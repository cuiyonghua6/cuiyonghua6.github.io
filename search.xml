<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[编写整洁的python代码（摘录）]]></title>
    <url>%2F2021%2F07%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20210726_%E7%BC%96%E5%86%99%E6%95%B4%E6%B4%81%E7%9A%84python%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[第 1章 简介、代码格式和工具1．1 代码整洁的意义1．2 代码整洁的重要性1．2．1 代码格式化在代码整洁中的作用 1．2．2 在项目中遵循编码风格准则 1．3 文档字符串和注解1．3．1 文档字符串 1．3．2 注解 9 1．3．3 注解是否会替代文档字符串 11 1．3．4 配置用于实施基本质量控制的工具 12 1．4 小结 16 第 2章 Python风格代码 2．1 索引和切片 18 2．2 上下文管理器 21 2．3 对象的属性、特性和不同类型的方法 26 2．3．1 Python中的下划线 27 2．3．2 属性 29 2．4 可迭代对象 31 2．4．1 创建可迭代对象 32 2．4．2 创建序列 34 2．5 容器对象 36 2．6 对象的动态属性 37 2．7 可调用对象 39 2．8 魔法方法概述 40 2．9 Python中的警告 41 2．9．1 可变的默认参数 41 2．9．2 扩展内置类型 42 2．10 小结 第3章 好代码的一般特征 3．1 契约式设计 3．1．1 前置条件3．1．2 后置条件3．1．3 Python的契约3．1．4 设计契约：结论3．2 防错性程序设计3．2．1 错误处理3．2．2 在Python中使用断言3．3 关注点分离3．4 常用缩略词3．4．1 DRY和OAOO3．4．2 YAGNI 623．4．3 KIS 633．4．4 EAFP和LBYL 643．5 组合和继承 653．5．1 什么时候继承是一个好的决定 663．5．2 反模式的继承 673．5．3 Python中的多重继承 693．6 函数和方法中的参数 723．6．1 Python函数的参数是如何工作的 733．6．2 函数中参数的数量 773．7 关于软件设计良好实践的结束语 803．7．1 软件的正交性 803．7．2 构建代码 823．8 小结 83第4章 SOLID原则 844．1 单一职责原则 844．1．1 一个有太多职责的类 854．1．2 分配责任 864．2 打开/关闭原则 874．2．1 不遵循打开/关闭原则的可维护性风险的示例 884．2．2 重构事件系统以获得可扩展性 904．2．3 扩展事件系统 924．2．4 关于OCP的结束语 944．3 里氏替换原则 944．3．1 使用工具检测LSP问题 954．3．2 更微妙的LSP违规案例 974．3．3 关于LSP需要注意的一些点 1004．4 接口隔离原则 1004．4．1 提供太多信息的接口 1024．4．2 接口越小越好 1024．4．3 接口应该多小 1034．5 依赖倒置原则 1034．5．1 一个严格依赖的案例 1044．5．2 倒置依赖 1044．6 小结 106第5章 用装饰器改进代码 1075．1 Python中的装饰器是什么 1075．1．1 装饰器函数 1085．1．2 装饰类 1095．1．3 其他类型的装饰器 1135．1．4 将参数传递给装饰器 1145．1．5 充分利用装饰器 1175．2 有效的装饰：避免常见的错误 1185．2．1 保存关于原始包装对象的数据 1185．2．2 处理装饰器中的副作用 1215．2．3 创建始终有效的装饰器 1255．3 装饰器的DRY原则 1285．4 装饰器和关注点分离 1295．5 好的装饰器的相关分析 1305．6 小结 132第6章 用描述符从对象中获取更多信息 1336．1 初探描述符 1336．1．1 描述符背后的机制 1336．1．2 研究描述符协议中的每个方法 1366．2 描述符的类型 1426．2．1 非数据描述符 1436．2．2 数据描述符 1456．3 描述符的实际应用 1476．3．1 描述符的一种应用 1476．3．2 实现描述符的不同形式 1516．3．3 关于描述符的更多考虑 1546．4 分析描述符 1586．4．1 Python内部如何使用描述符 1586．4．2 在装饰器中实现描述符 1636．5 小结 164第7章 使用生成器 1657．1 技术要求 1657．2 创建生成器 1657．2．1 初探生成器 1667．2．2 生成器表达式 1687．3 惯用迭代 1697．3．1 迭代的习惯用法 1697．3．2 Python中的迭代器模式 1757．4 协同程序 1797．4．1 使用生成器接口的方法 1797．4．2 更先进的协同程序 1847．5 异步编程 1917．6 小结 192第8章 单元测试和重构 1938．1 设计原则和单元测试 1938．1．1 关于其他形式的自动化测试的说明 1948．1．2 单元测试和敏捷软件开发 1958．1．3 单元测试和软件设计 1968．1．4 定义测试内容的边界 1998．2 测试的框架和工具 2008．2．1 用于单元测试的框架和库 2008．2．2 代码覆盖率 2098．2．3 模拟对象（Mock对象） 2118．3 代码重构 2168．3．1 代码演进 2168．3．2 需要演进的不仅仅是生产代码 2188．4 更多关于单元测试的信息 2208．4．1 基于属性的测试 2208．4．2 突变测试 2218．5 测试驱动开发的简要介绍 2238．6 小结 224第9章 常见的设计模式 2259．1 Python中设计模式的注意事项 2259．2 有效的设计模式 2279．2．1 创建型模式 2279．2．2 结构型模式 2339．2．3 行为模式 2409．3 空对象模式 2509．4 关于设计模式的最后想法 2529．4．1 模式对设计的影响 2529．4．2 模型中的名称 2539．5 小结 254第 10章 整洁架构 25510．1 从整洁代码到整洁架构 25510．1．1 关注点分离 25610．1．2 抽象 25710．2 软件组件 25810．2．1 包 25810．2．2 容器 26110．3 用例 26210．3．1 编码 26310．3．2 服务 26810．3．3 分析 27110．4 小结 273写在最后 274]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
        <tag>python优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python3代码整洁之道（摘录）]]></title>
    <url>%2F2021%2F07%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20210724_python%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%2F</url>
    <content type="text"><![CDATA[一. 关于python的思考 为什么range函数在python3中更好？ 有两件事range可以做到，但是python2中的xrange却做不到： # 1. range可以对2个数做比较 print(range(5) == range(5)) # true # 2. range可以做切片 print(range(10)[2:7])]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
        <tag>python优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Effective Python（摘录）]]></title>
    <url>%2F2021%2F07%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20210722_effective_python%2F</url>
    <content type="text"><![CDATA[静下心来去理解，收获颇多。 一. 培养Pythonic思维1. 查询自己使用的python版本import sys print(sys.version_info) print(sys.version) # 代码自动检查：https://pylint.org/ pip install pylint 2. 遵循PEP8风格指南官网：https://pep8.org/中文翻译：https://www.cnblogs.com/bymo/p/9567140.html 3. 了解bytes与str的区别bytes：bytes的实例包含原始的8个字节str：str的实例包含Unicode字符bytes # 接受str或bytes,并总是返回str的方法 def to_str(bytes_or_str): if isinstance(bytes_or_str,bytes): value = bytes_or_str.decode(&#39;utf-8&#39;) else: value = bytes_or_str return value # 接受str或bytes,并总是返回bytes的方法： def to_bytes(bytes_or_str): if isinstance(bytes_or_str,str): value = bytes_or_str.encode(&#39;utf-8&#39;) else: value = bytes_or_str return value 4. 用支持插值的f-string取代C风格的格式字符串和str.format方法pantry = [ (&#39;avocados&#39;, 1.25), (&#39;bananas&#39;, 2.5), (&#39;cherries&#39;, 15), ] for i, (item, count) in enumerate(pantry): print(f&#39;{i+1}: {item.title():&lt;10s} = {round(count)}&#39;) 5. 用辅助函数取代复杂的表达式from urllib.parse import parse_qs my_values = parse_qs(&#39;red=5&amp;blue=0&amp;green=3&#39;, keep_blank_values=True) print(repr(my_values)) green_str = my_values.get(&#39;green&#39;, [&#39;&#39;]) if green_str[0]: green = int(green_str[0]) else: green = 0 print(f&#39;Green: {green!r}&#39;) def get_first_int(values, key, default=0): found = values.get(key, [&#39;&#39;]) if found[0]: return int(found[0]) return default green = get_first_int(my_values, &#39;green&#39;) print(f&#39;Green: {green!r}&#39;) 6. 把数据结构直接拆分到多个变量里，不要专门通过下标访问snacks = [(&#39;bacon&#39;, 350), (&#39;donut&#39;, 240), (&#39;muffin&#39;, 190)] for i in range(len(snacks)): item = snacks[i] name = item[0] calories = item[1] print(f&#39;#{i + 1}: {name} has {calories} calories&#39;) for rank, (name, calories) in enumerate(snacks, 1): print(f&#39;#{rank}: {name} has {calories} calories&#39;) 7. 尽量用enumerate取代rangeflavor_list = [&#39;vanilla&#39;, &#39;chocolate&#39;, &#39;pecan&#39;, &#39;strawberry&#39;] for flavor in flavor_list: print(f&#39;{flavor} is delicious&#39;) for i in range(len(flavor_list)): flavor = flavor_list[i] print(f&#39;{i + 1}: {flavor}&#39;) # Example it = enumerate(flavor_list) print(next(it)) print(next(it)) for i, flavor in enumerate(flavor_list): print(f&#39;{i}: {flavor}&#39;) for i, flavor in enumerate(flavor_list, 2): # 从2开始 print(f&#39;enumerate {i}: {flavor}&#39;) 8. 用zip函数同时遍历两个迭代器# Example 1 names = [&#39;Cecilia&#39;, &#39;Lise&#39;, &#39;Marie&#39;] counts = [len(n) for n in names] print(counts, len(counts), len(names)) # Example 2 longest_name = &#39;None11&#39; max_count = 0 for i in range(len(names)): count = counts[i] if count &gt; max_count: longest_name = names[i] max_count = count print(longest_name) # Example 3 longest_name = None max_count = 0 for i, name in enumerate(names): count = counts[i] if count &gt; max_count: longest_name = name max_count = count print(&#39;--&#39;, longest_name) assert longest_name == &#39;Cecilia&#39; # Example 4 longest_name = None max_count = 0 for name, count in zip(names, counts): if count &gt; max_count: longest_name = name max_count = count assert longest_name == &#39;Cecilia&#39; # Example 5 names.append(&#39;Rosalind&#39;) # counts.append(8) print(f&#39;names: {names}, counts: {counts}&#39;) for name, count in zip(names, counts): print(name, count) # Example 6 import itertools for name, count in itertools.zip_longest(names, counts): print(f&#39;itertools: {name}: {count}&#39;) 9. 不要在for与while循环后面写else块 # Example 1 for i in range(3): print(&#39;Loop&#39;, i) else: print(&#39;Else block!&#39;) # Example a = 4 b = 9 for i in range(2, min(a, b) + 1): print(&#39;Testing&#39;, i) if a % i == 0 and b % i == 0: print(&#39;Not coprime&#39;) break else: print(&#39;Coprime&#39;) # 下面是应该的写法：方法一，只要发现某个方法成立，就立刻返回 def coprime(a, b): for i in range(2, min(a, b) + 1): if a % i == 0 and b % i == 0: return False return True assert coprime(4, 9) assert not coprime(3, 6) # 方法二，用变量记录循环过程中与没有碰到成立的情况，返回这个变量的值 def coprime_alternate(a, b): is_coprime = True for i in range(2, min(a, b) + 1): if a % i == 0 and b % i == 0: is_coprime = False break return is_coprime assert coprime_alternate(4, 9) assert not coprime_alternate(3, 6) 10. 用赋值表达式减少重复代码# -*- encoding: utf-8 -*- &quot;&quot;&quot; 赋值表达式通过海象操作符(:=)给变量赋值，并且让这个值成为这个表达式的结构 &quot;&quot;&quot; FRUIT_TO_PICK = [ {&#39;apple&#39;: 1, &#39;banana&#39;: 3}, {&#39;lemon&#39;: 2, &#39;lime&#39;: 5}, {&#39;orange&#39;: 3, &#39;melon&#39;: 2}, ] def pick_fruit(): if FRUIT_TO_PICK: return FRUIT_TO_PICK.pop(0) else: return [] def make_juice(fruit, count): return [(fruit, count)] bottles = [] while fresh_fruit := pick_fruit(): for fruit, count in fresh_fruit.items(): batch = make_juice(fruit, count) bottles.extend(batch) print(bottles) 二. 列表与字典11. 学会对序列做切片a = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;] print(&#39;Middle two: &#39;, a[3:5]) print(&#39;--:&#39;, a[-3:-1]) assert a[:5] == a[0:5] assert a[5:] == a[5:len(a)] print(a[2:-1]) print(a[-3:-1]) 12. 不要在切片里同时 起止下标与步进x = [&#39;red&#39;, &#39;orange&#39;, &#39;yellow&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;purple&#39;] print(f&#39;odds: {x[::2]}&#39;) # odds: [&#39;red&#39;, &#39;yellow&#39;, &#39;blue&#39;] print(f&#39;evens: {x[1::2]}&#39;) # evens: [&#39;orange&#39;, &#39;green&#39;, &#39;purple&#39;] print(b&#39;mongoose&#39;[::-1]) # b&#39;esoognom&#39; 13. 通过带星号的unpacking操作来捕获多个元素，不要用切片car_inventory = { &#39;Downtown&#39;: (&#39;Silver Shadow&#39;, &#39;Pinto&#39;, &#39;DMC&#39;), &#39;Airport&#39;: (&#39;Skyline&#39;, &#39;Viper&#39;, &#39;Gremlin&#39;, &#39;Nova&#39;), } ((loc1, (best1, *rest1)), (loc2, (best2, *rest2))) = car_inventory.items() print(f&#39;Best at {loc1} is {best1}, {len(rest1)} others&#39;) # Best at Downtown is Silver Shadow, 2 others print(f&#39;Best at {loc2} is {best2}, {len(rest2)} others&#39;) # Best at Airport is Skyline, 3 others short_list = [1, 2] first, second, *rest = short_list print(first, second, rest) # 3 1 2 [] def generate_csv(): yield &#39;Date&#39;, &#39;Make&#39;, &#39;Model&#39;, &#39;Year&#39;, &#39;Price&#39; for i in range(3): yield &#39;2019-03-25&#39;, &#39;Honda&#39;, &#39;Fit&#39;, &#39;2010&#39;, &#39;$3400&#39; yield &#39;2019-03-26&#39;, &#39;Ford&#39;, &#39;F150&#39;, &#39;2008&#39;, &#39;$2400&#39; all_csv_rows = list(generate_csv()) print(all_csv_rows) print(&#39;CSV Header:&#39;, all_csv_rows[0]) # CSV Header: (&#39;Date&#39;, &#39;Make&#39;, &#39;Model&#39;, &#39;Year&#39;, &#39;Price&#39;) print(&#39;Row count: &#39;, len(all_csv_rows[1:])) # Row count: 6 # Example 12 it = generate_csv() header, *rows = it print(&#39;CSV Header:&#39;, header) # CSV Header: (&#39;Date&#39;, &#39;Make&#39;, &#39;Model&#39;, &#39;Year&#39;, &#39;Price&#39;) print(&#39;Row count: &#39;, len(rows)) # Row count: 6 14. 用sort方法的key参数来表示复杂的排序逻辑numbers = [93, 86, 11, 68, 70] numbers.sort(reverse=True) # 由大到小排列 print(numbers) # Example 2 class Tool: def __init__(self, name, weight): self.name = name self.weight = weight def __repr__(self): return f&#39;Tool({self.name!r}, {self.weight})&#39; tools = [ Tool(&#39;level&#39;, 3.5), Tool(&#39;hammer&#39;, 1.25), Tool(&#39;screwdriver&#39;, 0.5), Tool(&#39;chisel&#39;, 0.25), ] # Example 4 print(&#39;Unsorted:&#39;, repr(tools)) tools.sort(key=lambda x: x.name) print(&#39;Sorted: &#39;, tools) # [Tool(&#39;chisel&#39;, 0.25), Tool(&#39;hammer&#39;, 1.25), Tool(&#39;level&#39;, 3.5), Tool(&#39;screwdriver&#39;, 0.5)] # Example 5 tools.sort(key=lambda x: x.weight) print(&#39;By weight:&#39;, tools) # [Tool(&#39;chisel&#39;, 0.25), Tool(&#39;screwdriver&#39;, 0.5), Tool(&#39;hammer&#39;, 1.25), Tool(&#39;level&#39;, 3.5)] # Example 6 places = [&#39;home&#39;, &#39;work&#39;, &#39;New York&#39;, &#39;Paris&#39;] places.sort() print(&#39;Case sensitive: &#39;, places) # [&#39;New York&#39;, &#39;Paris&#39;, &#39;home&#39;, &#39;work&#39;] places.sort(key=lambda x: x.lower()) print(&#39;Case insensitive:&#39;, places) # [&#39;home&#39;, &#39;New York&#39;, &#39;Paris&#39;, &#39;work&#39;] 15. 不要过分依赖给字典添加条目时所用的顺序baby_names = { &#39;cat&#39;: &#39;kitten&#39;, &#39;dog&#39;: &#39;puppy&#39;, } print(baby_names) print(list(baby_names.keys())) print(list(baby_names.values())) print(list(baby_names.items())) # [(&#39;cat&#39;, &#39;kitten&#39;), (&#39;dog&#39;, &#39;puppy&#39;)] print(baby_names.popitem()) # Last item inserted : (&#39;dog&#39;, &#39;puppy&#39;) class MyClass: def __init__(self): self.alligator = &#39;hatchling&#39; self.elephant = &#39;calf&#39; a = MyClass() for key, value in a.__dict__.items(): print(f&#39;{key} = {value}&#39;) # Example 9 votes = { &#39;otter&#39;: 1281, &#39;polar bear&#39;: 587, &#39;fox&#39;: 863, } def populate_ranks(votes, ranks): names = list(votes.keys()) names.sort(key=votes.get, reverse=True) for i, name in enumerate(names, 1): ranks[name] = i ranks = {} populate_ranks(votes, ranks) print(ranks) # {&#39;otter&#39;: 1, &#39;fox&#39;: 2, &#39;polar bear&#39;: 3} print(next(iter(ranks))) # otter from collections.abc import MutableMapping class SortedDict(MutableMapping): def __init__(self): self.data = {} def __getitem__(self, key): return self.data[key] def __setitem__(self, key, value): self.data[key] = value def __delitem__(self, key): del self.data[key] def __iter__(self): keys = list(self.data.keys()) keys.sort() for key in keys: yield key def __len__(self): return len(self.data) my_dict = SortedDict() my_dict[&#39;otter&#39;] = 1 my_dict[&#39;cheeta&#39;] = 2 my_dict[&#39;anteater&#39;] = 3 my_dict[&#39;deer&#39;] = 4 assert my_dict[&#39;otter&#39;] == 1 assert &#39;cheeta&#39; in my_dict del my_dict[&#39;cheeta&#39;] assert &#39;cheeta&#39; not in my_dict print(my_dict) expected = [(&#39;anteater&#39;, 3), (&#39;deer&#39;, 4), (&#39;otter&#39;, 1)] assert list(my_dict.items()) == expected assert not isinstance(my_dict, dict) # Example 14 sorted_ranks = SortedDict() populate_ranks(votes, sorted_ranks) print(sorted_ranks.data) # {&#39;otter&#39;: 1, &#39;fox&#39;: 2, &#39;polar bear&#39;: 3} print(next(iter(sorted_ranks))) # fox 16. 用get处理键不在字典中的情况，不要使用in与KeyError有4中方法处理键不在字典中的情况：in表达式，KeyError异常，get方法和setdefault方法。 counters = { &#39;pumpernickel&#39;: 2, &#39;sourdough&#39;: 1, } key = &#39;multigrain&#39; count = counters.get(key, 0) counters[key] = count + 1 print(counters) # {&#39;pumpernickel&#39;: 2, &#39;sourdough&#39;: 1, &#39;multigrain&#39;: 1} votes = { &#39;baguette&#39;: [&#39;Bob&#39;, &#39;Alice&#39;], &#39;ciabatta&#39;: [&#39;Coco&#39;, &#39;Deb&#39;], } key = &#39;brioche&#39; who = &#39;Elmer&#39; print(f&#39;votes pre: {votes}&#39;) # {&#39;baguette&#39;: [&#39;Bob&#39;, &#39;Alice&#39;], &#39;ciabatta&#39;: [&#39;Coco&#39;, &#39;Deb&#39;]} if key in votes: names = votes[key] else: votes[key] = names = [] print(votes) # {&#39;baguette&#39;: [&#39;Bob&#39;, &#39;Alice&#39;], &#39;ciabatta&#39;: [&#39;Coco&#39;, &#39;Deb&#39;], &#39;brioche&#39;: []} names.append(who) print(f&#39;votes: {votes}&#39;) # {&#39;baguette&#39;: [&#39;Bob&#39;, &#39;Alice&#39;], &#39;ciabatta&#39;: [&#39;Coco&#39;, &#39;Deb&#39;], &#39;brioche&#39;: [&#39;Elmer&#39;]} key = &#39;cornbread&#39; who = &#39;Kirk&#39; names = votes.setdefault(key, []) names.append(who) print(votes) # {&#39;baguette&#39;: [&#39;Bob&#39;, &#39;Alice&#39;], &#39;ciabatta&#39;: [&#39;Coco&#39;, &#39;Deb&#39;], &#39;brioche&#39;: [&#39;Elmer&#39;], &#39;cornbread&#39;: [&#39;Kirk&#39;]} data = {} key = &#39;foo&#39; value = [] data.setdefault(key, value) print(&#39;Before:&#39;, data) # Before: {&#39;foo&#39;: []} value.append(&#39;hello&#39;) print(&#39;After: &#39;, data) # After: {&#39;foo&#39;: [&#39;hello&#39;]} 17. 用defaultdict处理内部状态中缺失的元素，而不要用setdefaultclass Visits: def __init__(self): self.data = {} def add(self, country, city): city_set = self.data.setdefault(country, set()) city_set.add(city) visits = Visits() visits.add(&#39;Russia&#39;, &#39;Yekaterinburg&#39;) visits.add(&#39;Tanzania&#39;, &#39;Zanzibar&#39;) print(visits.data) # {&#39;Russia&#39;: {&#39;Yekaterinburg&#39;}, &#39;Tanzania&#39;: {&#39;Zanzibar&#39;}} print(&#39;-----------------------------&#39;) from collections import defaultdict # 推荐 class Visits: def __init__(self): self.data = defaultdict(set) def add(self, country, city): self.data[country].add(city) visits = Visits() visits.add(&#39;England&#39;, &#39;Bath&#39;) visits.add(&#39;England&#39;, &#39;London&#39;) print(visits.data) # defaultdict(&lt;class &#39;set&#39;&gt;, {&#39;England&#39;: {&#39;Bath&#39;}, &#39;England1&#39;: {&#39;London&#39;}}) 18. 学会利用missing构造依赖键的默认值path = &#39;account_9090.csv&#39; with open(path, &#39;wb&#39;) as f: f.write(b&#39;image data here 9090&#39;) def open_picture(profile_path): try: return open(profile_path, &#39;a+b&#39;) except OSError: print(f&#39;Failed to open path {profile_path}&#39;) raise class Pictures(dict): def __missing__(self, key): value = open_picture(key) self[key] = value return value pictures = Pictures() handle = pictures[path] handle.seek(0) image_data = handle.read() print(pictures) print(image_data) 19. 不要把函数返回的多个数值拆分到三个以上的变量中def get_stats(numbers): minimum = min(numbers) maximum = max(numbers) return minimum, maximum lengths = [63, 73, 72, 60, 67, 66, 71, 61, 72, 70] minimum, maximum = get_stats(lengths) # Two return values print(f&#39;Min: {minimum}, Max: {maximum}&#39;) 三. 函数20. 遇到意外状况时应该抛出异常，不要返回Nonedef careful_divide(a, b): try: return a / b except ZeroDivisionError: return None assert careful_divide(4, 2) == 2 assert careful_divide(0, 1) == 0 assert careful_divide(3, 6) == 0.5 assert careful_divide(1, 0) == None def careful_divide(a: float, b: float) -&gt; float: &quot;&quot;&quot;Divides a by b. Raises: ValueError: When the inputs cannot be divided. &quot;&quot;&quot; try: return a / b except ZeroDivisionError as e: print(f&#39;result: {e}&#39;) raise ValueError(f&#39;Invalid inputs: {e}&#39;) try: result = careful_divide(1, 0) assert False except ValueError: print(f&#39;result:&#39;) pass # Expected assert careful_divide(1, 5) == 0.2 21. 了解如何在闭包里面使用外围作用域中的变量 def sort_priority3(numbers, group): found = False def helper(x): # 把闭包里面的数据赋值给闭包外面的变量 nonlocal found # Added if x in group: found = True return (0, x) return (1, x) numbers.sort(key=helper) return found numbers = [8, 3, 1, 2, 5, 4, 7, 6] group = {2, 3, 5, 7} found = sort_priority3(numbers, group) assert found assert numbers == [2, 3, 5, 7, 1, 4, 6, 8] print(&#39;--------------下面是用辅助类来封装状态&#39;) class Sorter: def __init__(self, group): self.group = group self.found = False def __call__(self, x): if x in self.group: self.found = True return (0, x) return (1, x) sorter = Sorter(group) numbers.sort(key=sorter) assert sorter.found is True assert numbers == [2, 3, 5, 7, 1, 4, 6, 8] 22. 用数量可变的位置参数给函数设计清晰的参数列表def log(message, *values): # The only difference if not values: print(message) else: values_str = &#39;, &#39;.join(str(x) for x in values) print(f&#39;{message}: {values_str}&#39;) log(&#39;My numbers are&#39;, 1, 2) log(&#39;Hi there&#39;) # Much better 23. 用关键字参数来表示可选的行为def flow_rate(weight_diff, time_diff, period=1): &quot;&quot;&quot;流速：每秒的千克数&quot;&quot;&quot; return (weight_diff / time_diff) * period weight_diff = 0.5 time_diff = 3 flow = flow_rate(weight_diff, time_diff, period=2) print(f&#39;{flow:.3} kg per second&#39;) 24. 用None和docstring来描述默认值会变的参数import json from time import sleep from datetime import datetime from typing import Optional def log(message, when=None): &quot;&quot;&quot;Log a message with a timestamp. Args: message: Message to print. when: datetime of when the message occurred. Defaults to the present time. &quot;&quot;&quot; if when is None: when = datetime.now() print(f&#39;{when}: {message}&#39;) # Example log(&#39;Hi there!&#39;) sleep(0.1) log(&#39;Hello again!&#39;) def decode(data, default=None): &quot;&quot;&quot;Load JSON data from a string. Args: data: JSON data to decode. default: Value to return if decoding fails. Defaults to an empty dictionary. &quot;&quot;&quot; try: return json.loads(data) except ValueError: if default is None: default = {} return default foo = decode(&#39;bad data&#39;) foo[&#39;stuff&#39;] = 5 bar = decode(&#39;also bad&#39;) bar[&#39;meep&#39;] = 1 print(&#39;Foo:&#39;, foo) print(&#39;Bar:&#39;, bar) assert foo is not bar def log_typed(message: str, when: Optional[datetime] = None) -&gt; None: &quot;&quot;&quot;Log a message with a timestamp. Args: message: Message to print. when: datetime of when the message occurred. Defaults to the present time. &quot;&quot;&quot; if when is None: when = datetime.now() print(f&#39;{when}: {message}&#39;) log_typed(&#39;Hi there!&#39;) sleep(0.1) log_typed(&#39;Hello again!&#39;) 25. 用只能以关键字 和只能按位置传入的参数来设计清晰的参数列表def safe_division_e(numerator, denominator, ndigits=10, *, # Changed ignore_overflow=False, ignore_zero_division=False): try: fraction = numerator / denominator # Changed return round(fraction, ndigits) # Changed except OverflowError: if ignore_overflow: return 0 else: raise except ZeroDivisionError: if ignore_zero_division: return float(&#39;inf&#39;) else: raise result = safe_division_e(22, 7) print(result) # 3.1428571429 result = safe_division_e(22, 7, 5) print(result) # 3.14286 result = safe_division_e(22, 7, ndigits=2) print(result) # 3.14 26. 用functools.wraps定义函数修饰器import pickle from functools import wraps def trace(func): @wraps(func) def wrapper(*args, **kwargs): result = func(*args, **kwargs) print(f&#39;{func.__name__}({args!r}, {kwargs!r}) &#39; f&#39;-&gt; {result!r}&#39;) return result return wrapper @trace def fibonacci(n): &quot;&quot;&quot;Return the n-th Fibonacci number&quot;&quot;&quot; if n in (0, 1): return n return fibonacci(n - 2) + fibonacci(n - 1) help(fibonacci) print(pickle.dumps(fibonacci)) 四. 推导与生成27. 用列表推导取代map与filtera = range(1, 10) even_squares = [x**2 for x in a if x % 2 == 0] print(even_squares) alt = map(lambda x: x**2, filter(lambda x: x % 2 == 0, a)) assert even_squares == list(alt) # 字典推导 even_squares_dict = {x: x**2 for x in a if x % 2 == 0} threes_cubed_set = {x**3 for x in a if x % 3 == 0} print(even_squares_dict) print(threes_cubed_set) 28. 控制推导逻辑的子表达式不要超过两个matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] flat = [x for row in matrix for x in row] print(flat) squared = [[x**2 for x in row] for row in matrix] print(squared) 29. 用赋值表达式消除推导中的重复代码stock = { &#39;nails&#39;: 125, &#39;screws&#39;: 35, &#39;wingnuts&#39;: 8, &#39;washers&#39;: 24, } order = [&#39;screws&#39;, &#39;wingnuts&#39;, &#39;clips&#39;] found = ((name, batches) for name in order if (batches := get_batches(stock.get(name, 0), 8))) print(next(found)) print(next(found)) 30. 不要让函数直接返回列表，应该让它逐个生成列表里的值address_lines = &quot;&quot;&quot;Four score and seven years ago our fathers brought forth on this continent a new nation, conceived in liberty, and dedicated to the proposition that all men are created equal.&quot;&quot;&quot; with open(&#39;address.txt&#39;, &#39;w&#39;) as f: f.write(address_lines) import itertools with open(&#39;address.txt&#39;, &#39;r&#39;) as f: it = index_file(f) results = itertools.islice(it, 0, 10) print(list(results)) 31. 谨慎地迭代函数所收到的参数from collections.abc import Iterator def normalize_defensive(numbers): if isinstance(numbers, Iterator): # Another way to check raise TypeError(&#39;Must supply a container&#39;) total = sum(numbers) result = [] for value in numbers: percent = 100 * value / total result.append(percent) return result visits = [15, 35, 80] result = normalize_defensive(visits) # No error print(result, type(result)) it = iter(visits) try: normalize_defensive(it) except TypeError: pass else: assert False 32. 考虑用生成器表达式改写数据量较大的列表推导import random with open(&#39;my_file.txt&#39;, &#39;w&#39;) as f: for _ in range(10): f.write(&#39;a&#39; * random.randint(0, 100)) f.write(&#39;\n&#39;) value = [len(x) for x in open(&#39;my_file.txt&#39;)] print(value) it = (len(x) for x in open(&#39;my_file.txt&#39;)) print(it) print(next(it)) print(next(it)) roots = ((x, x**0.5) for x in it) print(next(roots)) 33. 通过yield from把多个生成器连起来用import timeit def child(): for i in range(1_000_000): yield i def slow(): for i in child(): yield i def fast(): yield from child() baseline = timeit.timeit( stmt=&#39;for _ in slow(): pass&#39;, globals=globals(), number=50) print(f&#39;Manual nesting {baseline:.2f}s&#39;) comparison = timeit.timeit( stmt=&#39;for _ in fast(): pass&#39;, globals=globals(), number=50) print(f&#39;Composed nesting {comparison:.2f}s&#39;) reduction = -(comparison - baseline) / baseline print(f&#39;{reduction:.1%} less time&#39;) 34. 不要用send给生成器注入数据import math def wave_cascading(amplitude_it, steps): step_size = 2 * math.pi / steps for step in range(steps): radians = step * step_size fraction = math.sin(radians) amplitude = next(amplitude_it) # Get next input output = amplitude * fraction yield output def complex_wave_cascading(amplitude_it): yield from wave_cascading(amplitude_it, 3) yield from wave_cascading(amplitude_it, 4) yield from wave_cascading(amplitude_it, 5) def run_cascading(): amplitudes = [7, 7, 7, 2, 2, 2, 2, 10, 10, 10, 10, 10] it = complex_wave_cascading(iter(amplitudes)) for amplitude in amplitudes: output = next(it) if output is None: print(f&#39;Output is None&#39;) else: print(f&#39;Output: {output:&gt;5.1f} {amplitude}&#39;) run_cascading() 35. 不要通过throw变换生成器的状态RESETS = [False, False, True, False, True, False, False, False, False, False, False, False, False] class Timer: def __init__(self, period): self.current = period self.period = period def reset(self): self.current = self.period def __iter__(self): while self.current: self.current -= 1 yield self.current def run(): timer = Timer(4) for current in timer: if RESETS.pop(0): timer.reset() print(f&#39;{current} ticks remaining&#39;) run() 36. 考虑用itertools拼装迭代器与生成器import itertools print(&#39;------- 一. 连接多个迭代器&#39;) # chain: 把多个迭代器从头到尾连成一个迭代器 it = itertools.chain([1, 2, 3], [4, 5, 6]) print(list(it)) # [1, 2, 3, 4, 5, 6] # repeat: 不停的输出某个值 it = itertools.repeat(&#39;hello&#39;, 3) print(list(it)) # [&#39;hello&#39;, &#39;hello&#39;, &#39;hello&#39;] # cycle: 循环的输出某段内容之间的元素 it = itertools.cycle([1, 2]) result = [next(it) for _ in range (10)] print(result) # [1, 2, 1, 2, 1, 2, 1, 2, 1, 2] # tee: 让一个迭代器分裂成多个平行的迭代器 it1, it2, it3 = itertools.tee([&#39;first&#39;, &#39;second&#39;], 3) print(list(it1)) # [&#39;first&#39;, &#39;second&#39;] print(list(it2)) # [&#39;first&#39;, &#39;second&#39;] print(list(it3)) # [&#39;first&#39;, &#39;second&#39;] # zip_longest： 和zip函数类似，但会用默认值填充 keys = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;] values = [1, 2] normal = list(zip(keys, values)) print(&#39;zip: &#39;, normal) # zip: [(&#39;one&#39;, 1), (&#39;two&#39;, 2)] it = itertools.zip_longest(keys, values, fillvalue=&#39;nope&#39;) longest = list(it) print(&#39;zip_longest:&#39;, longest) # zip_longest: [(&#39;one&#39;, 1), (&#39;two&#39;, 2), (&#39;three&#39;, &#39;nope&#39;)] print(&#39;------- 二. 过滤源迭代器中的元素&#39;) # islice： 按照下标切割源迭代器 values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] first_five = itertools.islice(values, 5) print(&#39;First five: &#39;, list(first_five)) # First five: [1, 2, 3, 4, 5] middle_odds = itertools.islice(values, 2, 8, 2) print(&#39;Middle odds:&#39;, list(middle_odds)) # Middle odds: [3, 5, 7] # takewhile: 一直从源迭代器里获取元素，直到返回false values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] less_than_seven = lambda x: x &lt; 7 it = itertools.takewhile(less_than_seven, values) print(list(it)) # [1, 2, 3, 4, 5, 6] # dropwhile: 一直跳过序列中的元素，直到返回true values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] less_than_seven = lambda x: x &lt; 7 it = itertools.dropwhile(less_than_seven, values) print(list(it)) # [7, 8, 9, 10] # filterfalse: 与内置的filter函数相反，输出false的那些元素 values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] evens = lambda x: x % 2 == 0 filter_result = filter(evens, values) print(&#39;Filter: &#39;, list(filter_result)) # Filter: [2, 4, 6, 8, 10] filter_false_result = itertools.filterfalse(evens, values) print(&#39;Filter false:&#39;, list(filter_false_result)) # Filter false: [1, 3, 5, 7, 9] print(&#39;------- 三. 从源迭代器中的元素合成新的元素&#39;) # accumulate： 从源迭代器中取出一个元素进行累加，和functools模块中的reduce函数其实是一样的 values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] sum_reduce = itertools.accumulate(values) print(&#39;Sum: &#39;, list(sum_reduce)) # Sum: [1, 3, 6, 10, 15, 21, 28, 36, 45, 55] def sum_modulo_20(first, second): output = first + second return output % 20 modulo_reduce = itertools.accumulate(values, sum_modulo_20) print(&#39;Modulo:&#39;, list(modulo_reduce)) # Modulo: [1, 3, 6, 10, 15, 1, 8, 16, 5, 15] # product： 从一个或多个源迭代器中获取元素，并计算笛卡尔积 single = itertools.product([1, 2], repeat=2) print(&#39;Single: &#39;, list(single)) # Single: [(1, 1), (1, 2), (2, 1), (2, 2)] multiple = itertools.product([1, 2], [&#39;a&#39;, &#39;b&#39;]) print(&#39;Multiple:&#39;, list(multiple)) # Multiple: [(1, &#39;a&#39;), (1, &#39;b&#39;), (2, &#39;a&#39;), (2, &#39;b&#39;)] # permutations： 输出迭代器中n个元素形成的每种 有序排列 it = itertools.permutations([1, 2, 3], 2) print(f&#39;permutations: {list(it)}&#39;) # permutations: [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)] # combinations： 输出迭代器中n个元素形成的每种 无序组合 it = itertools.combinations([1, 2, 3, 4], 2) print(list(it)) # [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)] # combinations_with_replacement：允许同一个元素在组合里多次出现 it = itertools.combinations_with_replacement([1, 2, 3], 2) print(list(it)) # [(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)] 五. 类与接口37. 用组合起来的类来实现多层结构，不要用嵌套的内置类型from collections import defaultdict from collections import namedtuple Grade = namedtuple(&#39;Grade&#39;, (&#39;score&#39;, &#39;weight&#39;)) class Subject: def __init__(self): self._grades = [] def report_grade(self, score, weight): self._grades.append(Grade(score, weight)) def average_grade(self): total, total_weight = 0, 0 for grade in self._grades: total += grade.score * grade.weight total_weight += grade.weight return total / total_weight class Student: def __init__(self): self._subjects = defaultdict(Subject) def get_subject(self, name): return self._subjects[name] def average_grade(self): total, count = 0, 0 for subject in self._subjects.values(): total += subject.average_grade() count += 1 return total / count class Gradebook: def __init__(self): self._students = defaultdict(Student) def get_student(self, name): return self._students[name] book = Gradebook() albert = book.get_student(&#39;Albert Einstein&#39;) math = albert.get_subject(&#39;Math&#39;) math.report_grade(75, 0.05) math.report_grade(65, 0.15) math.report_grade(70, 0.80) gym = albert.get_subject(&#39;Gym&#39;) gym.report_grade(100, 0.40) gym.report_grade(85, 0.60) print(albert.average_grade()) 38. 让简单的接口接受函数，而不是类的实例 # Example 1 names = [&#39;Socrates&#39;, &#39;Archimedes&#39;, &#39;Plato&#39;, &#39;Aristotle&#39;] names.sort(key=len) print(names) # [&#39;Plato&#39;, &#39;Socrates&#39;, &#39;Aristotle&#39;, &#39;Archimedes&#39;] # Example 2 def log_missing(): print(&#39;Key added&#39;) return 0 # Example 3 from collections import defaultdict current = {&#39;green&#39;: 12, &#39;blue&#39;: 3} increments = [ (&#39;red&#39;, 5), (&#39;blue&#39;, 17), (&#39;orange&#39;, 9), ] result = defaultdict(log_missing, current) print(&#39;Before:&#39;, dict(result)) # Before: {&#39;green&#39;: 12, &#39;blue&#39;: 3} for key, amount in increments: result[key] += amount print(&#39;After: &#39;, dict(result)) # After: {&#39;green&#39;: 12, &#39;blue&#39;: 20, &#39;red&#39;: 5, &#39;orange&#39;: 9} # Example 4 def increment_with_report(current, increments): added_count = 0 def missing(): nonlocal added_count # Stateful closure added_count += 1 return 0 result = defaultdict(missing, current) for key, amount in increments: result[key] += amount return result, added_count # Example 5 result, count = increment_with_report(current, increments) assert count == 2 print(result) # defaultdict(&lt;function increment_with_report.&lt;locals&gt;.missing at 0x7faa53a46ef0&gt;, {&#39;green&#39;: 12, &#39;blue&#39;: 20, &#39;red&#39;: 5, &#39;orange&#39;: 9}) # Example 6 class CountMissing: def __init__(self): self.added = 0 def missing(self): self.added += 1 return 0 # Example 7 counter = CountMissing() result = defaultdict(counter.missing, current) # Method ref for key, amount in increments: result[key] += amount assert counter.added == 2 print(result) # defaultdict(&lt;bound method CountMissing.missing of &lt;__main__.CountMissing object at 0x7faa53ac7810&gt;&gt;, {&#39;green&#39;: 12, &#39;blue&#39;: 20, &#39;red&#39;: 5, &#39;orange&#39;: 9}) # Example 8 class BetterCountMissing: def __init__(self): self.added = 0 def __call__(self): self.added += 1 return 0 counter = BetterCountMissing() assert counter() == 0 assert callable(counter) # Example 9 counter = BetterCountMissing() result = defaultdict(counter, current) # Relies on __call__ for key, amount in increments: result[key] += amount assert counter.added == 2 print(result) # defaultdict(&lt;__main__.BetterCountMissing object at 0x7faa53ac7990&gt;, {&#39;green&#39;: 12, &#39;blue&#39;: 20, &#39;red&#39;: 5, &#39;orange&#39;: 9}) 39. 通过@classmethod多态来构造同一体系中的各类对象# Example 1 class InputData: def read(self): raise NotImplementedError # Example 2 class PathInputData(InputData): def __init__(self, path): super().__init__() self.path = path def read(self): with open(self.path) as f: return f.read() # Example 3 class Worker: def __init__(self, input_data): self.input_data = input_data self.result = None def map(self): raise NotImplementedError def reduce(self, other): raise NotImplementedError # Example 4 class LineCountWorker(Worker): def map(self): data = self.input_data.read() self.result = data.count(&#39;\n&#39;) def reduce(self, other): self.result += other.result # Example 5 import os def generate_inputs(data_dir): for name in os.listdir(data_dir): yield PathInputData(os.path.join(data_dir, name)) # Example 6 def create_workers(input_list): workers = [] for input_data in input_list: workers.append(LineCountWorker(input_data)) return workers # Example 7 from threading import Thread def execute(workers): threads = [Thread(target=w.map) for w in workers] for thread in threads: thread.start() for thread in threads: thread.join() first, *rest = workers for worker in rest: first.reduce(worker) return first.result # Example 8 def mapreduce(data_dir): inputs = generate_inputs(data_dir) workers = create_workers(inputs) return execute(workers) # Example 9 import os import random def write_test_files(tmpdir): os.makedirs(tmpdir) for i in range(100): with open(os.path.join(tmpdir, str(i)), &#39;w&#39;) as f: f.write(&#39;\n&#39; * random.randint(0, 100)) tmpdir = &#39;test_inputs&#39; write_test_files(tmpdir) result = mapreduce(tmpdir) print(f&#39;There are {result} lines&#39;) # There are 4762 lines # Example 10 class GenericInputData: def read(self): raise NotImplementedError @classmethod def generate_inputs(cls, config): raise NotImplementedError # Example 11 class PathInputData(GenericInputData): def __init__(self, path): super().__init__() self.path = path def read(self): with open(self.path) as f: return f.read() @classmethod def generate_inputs(cls, config): data_dir = config[&#39;data_dir&#39;] for name in os.listdir(data_dir): yield cls(os.path.join(data_dir, name)) # Example 12 class GenericWorker: def __init__(self, input_data): self.input_data = input_data self.result = None def map(self): raise NotImplementedError def reduce(self, other): raise NotImplementedError @classmethod def create_workers(cls, input_class, config): workers = [] for input_data in input_class.generate_inputs(config): workers.append(cls(input_data)) return workers # Example 13 class LineCountWorker(GenericWorker): def map(self): data = self.input_data.read() self.result = data.count(&#39;\n&#39;) def reduce(self, other): self.result += other.result # Example 14 def mapreduce(worker_class, input_class, config): workers = worker_class.create_workers(input_class, config) return execute(workers) # Example 15 config = {&#39;data_dir&#39;: tmpdir} result = mapreduce(LineCountWorker, PathInputData, config) print(f&#39;There are {result} lines&#39;) # There are 4762 lines 40. 通过super初始化超类 # Example 1 class MyBaseClass: def __init__(self, value): self.value = value class MyChildClass(MyBaseClass): def __init__(self): MyBaseClass.__init__(self, 5) def times_two(self): return self.value * 2 foo = MyChildClass() assert foo.times_two() == 10 # Example 2 class TimesTwo: def __init__(self): self.value *= 2 class PlusFive: def __init__(self): self.value += 5 # Example 3 class OneWay(MyBaseClass, TimesTwo, PlusFive): def __init__(self, value): MyBaseClass.__init__(self, value) TimesTwo.__init__(self) PlusFive.__init__(self) # Example 4 foo = OneWay(5) print(&#39;First ordering value is (5 * 2) + 5 =&#39;, foo.value) # First ordering value is (5 * 2) + 5 = 15 # Example 5 class AnotherWay(MyBaseClass, PlusFive, TimesTwo): def __init__(self, value): MyBaseClass.__init__(self, value) TimesTwo.__init__(self) PlusFive.__init__(self) # Example 6 bar = AnotherWay(5) print(&#39;Second ordering value is&#39;, bar.value) # Second ordering value is 15 # Example 7 class TimesSeven(MyBaseClass): def __init__(self, value): MyBaseClass.__init__(self, value) self.value *= 7 class PlusNine(MyBaseClass): def __init__(self, value): MyBaseClass.__init__(self, value) self.value += 9 # Example 8 class ThisWay(TimesSeven, PlusNine): def __init__(self, value): TimesSeven.__init__(self, value) PlusNine.__init__(self, value) foo = ThisWay(5) print(&#39;Should be (5 * 7) + 9 = 44 but is&#39;, foo.value) # Should be (5 * 7) + 9 = 44 but is 14 # Example 9 class MyBaseClass: def __init__(self, value): self.value = value class TimesSevenCorrect(MyBaseClass): def __init__(self, value): super().__init__(value) self.value *= 7 class PlusNineCorrect(MyBaseClass): def __init__(self, value): super().__init__(value) self.value += 9 # Example 10 class GoodWay(TimesSevenCorrect, PlusNineCorrect): def __init__(self, value): super().__init__(value) foo = GoodWay(5) print(&#39;Should be 7 * (5 + 9) = 98 and is&#39;, foo.value) # Should be 7 * (5 + 9) = 98 and is 98 # Example 11 mro_str = &#39;\n&#39;.join(repr(cls) for cls in GoodWay.mro()) print(f&#39;mro_str: {mro_str}&#39;) # &lt;class &#39;__main__.GoodWay&#39;&gt; # Example 12 class ExplicitTrisect(MyBaseClass): def __init__(self, value): super(ExplicitTrisect, self).__init__(value) self.value /= 3 assert ExplicitTrisect(9).value == 3 # Example 13 class AutomaticTrisect(MyBaseClass): def __init__(self, value): super(__class__, self).__init__(value) self.value /= 3 class ImplicitTrisect(MyBaseClass): def __init__(self, value): super().__init__(value) self.value /= 3 assert ExplicitTrisect(9).value == 3 assert AutomaticTrisect(9).value == 3 assert ImplicitTrisect(9).value == 3 41. 考虑用mix-in类来表示可组合的功能# Example 1 class ToDictMixin: def to_dict(self): return self._traverse_dict(self.__dict__) # Example 2 def _traverse_dict(self, instance_dict): output = {} for key, value in instance_dict.items(): output[key] = self._traverse(key, value) return output def _traverse(self, key, value): if isinstance(value, ToDictMixin): return value.to_dict() elif isinstance(value, dict): return self._traverse_dict(value) elif isinstance(value, list): return [self._traverse(key, i) for i in value] elif hasattr(value, &#39;__dict__&#39;): return self._traverse_dict(value.__dict__) else: return value # Example 3 class BinaryTree(ToDictMixin): def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right # Example 4 tree = BinaryTree(10, left=BinaryTree(7, right=BinaryTree(9)), right=BinaryTree(13, left=BinaryTree(11))) print(tree.to_dict()) # {&#39;value&#39;: 10, &#39;left&#39;: {&#39;value&#39;: 7, &#39;left&#39;: None, &#39;right&#39;: {&#39;value&#39;: 9, &#39;left&#39;: None, &#39;right&#39;: None}}, &#39;right&#39;: {&#39;value&#39;: 13, &#39;left&#39;: {&#39;value&#39;: 11, &#39;left&#39;: None, &#39;right&#39;: None}, &#39;right&#39;: None}} # Example 5 class BinaryTreeWithParent(BinaryTree): def __init__(self, value, left=None, right=None, parent=None): super().__init__(value, left=left, right=right) self.parent = parent # Example 6 def _traverse(self, key, value): if (isinstance(value, BinaryTreeWithParent) and key == &#39;parent&#39;): return value.value # Prevent cycles else: return super()._traverse(key, value) # Example 7 root = BinaryTreeWithParent(10) root.left = BinaryTreeWithParent(7, parent=root) root.left.right = BinaryTreeWithParent(9, parent=root.left) print(root.to_dict()) # {&#39;value&#39;: 10, &#39;left&#39;: {&#39;value&#39;: 7, &#39;left&#39;: None, &#39;right&#39;: {&#39;value&#39;: 9, &#39;left&#39;: None, &#39;right&#39;: None, &#39;parent&#39;: 7}, &#39;parent&#39;: 10}, &#39;right&#39;: None, &#39;parent&#39;: None} # Example 8 class NamedSubTree(ToDictMixin): def __init__(self, name, tree_with_parent): self.name = name self.tree_with_parent = tree_with_parent my_tree = NamedSubTree(&#39;foobar&#39;, root.left.right) print(f&#39;my_tree.to_dict(): {my_tree.to_dict()}&#39;) # my_tree.to_dict(): {&#39;name&#39;: &#39;foobar&#39;, &#39;tree_with_parent&#39;: {&#39;value&#39;: 9, &#39;left&#39;: None, &#39;right&#39;: None, &#39;parent&#39;: 7}} # Example 9 import json class JsonMixin: @classmethod def from_json(cls, data): kwargs = json.loads(data) return cls(**kwargs) def to_json(self): return json.dumps(self.to_dict()) # Example 10 class DatacenterRack(ToDictMixin, JsonMixin): def __init__(self, switch=None, machines=None): self.switch = Switch(**switch) self.machines = [ Machine(**kwargs) for kwargs in machines] class Switch(ToDictMixin, JsonMixin): def __init__(self, ports=None, speed=None): self.ports = ports self.speed = speed class Machine(ToDictMixin, JsonMixin): def __init__(self, cores=None, ram=None, disk=None): self.cores = cores self.ram = ram self.disk = disk # Example 11 serialized = &quot;&quot;&quot;{ &quot;switch&quot;: {&quot;ports&quot;: 5, &quot;speed&quot;: 1e9}, &quot;machines&quot;: [ {&quot;cores&quot;: 8, &quot;ram&quot;: 32e9, &quot;disk&quot;: 5e12}, {&quot;cores&quot;: 4, &quot;ram&quot;: 16e9, &quot;disk&quot;: 1e12}, {&quot;cores&quot;: 2, &quot;ram&quot;: 4e9, &quot;disk&quot;: 500e9} ] }&quot;&quot;&quot; deserialized = DatacenterRack.from_json(serialized) roundtrip = deserialized.to_json() assert json.loads(serialized) == json.loads(roundtrip) 42. 优先考虑用public属性表示应受保护的数据，不要用private属性表示class ApiClass: def __init__(self): self._value = 5 def get(self): return self._value class Child(ApiClass): def __init__(self): super().__init__() self._value = &#39;hello&#39; # Conflicts a = Child() print(f&#39;{a.get()} and {a._value} should be different&#39;) # hello and hello should be different # Example 15 class ApiClass: def __init__(self): self.__value = 5 # Double underscore def get(self): return self.__value # Double underscore class Child(ApiClass): def __init__(self): super().__init__() self._value = &#39;hello&#39; # OK! a = Child() print(f&#39;{a.get()} and {a._value} are different&#39;) # 5 and hello are different 43. 自定义的容器类型应该从collections.abc继承from collections.abc import Sequence class BinaryNode: def __init__(self, value, left=None, right=None): self.value = value self.left = left self.right = right class IndexableNode(BinaryNode): def _traverse(self): if self.left is not None: yield from self.left._traverse() yield self if self.right is not None: yield from self.right._traverse() def __getitem__(self, index): for i, item in enumerate(self._traverse()): if i == index: return item.value raise IndexError(f&#39;Index {index} is out of range&#39;) class SequenceNode(IndexableNode): def __len__(self): for count, _ in enumerate(self._traverse(), 1): pass return count class BetterNode(SequenceNode, Sequence): pass tree = BetterNode( 10, left=BetterNode( 5, left=BetterNode(2), right=BetterNode( 6, right=BetterNode(7))), right=BetterNode( 15, left=BetterNode(11)) ) print(&#39;Index of 7 is&#39;, tree.index(7)) # Index of 7 is 3 print(&#39;Count of 10 is&#39;, tree.count(10)) # Count of 10 is 1 六. 元类与属性44. 用纯属性与修饰器取代旧式的setter与getter方法class Resistor: def __init__(self, ohms): self.ohms = ohms self.voltage = 0 self.current = 0 class MysteriousResistor(Resistor): @property def ohms(self): self.voltage = self._ohms * self.current return self._ohms @ohms.setter def ohms(self, ohms): self._ohms = ohms # Example r7 = MysteriousResistor(10) r7.current = 0.01 print(f&#39;Before: {r7.voltage:.2f}&#39;) # Before: 0.00 print(r7.ohms) # 10 print(f&#39;After: {r7.voltage:.2f}&#39;) # After: 0.10 45. 考虑用@property实现新的属性访问逻辑，不要急着重构原有的代码# Example 1 from datetime import datetime, timedelta class Bucket: def __init__(self, period): self.period_delta = timedelta(seconds=period) self.reset_time = datetime.now() self.quota = 0 def __repr__(self): return f&#39;Bucket(quota={self.quota})&#39; bucket = Bucket(60) print(bucket) # Bucket(quota=0) # Example 2 def fill(bucket, amount): now = datetime.now() if (now - bucket.reset_time) &gt; bucket.period_delta: bucket.quota = 0 bucket.reset_time = now bucket.quota += amount # Example 3 def deduct(bucket, amount): now = datetime.now() if (now - bucket.reset_time) &gt; bucket.period_delta: return False # Bucket hasn&#39;t been filled this period if bucket.quota - amount &lt; 0: return False # Bucket was filled, but not enough bucket.quota -= amount return True # Bucket had enough, quota consumed # Example 4 bucket = Bucket(60) fill(bucket, 100) print(bucket) # Bucket(quota=100) # Example 5 if deduct(bucket, 99): print(&#39;Had 99 quota&#39;) # Had 99 quota else: print(&#39;Not enough for 99 quota&#39;) print(bucket) # Bucket(quota=1) # Example 6 if deduct(bucket, 3): print(&#39;Had 3 quota&#39;) else: print(&#39;Not enough for 3 quota&#39;) # Not enough for 3 quota print(bucket) # Bucket(quota=1) # Example 7 class NewBucket: def __init__(self, period): self.period_delta = timedelta(seconds=period) self.reset_time = datetime.now() self.max_quota = 0 self.quota_consumed = 0 def __repr__(self): return (f&#39;NewBucket(max_quota={self.max_quota}, &#39; f&#39;quota_consumed={self.quota_consumed})&#39;) # Example 8 @property def quota(self): return self.max_quota - self.quota_consumed # Example 9 @quota.setter def quota(self, amount): delta = self.max_quota - amount if amount == 0: # Quota being reset for a new period self.quota_consumed = 0 self.max_quota = 0 elif delta &lt; 0: # Quota being filled during the period self.max_quota = amount + self.quota_consumed else: # Quota being consumed during the period self.quota_consumed = delta # Example 10 bucket = NewBucket(60) print(&#39;Initial&#39;, bucket) # Initial NewBucket(max_quota=0, quota_consumed=0) fill(bucket, 100) print(&#39;Filled&#39;, bucket) # Filled NewBucket(max_quota=100, quota_consumed=0) if deduct(bucket, 99): print(&#39;Had 99 quota&#39;) # Had 99 quota else: print(&#39;Not enough for 99 quota&#39;) print(&#39;Now&#39;, bucket) # Now NewBucket(max_quota=100, quota_consumed=99) if deduct(bucket, 3): print(&#39;Had 3 quota&#39;) # Not enough for 3 quota else: print(&#39;Not enough for 3 quota&#39;) print(&#39;Still&#39;, bucket) # Still NewBucket(max_quota=100, quota_consumed=99) # Example 11 bucket = NewBucket(6000) assert bucket.max_quota == 0 assert bucket.quota_consumed == 0 assert bucket.quota == 0 fill(bucket, 100) assert bucket.max_quota == 100 assert bucket.quota_consumed == 0 assert bucket.quota == 100 assert deduct(bucket, 10) assert bucket.max_quota == 100 assert bucket.quota_consumed == 10 assert bucket.quota == 90 assert deduct(bucket, 20) assert bucket.max_quota == 100 assert bucket.quota_consumed == 30 assert bucket.quota == 70 fill(bucket, 50) assert bucket.max_quota == 150 assert bucket.quota_consumed == 30 assert bucket.quota == 120 assert deduct(bucket, 40) assert bucket.max_quota == 150 assert bucket.quota_consumed == 70 assert bucket.quota == 80 assert not deduct(bucket, 81) assert bucket.max_quota == 150 assert bucket.quota_consumed == 70 assert bucket.quota == 80 bucket.reset_time += bucket.period_delta - timedelta(1) assert bucket.quota == 80 assert not deduct(bucket, 79) fill(bucket, 1) assert bucket.quota == 1 46. 用描述符来改写需要复用的@property方法 # Example 1 class Homework: def __init__(self): self._grade = 0 @property def grade(self): return self._grade @grade.setter def grade(self, value): if not (0 &lt;= value &lt;= 100): raise ValueError( &#39;Grade must be between 0 and 100&#39;) self._grade = value # Example 2 galileo = Homework() galileo.grade = 95 assert galileo.grade == 95 # Example 3 class Exam: def __init__(self): self._writing_grade = 0 self._math_grade = 0 @staticmethod def _check_grade(value): if not (0 &lt;= value &lt;= 100): raise ValueError( &#39;Grade must be between 0 and 100&#39;) # Example 4 @property def writing_grade(self): return self._writing_grade @writing_grade.setter def writing_grade(self, value): self._check_grade(value) self._writing_grade = value @property def math_grade(self): return self._math_grade @math_grade.setter def math_grade(self, value): self._check_grade(value) self._math_grade = value galileo = Exam() galileo.writing_grade = 85 galileo.math_grade = 99 assert galileo.writing_grade == 85 assert galileo.math_grade == 99 # Example 5 class Grade: def __get__(self, instance, instance_type): pass def __set__(self, instance, value): pass class Exam: # Class attributes math_grade = Grade() writing_grade = Grade() science_grade = Grade() # Example 6 exam = Exam() exam.writing_grade = 40 # Example 7 Exam.__dict__[&#39;writing_grade&#39;].__set__(exam, 40) # Example 8 exam.writing_grade # Example 9 Exam.__dict__[&#39;writing_grade&#39;].__get__(exam, Exam) # Example 10 class Grade: def __init__(self): self._value = 0 def __get__(self, instance, instance_type): return self._value def __set__(self, instance, value): if not (0 &lt;= value &lt;= 100): raise ValueError( &#39;Grade must be between 0 and 100&#39;) self._value = value # Example 11 class Exam: math_grade = Grade() writing_grade = Grade() science_grade = Grade() first_exam = Exam() first_exam.writing_grade = 82 first_exam.science_grade = 99 print(&#39;Writing&#39;, first_exam.writing_grade) # Writing 82 print(&#39;Science&#39;, first_exam.science_grade) # Science 99 # Example 12 second_exam = Exam() second_exam.writing_grade = 75 print(f&#39;Second {second_exam.writing_grade} is right&#39;) # Second 75 is right print(f&#39;First {first_exam.writing_grade} is wrong; should be 82&#39;) # First 75 is wrong; should be 82 # Example 13 class Grade: def __init__(self): self._values = {} def __get__(self, instance, instance_type): if instance is None: return self return self._values.get(instance, 0) def __set__(self, instance, value): if not (0 &lt;= value &lt;= 100): raise ValueError( &#39;Grade must be between 0 and 100&#39;) self._values[instance] = value # Example 14 from weakref import WeakKeyDictionary class Grade: def __init__(self): self._values = WeakKeyDictionary() def __get__(self, instance, instance_type): if instance is None: return self return self._values.get(instance, 0) def __set__(self, instance, value): if not (0 &lt;= value &lt;= 100): raise ValueError(&#39;Grade must be between 0 and 100&#39;) self._values[instance] = value # Example 15 class Exam: math_grade = Grade() writing_grade = Grade() science_grade = Grade() first_exam = Exam() first_exam.writing_grade = 82 second_exam = Exam() second_exam.writing_grade = 75 print(f&#39;First {first_exam.writing_grade} is right&#39;) # First 82 is right print(f&#39;Second {second_exam.writing_grade} is right&#39;) # Second 75 is right 47. 针对惰性属性使用__getattr__、__getattribute__及 __setattr__class DictionaryRecord: def __init__(self, data): self._data = data def __getattribute__(self, name): # Prevent weird interactions with isinstance() used # by example code harness. if name == &#39;__class__&#39;: return DictionaryRecord print(f&#39;* Called __getattribute__({name!r})&#39;) # * Called __getattribute__(&#39;foo&#39;) data_dict = super().__getattribute__(&#39;_data&#39;) return data_dict[name] data = DictionaryRecord({&#39;foo&#39;: 3}) print(&#39;foo: &#39;, data.foo) # foo: 3 48. 用init_subclass验证子类写得是否正确class ValidatePolygon(type): def __new__(meta, name, bases, class_dict): # Only validate non-root classes if not class_dict.get(&#39;is_root&#39;): if class_dict[&#39;sides&#39;] &lt; 3: raise ValueError(&#39;Polygons need 3+ sides&#39;) return type.__new__(meta, name, bases, class_dict) class Polygon(metaclass=ValidatePolygon): is_root = True sides = None # Must be specified by subclasses class ValidateFilledPolygon(ValidatePolygon): def __new__(meta, name, bases, class_dict): # Only validate non-root classes if not class_dict.get(&#39;is_root&#39;): if class_dict[&#39;color&#39;] not in (&#39;red&#39;, &#39;green&#39;): raise ValueError(&#39;Fill color must be supported&#39;) return super().__new__(meta, name, bases, class_dict) class FilledPolygon(Polygon, metaclass=ValidateFilledPolygon): is_root = True color = None # Must be specified by subclasses # Example 9 class GreenPentagon(FilledPolygon): color = &#39;green&#39; sides = 5 greenie = GreenPentagon() print(greenie, type(greenie)) # &lt;__main__.GreenPentagon object at 0x7fac8bccd8d0&gt; &lt;class &#39;__main__.GreenPentagon&#39;&gt; print(Polygon, type(Polygon)) # &lt;class &#39;__main__.Polygon&#39;&gt; &lt;class &#39;__main__.ValidatePolygon&#39;&gt; assert isinstance(greenie, Polygon) # 下面是基本的菱形继承体系 class Top: def __init_subclass__(cls): super().__init_subclass__() print(f&#39;Top for {cls}&#39;) class Left(Top): def __init_subclass__(cls): super().__init_subclass__() # print(f&#39;Left for {cls}&#39;) class Right(Top): def __init_subclass__(cls): super().__init_subclass__() print(f&#39;Right for {cls}&#39;) class Bottom(Left, Right): def __init_subclass__(cls): super().__init_subclass__() print(f&#39;Bottom for {cls}&#39;) &quot;&quot;&quot;打印结果如下： Top for &lt;class &#39;__main__.Left&#39;&gt; Top for &lt;class &#39;__main__.Right&#39;&gt; Top for &lt;class &#39;__main__.Bottom&#39;&gt; Right for &lt;class &#39;__main__.Bottom&#39;&gt; Left for &lt;class &#39;__main__.Bottom&#39;&gt;&quot;&quot;&quot; 49. 用init_subclass记录现有的子类import json registry = {} def register_class(target_class): registry[target_class.__name__] = target_class def deserialize(data): params = json.loads(data) name = params[&#39;class&#39;] target_class = registry[name] return target_class(*params[&#39;args&#39;]) class BetterSerializable: def __init__(self, *args): self.args = args def serialize(self): return json.dumps({ &#39;class&#39;: self.__class__.__name__, &#39;args&#39;: self.args, }) def __repr__(self): name = self.__class__.__name__ args_str = &#39;, &#39;.join(str(x) for x in self.args) return f&#39;{name}({args_str})&#39; class BetterRegisteredSerializable(BetterSerializable): def __init_subclass__(cls): super().__init_subclass__() register_class(cls) class Vector1D(BetterRegisteredSerializable): def __init__(self, magnitude): super().__init__(magnitude) self.magnitude = magnitude before = Vector1D(6) print(&#39;Before:&#39;, before) # Before: Vector1D(6) data = before.serialize() print(&#39;Serialized:&#39;, data) # Serialized: {&quot;class&quot;: &quot;Vector1D&quot;, &quot;args&quot;: [6]} print(&#39;After: &#39;, deserialize(data)) # After: Vector1D(6) 50. 用__set_name__给类属性加注解class Field: def __init__(self): self.name = None self.internal_name = None def __set_name__(self, owner, name): # Called on class creation for each descriptor self.name = name self.internal_name = &#39;_&#39; + name def __get__(self, instance, instance_type): if instance is None: return self return getattr(instance, self.internal_name, &#39;&#39;) def __set__(self, instance, value): setattr(instance, self.internal_name, value) # Example class FixedCustomer: first_name = Field() last_name = Field() prefix = Field() suffix = Field() cust = FixedCustomer() print(f&#39;Before: {cust.first_name!r} {cust.__dict__}&#39;) # Before: &#39;&#39; {} cust.first_name = &#39;Mersenne&#39; print(f&#39;After: {cust.first_name!r} {cust.__dict__}&#39;) # After: &#39;Mersenne&#39; {&#39;_first_name&#39;: &#39;Mersenne&#39;} 51. 优先考虑通过类修饰器来提供可组合的扩充功能，不要使用元类import types from functools import wraps trace_types = ( types.MethodType, types.FunctionType, types.BuiltinFunctionType, types.BuiltinMethodType, types.MethodDescriptorType, types.ClassMethodDescriptorType) def trace_func(func): if hasattr(func, &#39;tracing&#39;): # Only decorate once return func @wraps(func) def wrapper(*args, **kwargs): result = None try: result = func(*args, **kwargs) return result except Exception as e: result = e raise finally: print(f&#39;{func.__name__}({args!r}, {kwargs!r}) -&gt; {result!r}&#39;) wrapper.tracing = True return wrapper # Example def my_class_decorator(klass): klass.extra_param = &#39;hello&#39; return klass @my_class_decorator class MyClass: pass print(MyClass) # &lt;class &#39;__main__.MyClass&#39;&gt; print(MyClass.extra_param) # hello # Example def trace(klass): for key in dir(klass): value = getattr(klass, key) if isinstance(value, trace_types): wrapped = trace_func(value) setattr(klass, key, wrapped) return klass # Example @trace class TraceDict(dict): pass trace_dict = TraceDict([(&#39;hi&#39;, 1)]) trace_dict[&#39;there&#39;] = 2 try: trace_dict[&#39;does not exist&#39;] except KeyError: pass # Expected else: assert False # Example 11 class OtherMeta(type): pass @trace class TraceDict(dict, metaclass=OtherMeta): pass trace_dict = TraceDict([(&#39;hi&#39;, 1)]) trace_dict[&#39;there&#39;] = 2 try: trace_dict[&#39;does not exist&#39;] except KeyError: pass # Expected else: assert False &quot;&quot;&quot; &lt;class &#39;__main__.MyClass&#39;&gt; hello __new__((&lt;class &#39;__main__.TraceDict&#39;&gt;, [(&#39;hi&#39;, 1)]), {}) -&gt; {} __getitem__(({&#39;hi&#39;: 1, &#39;there&#39;: 2}, &#39;does not exist&#39;), {}) -&gt; KeyError(&#39;does not exist&#39;) __new__((&lt;class &#39;__main__.TraceDict&#39;&gt;, [(&#39;hi&#39;, 1)]), {}) -&gt; {} __getitem__(({&#39;hi&#39;: 1, &#39;there&#39;: 2}, &#39;does not exist&#39;), {}) -&gt; KeyError(&#39;does not exist&#39;) &quot;&quot;&quot; 七. 并发与并行52. 用subprocess管理子进程 # Example 1 import subprocess # Enable these lines to make this example work on Windows # import os # os.environ[&#39;COMSPEC&#39;] = &#39;powershell&#39; result = subprocess.run( [&#39;echo&#39;, &#39;Hello from the child!&#39;], capture_output=True, # Enable this line to make this example work on Windows # shell=True, encoding=&#39;utf-8&#39;) result.check_returncode() # No exception means it exited cleanly print(result.stdout) # Example 2 # Use this line instead to make this example work on Windows # proc = subprocess.Popen([&#39;sleep&#39;, &#39;1&#39;], shell=True) proc = subprocess.Popen([&#39;sleep&#39;, &#39;1&#39;]) while proc.poll() is None: print(&#39;Working...&#39;) # Some time-consuming work here import time time.sleep(0.3) print(&#39;Exit status&#39;, proc.poll()) # Example 3 import time start = time.time() sleep_procs = [] for _ in range(10): # Use this line instead to make this example work on Windows # proc = subprocess.Popen([&#39;sleep&#39;, &#39;1&#39;], shell=True) proc = subprocess.Popen([&#39;sleep&#39;, &#39;1&#39;]) sleep_procs.append(proc) # Example 4 for proc in sleep_procs: proc.communicate() end = time.time() delta = end - start print(f&#39;Finished in {delta:.3} seconds&#39;) # Example 5 import os # On Windows, after installing OpenSSL, you may need to # alias it in your PowerShell path with a command like: # $env:path = $env:path + &quot;;C:\Program Files\OpenSSL-Win64\bin&quot; def run_encrypt(data): env = os.environ.copy() env[&#39;password&#39;] = &#39;zf7ShyBhZOraQDdE/FiZpm/m/8f9X+M1&#39; proc = subprocess.Popen( [&#39;openssl&#39;, &#39;enc&#39;, &#39;-des3&#39;, &#39;-pass&#39;, &#39;env:password&#39;], env=env, stdin=subprocess.PIPE, stdout=subprocess.PIPE) proc.stdin.write(data) proc.stdin.flush() # Ensure that the child gets input return proc # Example 6 procs = [] for _ in range(3): data = os.urandom(10) proc = run_encrypt(data) procs.append(proc) # Example 7 for proc in procs: out, _ = proc.communicate() print(f&#39;out[-10:] {out[-10:]}&#39;) # Example 8 def run_hash(input_stdin): return subprocess.Popen( [&#39;openssl&#39;, &#39;dgst&#39;, &#39;-whirlpool&#39;, &#39;-binary&#39;], stdin=input_stdin, stdout=subprocess.PIPE) # Example 9 encrypt_procs = [] hash_procs = [] for _ in range(3): data = os.urandom(100) encrypt_proc = run_encrypt(data) encrypt_procs.append(encrypt_proc) hash_proc = run_hash(encrypt_proc.stdout) hash_procs.append(hash_proc) # Ensure that the child consumes the input stream and # the communicate() method doesn&#39;t inadvertently steal # input from the child. Also lets SIGPIPE propagate to # the upstream process if the downstream process dies. encrypt_proc.stdout.close() encrypt_proc.stdout = None # Example 10 for proc in encrypt_procs: proc.communicate() assert proc.returncode == 0 for proc in hash_procs: out, _ = proc.communicate() print(out[-10:]) assert proc.returncode == 0 # Example 11 # Use this line instead to make this example work on Windows # proc = subprocess.Popen([&#39;sleep&#39;, &#39;10&#39;], shell=True) proc = subprocess.Popen([&#39;sleep&#39;, &#39;10&#39;]) try: proc.communicate(timeout=0.1) except subprocess.TimeoutExpired: proc.terminate() proc.wait() print(&#39;Exit status&#39;, proc.poll()) 53. 可以用线程执行阻塞式I/O，但不要用它做并行计算 # Example 1 def factorize(number): for i in range(1, number + 1): if number % i == 0: yield i # Example 2 import time numbers = [2139079, 1214759, 1516637, 1852285] start = time.time() for number in numbers: list(factorize(number)) end = time.time() delta = end - start print(f&#39;Took {delta:.4f} seconds&#39;) # Took 0.4613 seconds # Example 3 from threading import Thread class FactorizeThread(Thread): def __init__(self, number): super().__init__() self.number = number def run(self): self.factors = list(factorize(self.number)) # Example 4 start = time.time() threads = [] for number in numbers: thread = FactorizeThread(number) thread.start() threads.append(thread) # Example 5 for thread in threads: thread.join() end = time.time() delta = end - start print(f&#39;Took {delta:.3f} seconds&#39;) # Took 0.448 seconds # Example 6 import select import socket def slow_systemcall(): select.select([socket.socket()], [], [], 0.1) # Example 7 start = time.time() for _ in range(5): slow_systemcall() end = time.time() delta = end - start print(f&#39;Took {delta:.3f} seconds...&#39;) # Took 0.517 seconds... # Example 8 start = time.time() threads = [] for _ in range(5): thread = Thread(target=slow_systemcall) thread.start() threads.append(thread) # Example 9 def compute_helicopter_location(index): pass for i in range(5): compute_helicopter_location(i) for thread in threads: thread.join() end = time.time() delta = end - start print(f&#39;Took {delta:.3f} seconds&#39;) # Took 0.102 seconds 54. 利用Lock防止多个线程争用同一份数据 # Example 1 class Counter: def __init__(self): self.count = 0 def increment(self, offset): self.count += offset # Example 2 def worker(sensor_index, how_many, counter): # I have a barrier in here so the workers synchronize # when they start counting, otherwise it&#39;s hard to get a race # because the overhead of starting a thread is high. BARRIER.wait() for _ in range(how_many): # Read from the sensor # Nothing actually happens here, but this is where # the blocking I/O would go. counter.increment(1) # Example 3 from threading import Barrier BARRIER = Barrier(5) from threading import Thread how_many = 10**5 counter = Counter() threads = [] for i in range(5): thread = Thread(target=worker, args=(i, how_many, counter)) threads.append(thread) thread.start() for thread in threads: thread.join() expected = how_many * 5 found = counter.count print(f&#39;Counter should be {expected}, got {found}&#39;) # Counter should be 500000, got 325923 # Example 4 counter.count += 1 # Example 5 value = getattr(counter, &#39;count&#39;) result = value + 1 setattr(counter, &#39;count&#39;, result) # Example 6 # Running in Thread A value_a = getattr(counter, &#39;count&#39;) # Context switch to Thread B value_b = getattr(counter, &#39;count&#39;) result_b = value_b + 1 setattr(counter, &#39;count&#39;, result_b) # Context switch back to Thread A result_a = value_a + 1 setattr(counter, &#39;count&#39;, result_a) # Example 7 from threading import Lock class LockingCounter: def __init__(self): self.lock = Lock() self.count = 0 def increment(self, offset): with self.lock: self.count += offset # Example 8 BARRIER = Barrier(5) counter = LockingCounter() for i in range(5): thread = Thread(target=worker, args=(i, how_many, counter)) threads.append(thread) thread.start() for thread in threads: thread.join() expected = how_many * 5 found = counter.count print(f&#39;Counter should be {expected}, got {found}&#39;) # Counter should be 500000, got 500000 55. 用Queue来协调各线程之间的工作进度 # Example 1 def download(item): return item def resize(item): return item def upload(item): return item # Example 2 from collections import deque from threading import Lock class MyQueue: def __init__(self): self.items = deque() self.lock = Lock() # Example 3 def put(self, item): with self.lock: self.items.append(item) # Example 4 def get(self): with self.lock: return self.items.popleft() # Example 5 from threading import Thread import time class Worker(Thread): def __init__(self, func, in_queue, out_queue): super().__init__() self.func = func self.in_queue = in_queue self.out_queue = out_queue self.polled_count = 0 self.work_done = 0 # Example 6 def run(self): while True: self.polled_count += 1 try: item = self.in_queue.get() except IndexError: time.sleep(0.01) # No work to do except AttributeError: # The magic exit signal return else: result = self.func(item) self.out_queue.put(result) self.work_done += 1 # Example 7 download_queue = MyQueue() resize_queue = MyQueue() upload_queue = MyQueue() done_queue = MyQueue() threads = [ Worker(download, download_queue, resize_queue), Worker(resize, resize_queue, upload_queue), Worker(upload, upload_queue, done_queue), ] # Example 8 for thread in threads: thread.start() for _ in range(1000): download_queue.put(object()) # Example 9 while len(done_queue.items) &lt; 1000: # Do something useful while waiting time.sleep(0.1) # Stop all the threads by causing an exception in their # run methods. for thread in threads: thread.in_queue = None thread.join() # Example 10 processed = len(done_queue.items) polled = sum(t.polled_count for t in threads) print(f&#39;Processed {processed} items after &#39; f&#39;polling {polled} times&#39;) # Example 11 from queue import Queue my_queue = Queue() def consumer(): print(&#39;Consumer waiting&#39;) my_queue.get() # Runs after put() below print(&#39;Consumer done&#39;) thread = Thread(target=consumer) thread.start() # Example 12 print(&#39;Producer putting&#39;) my_queue.put(object()) # Runs before get() above print(&#39;Producer done&#39;) thread.join() # Example 13 my_queue = Queue(1) # Buffer size of 1 def consumer(): time.sleep(0.1) # Wait my_queue.get() # Runs second print(&#39;Consumer got 1&#39;) my_queue.get() # Runs fourth print(&#39;Consumer got 2&#39;) print(&#39;Consumer done&#39;) thread = Thread(target=consumer) thread.start() # Example 14 my_queue.put(object()) # Runs first print(&#39;Producer put 1&#39;) my_queue.put(object()) # Runs third print(&#39;Producer put 2&#39;) print(&#39;Producer done&#39;) thread.join() # Example 15 in_queue = Queue() def consumer(): print(&#39;Consumer waiting&#39;) work = in_queue.get() # Done second print(&#39;Consumer working&#39;) # Doing work print(&#39;Consumer done&#39;) in_queue.task_done() # Done third thread = Thread(target=consumer) thread.start() # Example 16 print(&#39;Producer putting&#39;) in_queue.put(object()) # Done first print(&#39;Producer waiting&#39;) in_queue.join() # Done fourth print(&#39;Producer done&#39;) thread.join() # Example 17 class ClosableQueue(Queue): SENTINEL = object() def close(self): self.put(self.SENTINEL) # Example 18 def __iter__(self): while True: item = self.get() try: if item is self.SENTINEL: return # Cause the thread to exit yield item finally: self.task_done() # Example 19 class StoppableWorker(Thread): def __init__(self, func, in_queue, out_queue): super().__init__() self.func = func self.in_queue = in_queue self.out_queue = out_queue def run(self): for item in self.in_queue: result = self.func(item) self.out_queue.put(result) # Example 20 download_queue = ClosableQueue() resize_queue = ClosableQueue() upload_queue = ClosableQueue() done_queue = ClosableQueue() threads = [ StoppableWorker(download, download_queue, resize_queue), StoppableWorker(resize, resize_queue, upload_queue), StoppableWorker(upload, upload_queue, done_queue), ] # Example 21 for thread in threads: thread.start() for _ in range(1000): download_queue.put(object()) download_queue.close() # Example 22 download_queue.join() resize_queue.close() resize_queue.join() upload_queue.close() upload_queue.join() print(done_queue.qsize(), &#39;items finished&#39;) for thread in threads: thread.join() # Example 23 def start_threads(count, *args): threads = [StoppableWorker(*args) for _ in range(count)] for thread in threads: thread.start() return threads def stop_threads(closable_queue, threads): for _ in threads: closable_queue.close() closable_queue.join() for thread in threads: thread.join() # Example 24 download_queue = ClosableQueue() resize_queue = ClosableQueue() upload_queue = ClosableQueue() done_queue = ClosableQueue() download_threads = start_threads( 3, download, download_queue, resize_queue) resize_threads = start_threads( 4, resize, resize_queue, upload_queue) upload_threads = start_threads( 5, upload, upload_queue, done_queue) for _ in range(1000): download_queue.put(object()) stop_threads(download_queue, download_threads) stop_threads(resize_queue, resize_threads) stop_threads(upload_queue, upload_threads) print(done_queue.qsize(), &#39;items finished&#39;) 56. 学会判断什么场合必须做并发 # Example 1 ALIVE = &#39;*&#39; EMPTY = &#39;-&#39; # Example 2 class Grid: def __init__(self, height, width): self.height = height self.width = width self.rows = [] for _ in range(self.height): self.rows.append([EMPTY] * self.width) def get(self, y, x): return self.rows[y % self.height][x % self.width] def set(self, y, x, state): self.rows[y % self.height][x % self.width] = state def __str__(self): output = &#39;&#39; for row in self.rows: for cell in row: output += cell output += &#39;\n&#39; return output # Example 3 grid = Grid(5, 9) grid.set(0, 3, ALIVE) grid.set(1, 4, ALIVE) grid.set(2, 2, ALIVE) grid.set(2, 3, ALIVE) grid.set(2, 4, ALIVE) print(grid) &quot;&quot;&quot; ---*----- ----*---- --***---- --------- --------- &quot;&quot;&quot; # Example 4 def count_neighbors(y, x, get): n_ = get(y - 1, x + 0) # North ne = get(y - 1, x + 1) # Northeast e_ = get(y + 0, x + 1) # East se = get(y + 1, x + 1) # Southeast s_ = get(y + 1, x + 0) # South sw = get(y + 1, x - 1) # Southwest w_ = get(y + 0, x - 1) # West nw = get(y - 1, x - 1) # Northwest neighbor_states = [n_, ne, e_, se, s_, sw, w_, nw] count = 0 for state in neighbor_states: if state == ALIVE: count += 1 return count alive = {(9, 5), (9, 6)} seen = set() def fake_get(y, x): position = (y, x) seen.add(position) return ALIVE if position in alive else EMPTY count = count_neighbors(10, 5, fake_get) assert count == 2 expected_seen = { (9, 5), (9, 6), (10, 6), (11, 6), (11, 5), (11, 4), (10, 4), (9, 4) } assert seen == expected_seen # Example 5 def game_logic(state, neighbors): if state == ALIVE: if neighbors &lt; 2: return EMPTY # Die: Too few elif neighbors &gt; 3: return EMPTY # Die: Too many else: if neighbors == 3: return ALIVE # Regenerate return state assert game_logic(ALIVE, 0) == EMPTY assert game_logic(ALIVE, 1) == EMPTY assert game_logic(ALIVE, 2) == ALIVE assert game_logic(ALIVE, 3) == ALIVE assert game_logic(ALIVE, 4) == EMPTY assert game_logic(EMPTY, 0) == EMPTY assert game_logic(EMPTY, 1) == EMPTY assert game_logic(EMPTY, 2) == EMPTY assert game_logic(EMPTY, 3) == ALIVE assert game_logic(EMPTY, 4) == EMPTY # Example 6 def step_cell(y, x, get, set): state = get(y, x) neighbors = count_neighbors(y, x, get) next_state = game_logic(state, neighbors) set(y, x, next_state) alive = {(10, 5), (9, 5), (9, 6)} new_state = None def fake_get(y, x): return ALIVE if (y, x) in alive else EMPTY def fake_set(y, x, state): global new_state new_state = state # Stay alive step_cell(10, 5, fake_get, fake_set) assert new_state == ALIVE # Stay dead alive.remove((10, 5)) step_cell(10, 5, fake_get, fake_set) assert new_state == EMPTY # Regenerate alive.add((10, 6)) step_cell(10, 5, fake_get, fake_set) assert new_state == ALIVE # Example 7 def simulate(grid): next_grid = Grid(grid.height, grid.width) for y in range(grid.height): for x in range(grid.width): step_cell(y, x, grid.get, next_grid.set) return next_grid # Example 8 class ColumnPrinter: def __init__(self): self.columns = [] def append(self, data): self.columns.append(data) def __str__(self): row_count = 1 for data in self.columns: row_count = max( row_count, len(data.splitlines()) + 1) rows = [&#39;&#39;] * row_count for j in range(row_count): for i, data in enumerate(self.columns): line = data.splitlines()[max(0, j - 1)] if j == 0: padding = &#39; &#39; * (len(line) // 2) rows[j] += padding + str(i) + padding else: rows[j] += line if (i + 1) &lt; len(self.columns): rows[j] += &#39; | &#39; return &#39;\n&#39;.join(rows) columns = ColumnPrinter() for i in range(5): columns.append(str(grid)) grid = simulate(grid) print(columns) &quot;&quot;&quot; 0 | 1 | 2 | 3 | 4 ---*----- | --------- | --------- | --------- | --------- ----*---- | --*-*---- | ----*---- | ---*----- | ----*---- --***---- | ---**---- | --*-*---- | ----**--- | -----*--- --------- | ---*----- | ---**---- | ---**---- | ---***--- --------- | --------- | --------- | --------- | --------- &quot;&quot;&quot; 57. 不要在每次fan-out时都新建一批Thread实例 # Example 1 from threading import Lock ALIVE = &#39;*&#39; EMPTY = &#39;-&#39; class Grid: def __init__(self, height, width): self.height = height self.width = width self.rows = [] for _ in range(self.height): self.rows.append([EMPTY] * self.width) def get(self, y, x): return self.rows[y % self.height][x % self.width] def set(self, y, x, state): self.rows[y % self.height][x % self.width] = state def __str__(self): output = &#39;&#39; for row in self.rows: for cell in row: output += cell output += &#39;\n&#39; return output class LockingGrid(Grid): def __init__(self, height, width): super().__init__(height, width) self.lock = Lock() def __str__(self): with self.lock: return super().__str__() def get(self, y, x): with self.lock: return super().get(y, x) def set(self, y, x, state): with self.lock: return super().set(y, x, state) # Example 2 from threading import Thread def count_neighbors(y, x, get): n_ = get(y - 1, x + 0) # North ne = get(y - 1, x + 1) # Northeast e_ = get(y + 0, x + 1) # East se = get(y + 1, x + 1) # Southeast s_ = get(y + 1, x + 0) # South sw = get(y + 1, x - 1) # Southwest w_ = get(y + 0, x - 1) # West nw = get(y - 1, x - 1) # Northwest neighbor_states = [n_, ne, e_, se, s_, sw, w_, nw] count = 0 for state in neighbor_states: if state == ALIVE: count += 1 return count # def game_logic(state, neighbors): # # Do some blocking input/output in here: # data = my_socket.recv(100) def game_logic(state, neighbors): if state == ALIVE: if neighbors &lt; 2: return EMPTY # Die: Too few elif neighbors &gt; 3: return EMPTY # Die: Too many else: if neighbors == 3: return ALIVE # Regenerate return state def step_cell(y, x, get, set): state = get(y, x) neighbors = count_neighbors(y, x, get) next_state = game_logic(state, neighbors) set(y, x, next_state) def simulate_threaded(grid): next_grid = LockingGrid(grid.height, grid.width) threads = [] for y in range(grid.height): for x in range(grid.width): args = (y, x, grid.get, next_grid.set) thread = Thread(target=step_cell, args=args) thread.start() # Fan out threads.append(thread) for thread in threads: thread.join() # Fan in return next_grid # Example 3 class ColumnPrinter: def __init__(self): self.columns = [] def append(self, data): self.columns.append(data) def __str__(self): row_count = 1 for data in self.columns: row_count = max( row_count, len(data.splitlines()) + 1) rows = [&#39;&#39;] * row_count for j in range(row_count): for i, data in enumerate(self.columns): line = data.splitlines()[max(0, j - 1)] if j == 0: padding = &#39; &#39; * (len(line) // 2) rows[j] += padding + str(i) + padding else: rows[j] += line if (i + 1) &lt; len(self.columns): rows[j] += &#39; | &#39; return &#39;\n&#39;.join(rows) grid = LockingGrid(5, 9) # Changed grid.set(0, 3, ALIVE) grid.set(1, 4, ALIVE) grid.set(2, 2, ALIVE) grid.set(2, 3, ALIVE) grid.set(2, 4, ALIVE) columns = ColumnPrinter() for i in range(5): columns.append(str(grid)) grid = simulate_threaded(grid) # Changed print(columns) # Example 4 # def game_logic(state, neighbors): # raise OSError(&#39;Problem with I/O&#39;) # Example 5 import contextlib import io fake_stderr = io.StringIO() with contextlib.redirect_stderr(fake_stderr): thread = Thread(target=game_logic, args=(ALIVE, 3)) thread.start() thread.join() print(fake_stderr.getvalue()) 58. 学会正确地重构代码，以便用Queue做并发把队列与一定数量的线程搭配起来，可以高效的实现fan-out（分派）与fan-in（归集）。 59. 如果必须用线程做并发，那就考虑通过ThreadPoolExecutor实现# Example 1 ALIVE = &#39;*&#39; EMPTY = &#39;-&#39; class Grid: def __init__(self, height, width): self.height = height self.width = width self.rows = [] for _ in range(self.height): self.rows.append([EMPTY] * self.width) def get(self, y, x): return self.rows[y % self.height][x % self.width] def set(self, y, x, state): self.rows[y % self.height][x % self.width] = state def __str__(self): output = &#39;&#39; for row in self.rows: for cell in row: output += cell output += &#39;\n&#39; return output from threading import Lock class LockingGrid(Grid): def __init__(self, height, width): super().__init__(height, width) self.lock = Lock() def __str__(self): with self.lock: return super().__str__() def get(self, y, x): with self.lock: return super().get(y, x) def set(self, y, x, state): with self.lock: return super().set(y, x, state) def count_neighbors(y, x, get): n_ = get(y - 1, x + 0) # North ne = get(y - 1, x + 1) # Northeast e_ = get(y + 0, x + 1) # East se = get(y + 1, x + 1) # Southeast s_ = get(y + 1, x + 0) # South sw = get(y + 1, x - 1) # Southwest w_ = get(y + 0, x - 1) # West nw = get(y - 1, x - 1) # Northwest neighbor_states = [n_, ne, e_, se, s_, sw, w_, nw] count = 0 for state in neighbor_states: if state == ALIVE: count += 1 return count # def game_logic(state, neighbors): # # Do some blocking input/output in here: # data = my_socket.recv(100) def game_logic(state, neighbors): if state == ALIVE: if neighbors &lt; 2: return EMPTY # Die: Too few elif neighbors &gt; 3: return EMPTY # Die: Too many else: if neighbors == 3: return ALIVE # Regenerate return state def step_cell(y, x, get, set): state = get(y, x) neighbors = count_neighbors(y, x, get) next_state = game_logic(state, neighbors) set(y, x, next_state) # Example 2 from concurrent.futures import ThreadPoolExecutor def simulate_pool(pool, grid): next_grid = LockingGrid(grid.height, grid.width) futures = [] for y in range(grid.height): for x in range(grid.width): args = (y, x, grid.get, next_grid.set) future = pool.submit(step_cell, *args) # Fan out futures.append(future) for future in futures: future.result() # Fan in return next_grid # Example 3 class ColumnPrinter: def __init__(self): self.columns = [] def append(self, data): self.columns.append(data) def __str__(self): row_count = 1 for data in self.columns: row_count = max( row_count, len(data.splitlines()) + 1) rows = [&#39;&#39;] * row_count for j in range(row_count): for i, data in enumerate(self.columns): line = data.splitlines()[max(0, j - 1)] if j == 0: padding = &#39; &#39; * (len(line) // 2) rows[j] += padding + str(i) + padding else: rows[j] += line if (i + 1) &lt; len(self.columns): rows[j] += &#39; | &#39; return &#39;\n&#39;.join(rows) grid = LockingGrid(5, 9) grid.set(0, 3, ALIVE) grid.set(1, 4, ALIVE) grid.set(2, 2, ALIVE) grid.set(2, 3, ALIVE) grid.set(2, 4, ALIVE) columns = ColumnPrinter() with ThreadPoolExecutor(max_workers=10) as pool: for i in range(5): columns.append(str(grid)) grid = simulate_pool(pool, grid) print(columns) 60. 用协程实现高并发的I/Oimport logging # Example 1 ALIVE = &#39;*&#39; EMPTY = &#39;-&#39; class Grid: def __init__(self, height, width): self.height = height self.width = width self.rows = [] for _ in range(self.height): self.rows.append([EMPTY] * self.width) def get(self, y, x): return self.rows[y % self.height][x % self.width] def set(self, y, x, state): self.rows[y % self.height][x % self.width] = state def __str__(self): output = &#39;&#39; for row in self.rows: for cell in row: output += cell output += &#39;\n&#39; return output def count_neighbors(y, x, get): n_ = get(y - 1, x + 0) # North ne = get(y - 1, x + 1) # Northeast e_ = get(y + 0, x + 1) # East se = get(y + 1, x + 1) # Southeast s_ = get(y + 1, x + 0) # South sw = get(y + 1, x - 1) # Southwest w_ = get(y + 0, x - 1) # West nw = get(y - 1, x - 1) # Northwest neighbor_states = [n_, ne, e_, se, s_, sw, w_, nw] count = 0 for state in neighbor_states: if state == ALIVE: count += 1 return count async def game_logic(state, neighbors): if state == ALIVE: if neighbors &lt; 2: return EMPTY # Die: Too few elif neighbors &gt; 3: return EMPTY # Die: Too many else: if neighbors == 3: return ALIVE # Regenerate return state # Example 2 async def step_cell(y, x, get, set): state = get(y, x) neighbors = count_neighbors(y, x, get) next_state = await game_logic(state, neighbors) set(y, x, next_state) # Example 3 import asyncio async def simulate(grid): next_grid = Grid(grid.height, grid.width) tasks = [] for y in range(grid.height): for x in range(grid.width): task = step_cell( y, x, grid.get, next_grid.set) # Fan out tasks.append(task) await asyncio.gather(*tasks) # Fan in return next_grid # Example 4 class ColumnPrinter: def __init__(self): self.columns = [] def append(self, data): self.columns.append(data) def __str__(self): row_count = 1 for data in self.columns: row_count = max( row_count, len(data.splitlines()) + 1) rows = [&#39;&#39;] * row_count for j in range(row_count): for i, data in enumerate(self.columns): line = data.splitlines()[max(0, j - 1)] if j == 0: padding = &#39; &#39; * (len(line) // 2) rows[j] += padding + str(i) + padding else: rows[j] += line if (i + 1) &lt; len(self.columns): rows[j] += &#39; | &#39; return &#39;\n&#39;.join(rows) grid = Grid(5, 9) grid.set(0, 3, ALIVE) grid.set(1, 4, ALIVE) grid.set(2, 2, ALIVE) grid.set(2, 3, ALIVE) grid.set(2, 4, ALIVE) columns = ColumnPrinter() for i in range(5): columns.append(str(grid)) grid = asyncio.run(simulate(grid)) # Run the event loop print(columns) # Example 6 async def count_neighbors(y, x, get): n_ = get(y - 1, x + 0) # North ne = get(y - 1, x + 1) # Northeast e_ = get(y + 0, x + 1) # East se = get(y + 1, x + 1) # Southeast s_ = get(y + 1, x + 0) # South sw = get(y + 1, x - 1) # Southwest w_ = get(y + 0, x - 1) # West nw = get(y - 1, x - 1) # Northwest neighbor_states = [n_, ne, e_, se, s_, sw, w_, nw] count = 0 for state in neighbor_states: if state == ALIVE: count += 1 return count async def step_cell(y, x, get, set): state = get(y, x) neighbors = await count_neighbors(y, x, get) next_state = await game_logic(state, neighbors) set(y, x, next_state) async def game_logic(state, neighbors): if state == ALIVE: if neighbors &lt; 2: return EMPTY # Die: Too few elif neighbors &gt; 3: return EMPTY # Die: Too many else: if neighbors == 3: return ALIVE # Regenerate return state grid = Grid(5, 9) grid.set(0, 3, ALIVE) grid.set(1, 4, ALIVE) grid.set(2, 2, ALIVE) grid.set(2, 3, ALIVE) grid.set(2, 4, ALIVE) columns = ColumnPrinter() for i in range(5): columns.append(str(grid)) grid = asyncio.run(simulate(grid)) print(columns) 61. 学会用asyncio改写那些通过线程实现的I/Oimport logging # Example 1 class EOFError(Exception): pass class ConnectionBase: def __init__(self, connection): self.connection = connection self.file = connection.makefile(&#39;rb&#39;) def send(self, command): line = command + &#39;\n&#39; data = line.encode() self.connection.send(data) def receive(self): line = self.file.readline() if not line: raise EOFError(&#39;Connection closed&#39;) return line[:-1].decode() # Example 2 import random WARMER = &#39;Warmer&#39; COLDER = &#39;Colder&#39; UNSURE = &#39;Unsure&#39; CORRECT = &#39;Correct&#39; class UnknownCommandError(Exception): pass class Session(ConnectionBase): def __init__(self, *args): super().__init__(*args) self._clear_state(None, None) def _clear_state(self, lower, upper): self.lower = lower self.upper = upper self.secret = None self.guesses = [] # Example 3 def loop(self): while command := self.receive(): parts = command.split(&#39; &#39;) if parts[0] == &#39;PARAMS&#39;: self.set_params(parts) elif parts[0] == &#39;NUMBER&#39;: self.send_number() elif parts[0] == &#39;REPORT&#39;: self.receive_report(parts) else: raise UnknownCommandError(command) # Example 4 def set_params(self, parts): assert len(parts) == 3 lower = int(parts[1]) upper = int(parts[2]) self._clear_state(lower, upper) # Example 5 def next_guess(self): if self.secret is not None: return self.secret while True: guess = random.randint(self.lower, self.upper) if guess not in self.guesses: return guess def send_number(self): guess = self.next_guess() self.guesses.append(guess) self.send(format(guess)) # Example 6 def receive_report(self, parts): assert len(parts) == 2 decision = parts[1] last = self.guesses[-1] if decision == CORRECT: self.secret = last print(f&#39;Server: {last} is {decision}&#39;) # Example 7 import contextlib import math class Client(ConnectionBase): def __init__(self, *args): super().__init__(*args) self._clear_state() def _clear_state(self): self.secret = None self.last_distance = None # Example 8 @contextlib.contextmanager def session(self, lower, upper, secret): print(f&#39;Guess a number between {lower} and {upper}!&#39; f&#39; Shhhhh, it\&#39;s {secret}.&#39;) self.secret = secret self.send(f&#39;PARAMS {lower} {upper}&#39;) try: yield finally: self._clear_state() self.send(&#39;PARAMS 0 -1&#39;) # Example 9 def request_numbers(self, count): for _ in range(count): self.send(&#39;NUMBER&#39;) data = self.receive() yield int(data) if self.last_distance == 0: return # Example 10 def report_outcome(self, number): new_distance = math.fabs(number - self.secret) decision = UNSURE if new_distance == 0: decision = CORRECT elif self.last_distance is None: pass elif new_distance &lt; self.last_distance: decision = WARMER elif new_distance &gt; self.last_distance: decision = COLDER self.last_distance = new_distance self.send(f&#39;REPORT {decision}&#39;) return decision # Example 11 import socket from threading import Thread def handle_connection(connection): with connection: session = Session(connection) try: session.loop() except EOFError: pass def run_server(address): with socket.socket() as listener: # Allow the port to be reused listener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) listener.bind(address) listener.listen() while True: connection, _ = listener.accept() thread = Thread(target=handle_connection, args=(connection,), daemon=True) thread.start() # Example 12 def run_client(address): with socket.create_connection(address) as connection: client = Client(connection) with client.session(1, 5, 3): results = [(x, client.report_outcome(x)) for x in client.request_numbers(5)] with client.session(10, 15, 12): for number in client.request_numbers(5): outcome = client.report_outcome(number) results.append((number, outcome)) return results # Example 13 def main(): address = (&#39;127.0.0.1&#39;, 1234) server_thread = Thread( target=run_server, args=(address,), daemon=True) server_thread.start() results = run_client(address) for number, outcome in results: print(f&#39;Client: {number} is {outcome}&#39;) main() # Example 14 class AsyncConnectionBase: def __init__(self, reader, writer): # Changed self.reader = reader # Changed self.writer = writer # Changed async def send(self, command): line = command + &#39;\n&#39; data = line.encode() self.writer.write(data) # Changed await self.writer.drain() # Changed async def receive(self): line = await self.reader.readline() # Changed if not line: raise EOFError(&#39;Connection closed&#39;) return line[:-1].decode() # Example 15 class AsyncSession(AsyncConnectionBase): # Changed def __init__(self, *args): super().__init__(*args) self._clear_values(None, None) def _clear_values(self, lower, upper): self.lower = lower self.upper = upper self.secret = None self.guesses = [] # Example 16 async def loop(self): # Changed while command := await self.receive(): # Changed parts = command.split(&#39; &#39;) if parts[0] == &#39;PARAMS&#39;: self.set_params(parts) elif parts[0] == &#39;NUMBER&#39;: await self.send_number() # Changed elif parts[0] == &#39;REPORT&#39;: self.receive_report(parts) else: raise UnknownCommandError(command) # Example 17 def set_params(self, parts): assert len(parts) == 3 lower = int(parts[1]) upper = int(parts[2]) self._clear_values(lower, upper) # Example 18 def next_guess(self): if self.secret is not None: return self.secret while True: guess = random.randint(self.lower, self.upper) if guess not in self.guesses: return guess async def send_number(self): # Changed guess = self.next_guess() self.guesses.append(guess) await self.send(format(guess)) # Changed # Example 19 def receive_report(self, parts): assert len(parts) == 2 decision = parts[1] last = self.guesses[-1] if decision == CORRECT: self.secret = last print(f&#39;Server: {last} is {decision}&#39;) # Example 20 class AsyncClient(AsyncConnectionBase): # Changed def __init__(self, *args): super().__init__(*args) self._clear_state() def _clear_state(self): self.secret = None self.last_distance = None # Example 21 @contextlib.asynccontextmanager # Changed async def session(self, lower, upper, secret): # Changed print(f&#39;Guess a number between {lower} and {upper}!&#39; f&#39; Shhhhh, it\&#39;s {secret}.&#39;) self.secret = secret await self.send(f&#39;PARAMS {lower} {upper}&#39;) # Changed try: yield finally: self._clear_state() await self.send(&#39;PARAMS 0 -1&#39;) # Changed # Example 22 async def request_numbers(self, count): # Changed for _ in range(count): await self.send(&#39;NUMBER&#39;) # Changed data = await self.receive() # Changed yield int(data) if self.last_distance == 0: return # Example 23 async def report_outcome(self, number): # Changed new_distance = math.fabs(number - self.secret) decision = UNSURE if new_distance == 0: decision = CORRECT elif self.last_distance is None: pass elif new_distance &lt; self.last_distance: decision = WARMER elif new_distance &gt; self.last_distance: decision = COLDER self.last_distance = new_distance await self.send(f&#39;REPORT {decision}&#39;) # Changed # Make it so the output printing is in # the same order as the threaded version. await asyncio.sleep(0.01) return decision # Example 24 import asyncio async def handle_async_connection(reader, writer): session = AsyncSession(reader, writer) try: await session.loop() except EOFError: pass async def run_async_server(address): server = await asyncio.start_server( handle_async_connection, *address) async with server: await server.serve_forever() # Example 25 async def run_async_client(address): # Wait for the server to listen before trying to connect await asyncio.sleep(0.1) streams = await asyncio.open_connection(*address) # New client = AsyncClient(*streams) # New async with client.session(1, 5, 3): results = [(x, await client.report_outcome(x)) async for x in client.request_numbers(5)] async with client.session(10, 15, 12): async for number in client.request_numbers(5): outcome = await client.report_outcome(number) results.append((number, outcome)) _, writer = streams # New writer.close() # New await writer.wait_closed() # New return results # Example 26 async def main_async(): address = (&#39;127.0.0.1&#39;, 4321) server = run_async_server(address) asyncio.create_task(server) results = await run_async_client(address) for number, outcome in results: print(f&#39;Client: {number} is {outcome}&#39;) logging.getLogger().setLevel(logging.ERROR) asyncio.run(main_async()) logging.getLogger().setLevel(logging.DEBUG) 62. 结合线程与协程，将代码顺利迁移到asyncio # Example 1 class NoNewData(Exception): pass def readline(handle): offset = handle.tell() handle.seek(0, 2) length = handle.tell() if length == offset: raise NoNewData handle.seek(offset, 0) return handle.readline() # Example 2 import time def tail_file(handle, interval, write_func): while not handle.closed: try: line = readline(handle) except NoNewData: time.sleep(interval) else: write_func(line) # Example 3 from threading import Lock, Thread def run_threads(handles, interval, output_path): with open(output_path, &#39;wb&#39;) as output: lock = Lock() def write(data): with lock: output.write(data) threads = [] for handle in handles: args = (handle, interval, write) thread = Thread(target=tail_file, args=args) thread.start() threads.append(thread) for thread in threads: thread.join() # Example 4 # This is all code to simulate the writers to the handles import collections import os import random import string from tempfile import TemporaryDirectory def write_random_data(path, write_count, interval): with open(path, &#39;wb&#39;) as f: for i in range(write_count): time.sleep(random.random() * interval) letters = random.choices( string.ascii_lowercase, k=10) data = f&#39;{path}-{i:02}-{&quot;&quot;.join(letters)}\n&#39; f.write(data.encode()) f.flush() def start_write_threads(directory, file_count): paths = [] for i in range(file_count): path = os.path.join(directory, str(i)) with open(path, &#39;w&#39;): # Make sure the file at this path will exist when # the reading thread tries to poll it. pass paths.append(path) args = (path, 10, 0.1) thread = Thread(target=write_random_data, args=args) thread.start() return paths def close_all(handles): time.sleep(1) for handle in handles: handle.close() def setup(): tmpdir = TemporaryDirectory() input_paths = start_write_threads(tmpdir.name, 5) handles = [] for path in input_paths: handle = open(path, &#39;rb&#39;) handles.append(handle) Thread(target=close_all, args=(handles,)).start() output_path = os.path.join(tmpdir.name, &#39;merged&#39;) return tmpdir, input_paths, handles, output_path # Example 5 def confirm_merge(input_paths, output_path): found = collections.defaultdict(list) with open(output_path, &#39;rb&#39;) as f: for line in f: for path in input_paths: if line.find(path.encode()) == 0: found[path].append(line) expected = collections.defaultdict(list) for path in input_paths: with open(path, &#39;rb&#39;) as f: expected[path].extend(f.readlines()) for key, expected_lines in expected.items(): found_lines = found[key] assert expected_lines == found_lines, \ f&#39;{expected_lines!r} == {found_lines!r}&#39; input_paths = ... handles = ... output_path = ... tmpdir, input_paths, handles, output_path = setup() run_threads(handles, 0.1, output_path) confirm_merge(input_paths, output_path) tmpdir.cleanup() # Example 6 import asyncio # On Windows, a ProactorEventLoop can&#39;t be created within # threads because it tries to register signal handlers. This # is a work-around to always use the SelectorEventLoop policy # instead. See: https://bugs.python.org/issue33792 policy = asyncio.get_event_loop_policy() policy._loop_factory = asyncio.SelectorEventLoop async def run_tasks_mixed(handles, interval, output_path): loop = asyncio.get_event_loop() with open(output_path, &#39;wb&#39;) as output: async def write_async(data): output.write(data) def write(data): coro = write_async(data) future = asyncio.run_coroutine_threadsafe( coro, loop) future.result() tasks = [] for handle in handles: task = loop.run_in_executor( None, tail_file, handle, interval, write) tasks.append(task) await asyncio.gather(*tasks) # Example 7 input_paths = ... handles = ... output_path = ... tmpdir, input_paths, handles, output_path = setup() asyncio.run(run_tasks_mixed(handles, 0.1, output_path)) confirm_merge(input_paths, output_path) tmpdir.cleanup() # Example 8 async def tail_async(handle, interval, write_func): loop = asyncio.get_event_loop() while not handle.closed: try: line = await loop.run_in_executor( None, readline, handle) except NoNewData: await asyncio.sleep(interval) else: await write_func(line) # Example 9 async def run_tasks(handles, interval, output_path): with open(output_path, &#39;wb&#39;) as output: async def write_async(data): output.write(data) tasks = [] for handle in handles: coro = tail_async(handle, interval, write_async) task = asyncio.create_task(coro) tasks.append(task) await asyncio.gather(*tasks) # Example 10 input_paths = ... handles = ... output_path = ... tmpdir, input_paths, handles, output_path = setup() asyncio.run(run_tasks(handles, 0.1, output_path)) confirm_merge(input_paths, output_path) tmpdir.cleanup() # Example 11 def tail_file(handle, interval, write_func): loop = asyncio.new_event_loop() asyncio.set_event_loop(loop) async def write_async(data): write_func(data) coro = tail_async(handle, interval, write_async) loop.run_until_complete(coro) # Example 12 input_paths = ... handles = ... output_path = ... tmpdir, input_paths, handles, output_path = setup() run_threads(handles, 0.1, output_path) confirm_merge(input_paths, output_path) tmpdir.cleanup() 63. 让asyncio的事件循环保持畅通，以便进一步提升程序的响应能力调用asyncio.run时，可以把debug参数设置成为true，这样可以知道哪些协程降低了事件循环的速度。 # Example 1 import asyncio # On Windows, a ProactorEventLoop can&#39;t be created within # threads because it tries to register signal handlers. This # is a work-around to always use the SelectorEventLoop policy # instead. See: https://bugs.python.org/issue33792 policy = asyncio.get_event_loop_policy() policy._loop_factory = asyncio.SelectorEventLoop async def run_tasks(handles, interval, output_path): with open(output_path, &#39;wb&#39;) as output: async def write_async(data): output.write(data) tasks = [] for handle in handles: coro = tail_async(handle, interval, write_async) task = asyncio.create_task(coro) tasks.append(task) await asyncio.gather(*tasks) # Example 2 import time async def slow_coroutine(): time.sleep(0.5) # Simulating slow I/O asyncio.run(slow_coroutine(), debug=True) # Example 3 from threading import Thread class WriteThread(Thread): def __init__(self, output_path): super().__init__() self.output_path = output_path self.output = None self.loop = asyncio.new_event_loop() def run(self): asyncio.set_event_loop(self.loop) with open(self.output_path, &#39;wb&#39;) as self.output: self.loop.run_forever() # Run one final round of callbacks so the await on # stop() in another event loop will be resolved. self.loop.run_until_complete(asyncio.sleep(0)) # Example 4 async def real_write(self, data): self.output.write(data) async def write(self, data): coro = self.real_write(data) future = asyncio.run_coroutine_threadsafe( coro, self.loop) await asyncio.wrap_future(future) # Example 5 async def real_stop(self): self.loop.stop() async def stop(self): coro = self.real_stop() future = asyncio.run_coroutine_threadsafe( coro, self.loop) await asyncio.wrap_future(future) # Example 6 async def __aenter__(self): loop = asyncio.get_event_loop() await loop.run_in_executor(None, self.start) return self async def __aexit__(self, *_): await self.stop() # Example 7 class NoNewData(Exception): pass def readline(handle): offset = handle.tell() handle.seek(0, 2) length = handle.tell() if length == offset: raise NoNewData handle.seek(offset, 0) return handle.readline() async def tail_async(handle, interval, write_func): loop = asyncio.get_event_loop() while not handle.closed: try: line = await loop.run_in_executor( None, readline, handle) except NoNewData: await asyncio.sleep(interval) else: await write_func(line) async def run_fully_async(handles, interval, output_path): async with WriteThread(output_path) as output: tasks = [] for handle in handles: coro = tail_async(handle, interval, output.write) task = asyncio.create_task(coro) tasks.append(task) await asyncio.gather(*tasks) # Example 8 # This is all code to simulate the writers to the handles import collections import os import random import string from tempfile import TemporaryDirectory def write_random_data(path, write_count, interval): with open(path, &#39;wb&#39;) as f: for i in range(write_count): time.sleep(random.random() * interval) letters = random.choices( string.ascii_lowercase, k=10) data = f&#39;{path}-{i:02}-{&quot;&quot;.join(letters)}\n&#39; f.write(data.encode()) f.flush() def start_write_threads(directory, file_count): paths = [] for i in range(file_count): path = os.path.join(directory, str(i)) with open(path, &#39;w&#39;): # Make sure the file at this path will exist when # the reading thread tries to poll it. pass paths.append(path) args = (path, 10, 0.1) thread = Thread(target=write_random_data, args=args) thread.start() return paths def close_all(handles): time.sleep(1) for handle in handles: handle.close() def setup(): tmpdir = TemporaryDirectory() input_paths = start_write_threads(tmpdir.name, 5) handles = [] for path in input_paths: handle = open(path, &#39;rb&#39;) handles.append(handle) Thread(target=close_all, args=(handles,)).start() output_path = os.path.join(tmpdir.name, &#39;merged&#39;) return tmpdir, input_paths, handles, output_path # Example 9 def confirm_merge(input_paths, output_path): found = collections.defaultdict(list) with open(output_path, &#39;rb&#39;) as f: for line in f: for path in input_paths: if line.find(path.encode()) == 0: found[path].append(line) expected = collections.defaultdict(list) for path in input_paths: with open(path, &#39;rb&#39;) as f: expected[path].extend(f.readlines()) for key, expected_lines in expected.items(): found_lines = found[key] assert expected_lines == found_lines input_paths = ... handles = ... output_path = ... tmpdir, input_paths, handles, output_path = setup() asyncio.run(run_fully_async(handles, 0.1, output_path)) confirm_merge(input_paths, output_path) tmpdir.cleanup() 64. 考虑用concurrent.futures实现真正的并行计算 Run_thread.py from concurrent.futures import ThreadPoolExecutor import time NUMBERS = [ (1963309, 2265973), (2030677, 3814172), (1551645, 2229620), (2039045, 2020802), (1823712, 1924928), (2293129, 1020491), (1281238, 2273782), (3823812, 4237281), (3812741, 4729139), (1292391, 2123811), ] def gcd(pair): a, b = pair low = min(a, b) for i in range(low, 0, -1): if a % i == 0 and b % i == 0: return i assert False, &#39;Not reachable&#39; def main(): start = time.time() pool = ThreadPoolExecutor(max_workers=2) results = list(pool.map(gcd, NUMBERS)) end = time.time() delta = end - start print(f&#39;Took {delta:.3f} seconds&#39;) # Took 1.278 seconds if __name__ == &#39;__main__&#39;: main() Run_serial.py import time NUMBERS = [ (1963309, 2265973), (2030677, 3814172), (1551645, 2229620), (2039045, 2020802), (1823712, 1924928), (2293129, 1020491), (1281238, 2273782), (3823812, 4237281), (3812741, 4729139), (1292391, 2123811), ] def gcd(pair): a, b = pair low = min(a, b) for i in range(low, 0, -1): if a % i == 0 and b % i == 0: return i assert False, &#39;Not reachable&#39; def main(): start = time.time() results = list(map(gcd, NUMBERS)) end = time.time() delta = end - start print(f&#39;Took {delta:.3f} seconds&#39;) # Took 1.204 seconds if __name__ == &#39;__main__&#39;: main() run_parallel.py from concurrent.futures import ProcessPoolExecutor import time NUMBERS = [ (1963309, 2265973), (2030677, 3814172), (1551645, 2229620), (2039045, 2020802), (1823712, 1924928), (2293129, 1020491), (1281238, 2273782), (3823812, 4237281), (3812741, 4729139), (1292391, 2123811), ] def gcd(pair): a, b = pair low = min(a, b) for i in range(low, 0, -1): if a % i == 0 and b % i == 0: return i assert False, &#39;Not reachable&#39; def main(): start = time.time() pool = ProcessPoolExecutor(max_workers=2) # The one change results = list(pool.map(gcd, NUMBERS)) end = time.time() delta = end - start print(f&#39;Took {delta:.3f} seconds&#39;) # Took 0.635 seconds if __name__ == &#39;__main__&#39;: main() 八. 稳定与性能65. 合理利用try/except/else/finally结构中的每个代码块import json UNDEFINED = object() DIE_IN_ELSE_BLOCK = False def divide_json(path): print(&#39;* Opening file&#39;) handle = open(path, &#39;r+&#39;) # May raise OSError try: print(&#39;* Reading data&#39;) data = handle.read() # May raise UnicodeDecodeError print(&#39;* Loading JSON data&#39;) op = json.loads(data) # May raise ValueError print(&#39;* Performing calculation&#39;) value = ( op[&#39;numerator&#39;] / op[&#39;denominator&#39;]) # May raise ZeroDivisionError except ZeroDivisionError as e: print(f&#39;* Handling ZeroDivisionError: {e}&#39;) return UNDEFINED else: print(&#39;* Writing calculation&#39;) op[&#39;result&#39;] = value result = json.dumps(op) handle.seek(0) # May raise OSError if DIE_IN_ELSE_BLOCK: import errno import os raise OSError(errno.ENOSPC, os.strerror(errno.ENOSPC)) handle.write(result) # May raise OSError return value finally: print(&#39;* Calling close()&#39;) handle.close() # Always runs temp_path = &#39;random_data.json&#39; with open(temp_path, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f: f.write(&#39;{&quot;numerator&quot;: 1, &quot;denominator&quot;: 10}&#39;) assert divide_json(temp_path) == 0.1 66. 考虑用contextlib和with语句来改写可复用的try/finally代码 # Example 1 from threading import Lock lock = Lock() with lock: # Do something while maintaining an invariant pass # Example 2 lock.acquire() try: # Do something while maintaining an invariant pass finally: lock.release() # Example 3 import logging logging.getLogger().setLevel(logging.WARNING) def my_function(): logging.debug(&#39;Some debug data&#39;) logging.error(&#39;Error log here&#39;) logging.debug(&#39;More debug data&#39;) # Example 4 my_function() # Example 5 from contextlib import contextmanager @contextmanager def debug_logging(level): logger = logging.getLogger() old_level = logger.getEffectiveLevel() logger.setLevel(level) try: yield finally: logger.setLevel(old_level) # Example 6 with debug_logging(logging.DEBUG): print(&#39;* Inside:&#39;) my_function() print(&#39;* After:&#39;) my_function() # Example 7 with open(&#39;my_output.txt&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;) as handle: handle.write(&#39;This is some data!&#39;) # Example 8 @contextmanager def log_level(level, name): logger = logging.getLogger(name) old_level = logger.getEffectiveLevel() logger.setLevel(level) try: yield logger finally: logger.setLevel(old_level) # Example 9 with log_level(logging.DEBUG, &#39;my-log&#39;) as logger: logger.debug(f&#39;This is a message for {logger.name}!&#39;) logging.debug(&#39;This will not print&#39;) # Example 10 logger = logging.getLogger(&#39;my-log&#39;) logger.debug(&#39;Debug will not print&#39;) logger.error(&#39;Error will print&#39;) # Example 11 with log_level(logging.DEBUG, &#39;other-log&#39;) as logger: logger.debug(f&#39;This is a message for {logger.name}!&#39;) logging.debug(&#39;This will not print&#39;) 67. 用datetime模块处理本地时间，不要用time模块import time from datetime import datetime, timezone now = datetime(2019, 3, 16, 22, 14, 35) now_utc = now.replace(tzinfo=timezone.utc) now_local = now_utc.astimezone() print(now_local) # 2019-03-17 06:14:35+08:00 # Example 6 time_str = &#39;2019-03-16 15:14:35&#39; time_format = &#39;%Y-%m-%d %H:%M:%S&#39; now = datetime.strptime(time_str, time_format) time_tuple = now.timetuple() utc_now = time.mktime(time_tuple) print(utc_now) # 1552720475.0 # Example 7 import pytz arrival_nyc = &#39;2019-03-16 23:33:24&#39; nyc_dt_naive = datetime.strptime(arrival_nyc, time_format) eastern = pytz.timezone(&#39;US/Eastern&#39;) nyc_dt = eastern.localize(nyc_dt_naive) utc_dt = pytz.utc.normalize(nyc_dt.astimezone(pytz.utc)) print(utc_dt) # 2019-03-17 03:33:24+00:00 # Example 8 pacific = pytz.timezone(&#39;US/Pacific&#39;) sf_dt = pacific.normalize(utc_dt.astimezone(pacific)) print(sf_dt) # 2019-03-16 20:33:24-07:00 # Example 9 nepal = pytz.timezone(&#39;Asia/Katmandu&#39;) nepal_dt = nepal.normalize(utc_dt.astimezone(nepal)) print(nepal_dt) # 2019-03-17 09:18:24+05:45 68. 用copyreg实现可靠的pickle操作import logging # Example 1 class GameState: def __init__(self): self.level = 0 self.lives = 4 # Example 2 state = GameState() state.level += 1 # Player beat a level state.lives -= 1 # Player had to try again print(state.__dict__) # Example 3 import pickle state_path = &#39;game_state.bin&#39; with open(state_path, &#39;wb&#39;) as f: pickle.dump(state, f) # Example 4 with open(state_path, &#39;rb&#39;) as f: state_after = pickle.load(f) print(state_after.__dict__) # Example 5 class GameState: def __init__(self): self.level = 0 self.lives = 4 self.points = 0 # New field # Example 6 state = GameState() serialized = pickle.dumps(state) state_after = pickle.loads(serialized) print(state_after.__dict__) # Example 7 with open(state_path, &#39;rb&#39;) as f: state_after = pickle.load(f) print(state_after.__dict__) # Example 8 assert isinstance(state_after, GameState) # Example 9 class GameState: def __init__(self, level=0, lives=4, points=0): self.level = level self.lives = lives self.points = points # Example 10 def pickle_game_state(game_state): kwargs = game_state.__dict__ return unpickle_game_state, (kwargs,) # Example 11 def unpickle_game_state(kwargs): return GameState(**kwargs) # Example 12 import copyreg copyreg.pickle(GameState, pickle_game_state) # Example 13 state = GameState() state.points += 1000 serialized = pickle.dumps(state) state_after = pickle.loads(serialized) print(state_after.__dict__) # Example 14 class GameState: def __init__(self, level=0, lives=4, points=0, magic=5): self.level = level self.lives = lives self.points = points self.magic = magic # New field # Example 15 print(&#39;Before:&#39;, state.__dict__) state_after = pickle.loads(serialized) print(&#39;After: &#39;, state_after.__dict__) # Example 16 class GameState: def __init__(self, level=0, points=0, magic=5): self.level = level self.points = points self.magic = magic # Example 17 # try: # pickle.loads(serialized) # except: # logging.exception(&#39;Expected&#39;) # else: # assert False # Example 18 def pickle_game_state(game_state): kwargs = game_state.__dict__ kwargs[&#39;version&#39;] = 2 return unpickle_game_state, (kwargs,) # Example 19 def unpickle_game_state(kwargs): version = kwargs.pop(&#39;version&#39;, 1) if version == 1: del kwargs[&#39;lives&#39;] return GameState(**kwargs) # Example 20 copyreg.pickle(GameState, pickle_game_state) print(&#39;Before:&#39;, state.__dict__) state_after = pickle.loads(serialized) print(&#39;After: &#39;, state_after.__dict__) # Example 21 copyreg.dispatch_table.clear() state = GameState() serialized = pickle.dumps(state) del GameState class BetterGameState: def __init__(self, level=0, points=0, magic=5): self.level = level self.points = points self.magic = magic # Example 22 # try: # pickle.loads(serialized) # except: # logging.exception(&#39;Expected&#39;) # else: # assert False # Example 23 print(serialized) # Example 24 copyreg.pickle(BetterGameState, pickle_game_state) # Example 25 state = BetterGameState() serialized = pickle.dumps(state) print(serialized) 69. 在需要准确计算的场合，用decimal表示相应的数值 # Example 1 rate = 1.45 seconds = 3*60 + 42 cost = rate * seconds / 60 print(cost) # 5.364999999999999 # Example 2 print(round(cost, 2)) # 5.36 # Example 3 from decimal import Decimal rate = Decimal(&#39;1.45&#39;) seconds = Decimal(3*60 + 42) cost = rate * seconds / Decimal(60) print(cost) # 5.365 # Example 4 print(Decimal(&#39;1.45&#39;)) # 1.45 print(Decimal(1.45)) # 1.4499999999999999555910790149937383830547332763671875 # Example 5 print(&#39;456&#39;) # 456 print(456) # 456 # Example 6 rate = Decimal(&#39;0.05&#39;) seconds = Decimal(&#39;5&#39;) small_cost = rate * seconds / Decimal(60) print(small_cost) # 0.004166666666666666666666666667 # Example 7 print(round(small_cost, 2)) # 0.00 # Example 8 from decimal import ROUND_UP rounded = cost.quantize(Decimal(&#39;0.01&#39;), rounding=ROUND_UP) print(f&#39;Rounded {cost} to {rounded}&#39;) # Rounded 5.365 to 5.37 # Example 9 rounded = small_cost.quantize(Decimal(&#39;0.01&#39;), rounding=ROUND_UP) print(f&#39;Rounded {small_cost} to {rounded}&#39;) # Rounded 0.004166666666666666666666666667 to 0.01 70. 先分析性能，然后再优化 优化python程序之前，一定要先分析它的性能，程序变慢的真正原因未必和我们想的一样； 可以通过Stats对象筛选出我们关心的结果。 # Example 1 def insertion_sort(data): result = [] for value in data: insert_value(result, value) return result # Example 2 def insert_value(array, value): for i, existing in enumerate(array): if existing &gt; value: array.insert(i, value) return array.append(value) # Example 3 from random import randint max_size = 10**4 data = [randint(0, max_size) for _ in range(max_size)] test = lambda: insertion_sort(data) # Example 4 from cProfile import Profile profiler = Profile() profiler.runcall(test) # Example 5 from pstats import Stats stats = Stats(profiler) # stats = Stats(profiler, stream=STDOUT) stats.strip_dirs() stats.sort_stats(&#39;cumulative&#39;) stats.print_stats() # Example 6 from bisect import bisect_left def insert_value(array, value): i = bisect_left(array, value) array.insert(i, value) # Example 7 profiler = Profile() profiler.runcall(test) # stats = Stats(profiler, stream=STDOUT) stats.strip_dirs() stats.sort_stats(&#39;cumulative&#39;) stats.print_stats() # Example 8 def my_utility(a, b): c = 1 for i in range(100): c += a * b def first_func(): for _ in range(1000): my_utility(4, 5) def second_func(): for _ in range(10): my_utility(1, 3) def my_program(): for _ in range(20): first_func() second_func() # Example 9 profiler = Profile() profiler.runcall(my_program) # stats = Stats(profiler, stream=STDOUT) stats.strip_dirs() stats.sort_stats(&#39;cumulative&#39;) stats.print_stats() # Example 10 # stats = Stats(profiler, stream=STDOUT) stats.strip_dirs() stats.sort_stats(&#39;cumulative&#39;) stats.print_callers() 71. 优先考虑用deque实现生产者-消费者队列 # Example 1 class Email: def __init__(self, sender, receiver, message): self.sender = sender self.receiver = receiver self.message = message # Example 2 def get_emails(): yield Email(&#39;foo@example.com&#39;, &#39;bar@example.com&#39;, &#39;hello1&#39;) yield Email(&#39;baz@example.com&#39;, &#39;banana@example.com&#39;, &#39;hello2&#39;) yield None yield Email(&#39;meep@example.com&#39;, &#39;butter@example.com&#39;, &#39;hello3&#39;) yield Email(&#39;stuff@example.com&#39;, &#39;avocado@example.com&#39;, &#39;hello4&#39;) yield None yield Email(&#39;thingy@example.com&#39;, &#39;orange@example.com&#39;, &#39;hello5&#39;) yield Email(&#39;roger@example.com&#39;, &#39;bob@example.com&#39;, &#39;hello6&#39;) yield None yield Email(&#39;peanut@example.com&#39;, &#39;alice@example.com&#39;, &#39;hello7&#39;) yield None EMAIL_IT = get_emails() class NoEmailError(Exception): pass def try_receive_email(): # Returns an Email instance or raises NoEmailError try: email = next(EMAIL_IT) except StopIteration: email = None if not email: raise NoEmailError print(f&#39;Produced email: {email.message}&#39;) return email # Example 3 def produce_emails(queue): while True: try: email = try_receive_email() except NoEmailError: return else: queue.append(email) # Producer # Example 4 def consume_one_email(queue): if not queue: return email = queue.pop(0) # Consumer # Index the message for long-term archival print(f&#39;Consumed email: {email.message}&#39;) # Example 5 def loop(queue, keep_running): while keep_running(): produce_emails(queue) consume_one_email(queue) def make_test_end(): count=list(range(10)) def func(): if count: count.pop() return True return False return func def my_end_func(): pass my_end_func = make_test_end() loop([], my_end_func) # Example 6 import timeit def print_results(count, tests): avg_iteration = sum(tests) / len(tests) print(f&#39;Count {count:&gt;5,} takes {avg_iteration:.6f}s&#39;) return count, avg_iteration def list_append_benchmark(count): def run(queue): for i in range(count): queue.append(i) tests = timeit.repeat( setup=&#39;queue = []&#39;, stmt=&#39;run(queue)&#39;, globals=locals(), repeat=1000, number=1) return print_results(count, tests) # Example 7 def print_delta(before, after): before_count, before_time = before after_count, after_time = after growth = 1 + (after_count - before_count) / before_count slowdown = 1 + (after_time - before_time) / before_time print(f&#39;{growth:&gt;4.1f}x data size, {slowdown:&gt;4.1f}x time&#39;) baseline = list_append_benchmark(500) for count in (1_000, 2_000, 3_000, 4_000, 5_000): print() comparison = list_append_benchmark(count) print_delta(baseline, comparison) # Example 8 def list_pop_benchmark(count): def prepare(): return list(range(count)) def run(queue): while queue: queue.pop(0) tests = timeit.repeat( setup=&#39;queue = prepare()&#39;, stmt=&#39;run(queue)&#39;, globals=locals(), repeat=1000, number=1) return print_results(count, tests) # Example 9 baseline = list_pop_benchmark(500) for count in (1_000, 2_000, 3_000, 4_000, 5_000): print() comparison = list_pop_benchmark(count) print_delta(baseline, comparison) # Example 10 import collections def consume_one_email(queue): if not queue: return email = queue.popleft() # Consumer # Process the email message print(f&#39;Consumed email: {email.message}&#39;) def my_end_func(): pass my_end_func = make_test_end() EMAIL_IT = get_emails() loop(collections.deque(), my_end_func) # Example 11 def deque_append_benchmark(count): def prepare(): return collections.deque() def run(queue): for i in range(count): queue.append(i) tests = timeit.repeat( setup=&#39;queue = prepare()&#39;, stmt=&#39;run(queue)&#39;, globals=locals(), repeat=1000, number=1) return print_results(count, tests) baseline = deque_append_benchmark(500) for count in (1_000, 2_000, 3_000, 4_000, 5_000): print() comparison = deque_append_benchmark(count) print_delta(baseline, comparison) # Example 12 def dequeue_popleft_benchmark(count): def prepare(): return collections.deque(range(count)) def run(queue): while queue: queue.popleft() tests = timeit.repeat( setup=&#39;queue = prepare()&#39;, stmt=&#39;run(queue)&#39;, globals=locals(), repeat=1000, number=1) return print_results(count, tests) baseline = dequeue_popleft_benchmark(500) for count in (1_000, 2_000, 3_000, 4_000, 5_000): print() comparison = dequeue_popleft_benchmark(count) print_delta(baseline, comparison) 72. 考虑用bisect搜索已排序的序列 # Example 1 data = list(range(10**5)) index = data.index(91234) assert index == 91234 # Example 2 def find_closest(sequence, goal): for index, value in enumerate(sequence): if goal &lt; value: return index raise ValueError(f&#39;{goal} is out of bounds&#39;) index = find_closest(data, 91234.56) assert index == 91235 try: find_closest(data, 100000000) except ValueError: pass # Expected else: assert False # Example 3 python内置的bisect模块可以更好的搜索有序列表 from bisect import bisect_left index = bisect_left(data, 91234) # Exact match assert index == 91234 index = bisect_left(data, 91234.56) # Closest match assert index == 91235 # Example 4 import random import timeit size = 10**5 iterations = 1000 data = list(range(size)) to_lookup = [random.randint(0, size) for _ in range(iterations)] def run_linear(data, to_lookup): for index in to_lookup: data.index(index) def run_bisect(data, to_lookup): for index in to_lookup: bisect_left(data, index) baseline = timeit.timeit( stmt=&#39;run_linear(data, to_lookup)&#39;, globals=globals(), number=10) print(f&#39;Linear search takes {baseline:.6f}s&#39;) comparison = timeit.timeit( stmt=&#39;run_bisect(data, to_lookup)&#39;, globals=globals(), number=10) print(f&#39;Bisect search takes {comparison:.6f}s&#39;) slowdown = 1 + ((baseline - comparison) / comparison) print(f&#39;{slowdown:.1f}x time&#39;) 73. 学会使用heapq制作优先级队列有时候，我们想根据元素的优先程度来排序，此时应该使用优先级队列。 import logging # Example 1 class Book: def __init__(self, title, due_date): self.title = title self.due_date = due_date # Example 2 def add_book(queue, book): queue.append(book) queue.sort(key=lambda x: x.due_date, reverse=True) queue = [] add_book(queue, Book(&#39;Don Quixote&#39;, &#39;2019-06-07&#39;)) add_book(queue, Book(&#39;Frankenstein&#39;, &#39;2019-06-05&#39;)) add_book(queue, Book(&#39;Les Misérables&#39;, &#39;2019-06-08&#39;)) add_book(queue, Book(&#39;War and Peace&#39;, &#39;2019-06-03&#39;)) # Example 3 class NoOverdueBooks(Exception): pass def next_overdue_book(queue, now): if queue: book = queue[-1] if book.due_date &lt; now: queue.pop() return book raise NoOverdueBooks # Example 4 now = &#39;2019-06-10&#39; found = next_overdue_book(queue, now) print(found.title) found = next_overdue_book(queue, now) print(found.title) # Example 5 def return_book(queue, book): queue.remove(book) queue = [] book = Book(&#39;Treasure Island&#39;, &#39;2019-06-04&#39;) add_book(queue, book) print(&#39;Before return:&#39;, [x.title for x in queue]) return_book(queue, book) print(&#39;After return: &#39;, [x.title for x in queue]) # Example 6 try: next_overdue_book(queue, now) except NoOverdueBooks: pass # Expected else: assert False # Doesn&#39;t happen # Example 7 import random import timeit def print_results(count, tests): avg_iteration = sum(tests) / len(tests) print(f&#39;Count {count:&gt;5,} takes {avg_iteration:.6f}s&#39;) return count, avg_iteration def print_delta(before, after): before_count, before_time = before after_count, after_time = after growth = 1 + (after_count - before_count) / before_count slowdown = 1 + (after_time - before_time) / before_time print(f&#39;{growth:&gt;4.1f}x data size, {slowdown:&gt;4.1f}x time&#39;) def list_overdue_benchmark(count): def prepare(): to_add = list(range(count)) random.shuffle(to_add) return [], to_add def run(queue, to_add): for i in to_add: queue.append(i) queue.sort(reverse=True) while queue: queue.pop() tests = timeit.repeat( setup=&#39;queue, to_add = prepare()&#39;, stmt=f&#39;run(queue, to_add)&#39;, globals=locals(), repeat=100, number=1) return print_results(count, tests) # Example 8 baseline = list_overdue_benchmark(500) for count in (1_000, 1_500, 2_000): print() comparison = list_overdue_benchmark(count) print_delta(baseline, comparison) # Example 9 def list_return_benchmark(count): def prepare(): queue = list(range(count)) random.shuffle(queue) to_return = list(range(count)) random.shuffle(to_return) return queue, to_return def run(queue, to_return): for i in to_return: queue.remove(i) tests = timeit.repeat( setup=&#39;queue, to_return = prepare()&#39;, stmt=f&#39;run(queue, to_return)&#39;, globals=locals(), repeat=100, number=1) return print_results(count, tests) # Example 10 baseline = list_return_benchmark(500) for count in (1_000, 1_500, 2_000): print() comparison = list_return_benchmark(count) print_delta(baseline, comparison) # Example 11 from heapq import heappush def add_book(queue, book): heappush(queue, book) # Example 12 # try: # queue = [] # add_book(queue, Book(&#39;Little Women&#39;, &#39;2019-06-05&#39;)) # add_book(queue, Book(&#39;The Time Machine&#39;, &#39;2019-05-30&#39;)) # except: # logging.exception(&#39;Expected&#39;) # else: # assert False # Example 13 import functools @functools.total_ordering class Book: def __init__(self, title, due_date): self.title = title self.due_date = due_date def __lt__(self, other): return self.due_date &lt; other.due_date # Example 14 queue = [] add_book(queue, Book(&#39;Pride and Prejudice&#39;, &#39;2019-06-01&#39;)) add_book(queue, Book(&#39;The Time Machine&#39;, &#39;2019-05-30&#39;)) add_book(queue, Book(&#39;Crime and Punishment&#39;, &#39;2019-06-06&#39;)) add_book(queue, Book(&#39;Wuthering Heights&#39;, &#39;2019-06-12&#39;)) print([b.title for b in queue]) # Example 15 queue = [ Book(&#39;Pride and Prejudice&#39;, &#39;2019-06-01&#39;), Book(&#39;The Time Machine&#39;, &#39;2019-05-30&#39;), Book(&#39;Crime and Punishment&#39;, &#39;2019-06-06&#39;), Book(&#39;Wuthering Heights&#39;, &#39;2019-06-12&#39;), ] queue.sort() print([b.title for b in queue]) # Example 16 from heapq import heapify queue = [ Book(&#39;Pride and Prejudice&#39;, &#39;2019-06-01&#39;), Book(&#39;The Time Machine&#39;, &#39;2019-05-30&#39;), Book(&#39;Crime and Punishment&#39;, &#39;2019-06-06&#39;), Book(&#39;Wuthering Heights&#39;, &#39;2019-06-12&#39;), ] heapify(queue) print([b.title for b in queue]) # Example 17 from heapq import heappop def next_overdue_book(queue, now): if queue: book = queue[0] # Most overdue first if book.due_date &lt; now: heappop(queue) # Remove the overdue book return book raise NoOverdueBooks # Example 18 now = &#39;2019-06-02&#39; book = next_overdue_book(queue, now) print(book.title) book = next_overdue_book(queue, now) print(book.title) try: next_overdue_book(queue, now) except NoOverdueBooks: pass # Expected else: assert False # Doesn&#39;t happen # Example 19 def heap_overdue_benchmark(count): def prepare(): to_add = list(range(count)) random.shuffle(to_add) return [], to_add def run(queue, to_add): for i in to_add: heappush(queue, i) while queue: heappop(queue) tests = timeit.repeat( setup=&#39;queue, to_add = prepare()&#39;, stmt=f&#39;run(queue, to_add)&#39;, globals=locals(), repeat=100, number=1) return print_results(count, tests) # Example 20 baseline = heap_overdue_benchmark(500) for count in (1_000, 1_500, 2_000): print() comparison = heap_overdue_benchmark(count) print_delta(baseline, comparison) # Example 21 @functools.total_ordering class Book: def __init__(self, title, due_date): self.title = title self.due_date = due_date self.returned = False # New field def __lt__(self, other): return self.due_date &lt; other.due_date # Example 22 def next_overdue_book(queue, now): while queue: book = queue[0] if book.returned: heappop(queue) continue if book.due_date &lt; now: heappop(queue) return book break raise NoOverdueBooks queue = [] book = Book(&#39;Pride and Prejudice&#39;, &#39;2019-06-01&#39;) add_book(queue, book) book = Book(&#39;The Time Machine&#39;, &#39;2019-05-30&#39;) add_book(queue, book) book.returned = True book = Book(&#39;Crime and Punishment&#39;, &#39;2019-06-06&#39;) add_book(queue, book) book.returned = True book = Book(&#39;Wuthering Heights&#39;, &#39;2019-06-12&#39;) add_book(queue, book) now = &#39;2019-06-11&#39; book = next_overdue_book(queue, now) assert book.title == &#39;Pride and Prejudice&#39; try: next_overdue_book(queue, now) except NoOverdueBooks: pass # Expected else: assert False # Doesn&#39;t happen # Example 23 def return_book(queue, book): book.returned = True assert not book.returned return_book(queue, book) assert book.returned 74. 考虑用memoryview与bytearray来实现无须拷贝的bytes操作# Example 1 def timecode_to_index(video_id, timecode): return 1234 # Returns the byte offset in the video data def request_chunk(video_id, byte_offset, size): pass # Returns size bytes of video_id&#39;s data from the offset video_id = ... timecode = &#39;01:09:14:28&#39; byte_offset = timecode_to_index(video_id, timecode) size = 20 * 1024 * 1024 video_data = request_chunk(video_id, byte_offset, size) # Example 2 class NullSocket: def __init__(self): self.handle = open(os.devnull, &#39;wb&#39;) def send(self, data): self.handle.write(data) socket = ... # socket connection to client video_data = ... # bytes containing data for video_id byte_offset = ... # Requested starting position size = 20 * 1024 * 1024 # Requested chunk size import os socket = NullSocket() video_data = 100 * os.urandom(1024 * 1024) byte_offset = 1234 chunk = video_data[byte_offset:byte_offset + size] socket.send(chunk) # Example 3 import timeit def run_test(): chunk = video_data[byte_offset:byte_offset + size] # Call socket.send(chunk), but ignoring for benchmark result = timeit.timeit( stmt=&#39;run_test()&#39;, globals=globals(), number=100) / 100 print(f&#39;{result:0.9f} seconds&#39;) # Example 4 data = b&#39;shave and a haircut, two bits&#39; view = memoryview(data) chunk = view[12:19] print(chunk) print(&#39;Size: &#39;, chunk.nbytes) print(&#39;Data in view: &#39;, chunk.tobytes()) print(&#39;Underlying data:&#39;, chunk.obj) # Example 5 video_view = memoryview(video_data) def run_test(): chunk = video_view[byte_offset:byte_offset + size] # Call socket.send(chunk), but ignoring for benchmark result = timeit.timeit( stmt=&#39;run_test()&#39;, globals=globals(), number=100) / 100 print(f&#39;{result:0.9f} seconds&#39;) # Example 6 class FakeSocket: def recv(self, size): return video_view[byte_offset:byte_offset+size] def recv_into(self, buffer): source_data = video_view[byte_offset:byte_offset+size] buffer[:] = source_data socket = ... # socket connection to the client video_cache = ... # Cache of incoming video stream byte_offset = ... # Incoming buffer position size = 1024 * 1024 # Incoming chunk size socket = FakeSocket() video_cache = video_data[:] byte_offset = 1234 chunk = socket.recv(size) video_view = memoryview(video_cache) before = video_view[:byte_offset] after = video_view[byte_offset + size:] new_cache = b&#39;&#39;.join([before, chunk, after]) # Example 7 def run_test(): chunk = socket.recv(size) before = video_view[:byte_offset] after = video_view[byte_offset + size:] new_cache = b&#39;&#39;.join([before, chunk, after]) result = timeit.timeit( stmt=&#39;run_test()&#39;, globals=globals(), number=100) / 100 print(f&#39;{result:0.9f} seconds&#39;) # Example 8 # try: # my_bytes = b&#39;hello&#39; # my_bytes[0] = b&#39;\x79&#39; # except: # logging.exception(&#39;Expected&#39;) # else: # assert False # Example 9 my_array = bytearray(b&#39;hello&#39;) my_array[0] = 0x79 print(my_array) # Example 10 my_array = bytearray(b&#39;row, row, row your boat&#39;) my_view = memoryview(my_array) write_view = my_view[3:13] write_view[:] = b&#39;-10 bytes-&#39; print(my_array) # Example 11 video_array = bytearray(video_cache) write_view = memoryview(video_array) chunk = write_view[byte_offset:byte_offset + size] socket.recv_into(chunk) # Example 12 def run_test(): chunk = write_view[byte_offset:byte_offset + size] socket.recv_into(chunk) result = timeit.timeit( stmt=&#39;run_test()&#39;, globals=globals(), number=100) / 100 print(f&#39;{result:0.9f} seconds&#39;) 九. 测试与调试75. 通过repr字符串输出调试信息# Example 1 print(&#39;foo bar&#39;) # Example 2 my_value = &#39;foo bar&#39; print(str(my_value)) print(&#39;%s&#39; % my_value) print(f&#39;{my_value}&#39;) print(format(my_value)) print(my_value.__format__(&#39;s&#39;)) print(my_value.__str__()) # Example 3 print(5) print(&#39;5&#39;) int_value = 5 str_value = &#39;5&#39; print(f&#39;{int_value} == {str_value} ?&#39;) # Example 4 a = &#39;\x07&#39; print(repr(a)) # Example 5 b = eval(repr(a)) assert a == b # Example 6 print(repr(5)) print(repr(&#39;5&#39;)) # Example 7 print(&#39;%r&#39; % 5) print(&#39;%r&#39; % &#39;5&#39;) int_value = 5 str_value = &#39;5&#39; print(f&#39;{int_value!r} != {str_value!r}&#39;) # Example 8 class OpaqueClass: def __init__(self, x, y): self.x = x self.y = y obj = OpaqueClass(1, &#39;foo&#39;) print(obj) # Example 9 class BetterClass: def __init__(self, x, y): self.x = x self.y = y def __repr__(self): return f&#39;BetterClass({self.x!r}, {self.y!r})&#39; # Example 10 obj = BetterClass(2, &#39;bar&#39;) print(obj) # Example 11 obj = OpaqueClass(4, &#39;baz&#39;) print(obj.__dict__) 76. 在TestCase子类里验证相关的行为 Helper_test.py from unittest import TestCase, main def sum_squares(values): cumulative = 0 for value in values: cumulative += value ** 2 yield cumulative class HelperTestCase(TestCase): def verify_complex_case(self, values, expected): expect_it = iter(expected) found_it = iter(sum_squares(values)) test_it = zip(expect_it, found_it) for i, (expect, found) in enumerate(test_it): self.assertEqual( expect, found, f&#39;Index {i} is wrong&#39;) # Verify both generators are exhausted try: next(expect_it) except StopIteration: pass else: self.fail(&#39;Expected longer than found&#39;) try: next(found_it) except StopIteration: pass else: self.fail(&#39;Found longer than expected&#39;) def test_wrong_lengths(self): values = [1.1, 2.2, 3.3] expected = [ 1.1**2, ] self.verify_complex_case(values, expected) def test_wrong_results(self): values = [1.1, 2.2, 3.3] expected = [ 1.1**2, 1.1**2 + 2.2**2, 1.1**2 + 2.2**2 + 3.3**2 + 4.4**2, ] self.verify_complex_case(values, expected) if __name__ == &#39;__main__&#39;: main() Data_driven_test.py from unittest import TestCase, main from utils import to_str class DataDrivenTestCase(TestCase): def test_good(self): good_cases = [ (b&#39;my bytes&#39;, &#39;my bytes&#39;), (&#39;no error&#39;, b&#39;no error&#39;), # This one will fail (&#39;other str&#39;, &#39;other str&#39;), ] for value, expected in good_cases: with self.subTest(value): self.assertEqual(expected, to_str(value)) def test_bad(self): bad_cases = [ (object(), TypeError), (b&#39;\xfa\xfa&#39;, UnicodeDecodeError), ] for value, exception in bad_cases: with self.subTest(value): with self.assertRaises(exception): to_str(value) if __name__ == &#39;__main__&#39;: main() 77. 把测试前、后的准备与清理逻辑写在setUp、tearDown、setUpModule与tearDownModule中，以防用例之间互相干扰from unittest import TestCase, main def setUpModule(): print(&#39;* Module setup&#39;) def tearDownModule(): print(&#39;* Module clean-up&#39;) class IntegrationTest(TestCase): def setUp(self): print(&#39;* Test setup&#39;) def tearDown(self): print(&#39;* Test clean-up&#39;) def test_end_to_end1(self): print(&#39;* Test 1&#39;) def test_end_to_end2(self): print(&#39;* Test 2&#39;) if __name__ == &#39;__main__&#39;: main() 78. 用Mock来模拟受测代码所依赖的复杂函数import logging # Example 1 class DatabaseConnection: def __init__(self, host, port): pass class DatabaseConnectionError(Exception): pass def get_animals(database, species): # Query the Database raise DatabaseConnectionError(&#39;Not connected&#39;) # Return a list of (name, last_mealtime) tuples # Example 2 # try: # database = DatabaseConnection(&#39;localhost&#39;, &#39;4444&#39;) # # get_animals(database, &#39;Meerkat&#39;) # except: # logging.exception(&#39;Expected&#39;) # else: # assert False # Example 3 from datetime import datetime from unittest.mock import Mock mock = Mock(spec=get_animals) expected = [ (&#39;Spot&#39;, datetime(2019, 6, 5, 11, 15)), (&#39;Fluffy&#39;, datetime(2019, 6, 5, 12, 30)), (&#39;Jojo&#39;, datetime(2019, 6, 5, 12, 45)), ] mock.return_value = expected # Example 4 # try: # mock.does_not_exist # except: # logging.exception(&#39;Expected&#39;) # else: # assert False # Example 5 database = object() result = mock(database, &#39;Meerkat&#39;) assert result == expected # Example 6 mock.assert_called_once_with(database, &#39;Meerkat&#39;) # Example 7 # try: # mock.assert_called_once_with(database, &#39;Giraffe&#39;) # except: # logging.exception(&#39;Expected&#39;) # else: # assert False # Example 8 from unittest.mock import ANY mock = Mock(spec=get_animals) mock(&#39;database 1&#39;, &#39;Rabbit&#39;) mock(&#39;database 2&#39;, &#39;Bison&#39;) mock(&#39;database 3&#39;, &#39;Meerkat&#39;) mock.assert_called_with(ANY, &#39;Meerkat&#39;) # Example 9 # try: # class MyError(Exception): # pass # # mock = Mock(spec=get_animals) # mock.side_effect = MyError(&#39;Whoops! Big problem&#39;) # result = mock(database, &#39;Meerkat&#39;) # except: # logging.exception(&#39;Expected&#39;) # else: # assert False # Example 10 def get_food_period(database, species): # Query the Database pass # Return a time delta def feed_animal(database, name, when): # Write to the Database pass def do_rounds(database, species): now = datetime.datetime.utcnow() feeding_timedelta = get_food_period(database, species) animals = get_animals(database, species) fed = 0 for name, last_mealtime in animals: if (now - last_mealtime) &gt; feeding_timedelta: feed_animal(database, name, now) fed += 1 return fed # Example 11 def do_rounds(database, species, *, now_func=datetime.utcnow, food_func=get_food_period, animals_func=get_animals, feed_func=feed_animal): now = now_func() feeding_timedelta = food_func(database, species) animals = animals_func(database, species) fed = 0 for name, last_mealtime in animals: if (now - last_mealtime) &gt; feeding_timedelta: feed_func(database, name, now) fed += 1 return fed # Example 12 from datetime import timedelta now_func = Mock(spec=datetime.utcnow) now_func.return_value = datetime(2019, 6, 5, 15, 45) food_func = Mock(spec=get_food_period) food_func.return_value = timedelta(hours=3) animals_func = Mock(spec=get_animals) animals_func.return_value = [ (&#39;Spot&#39;, datetime(2019, 6, 5, 11, 15)), (&#39;Fluffy&#39;, datetime(2019, 6, 5, 12, 30)), (&#39;Jojo&#39;, datetime(2019, 6, 5, 12, 45)), ] feed_func = Mock(spec=feed_animal) # Example 13 result = do_rounds( database, &#39;Meerkat&#39;, now_func=now_func, food_func=food_func, animals_func=animals_func, feed_func=feed_func) assert result == 2 # Example 14 from unittest.mock import call food_func.assert_called_once_with(database, &#39;Meerkat&#39;) animals_func.assert_called_once_with(database, &#39;Meerkat&#39;) feed_func.assert_has_calls( [ call(database, &#39;Spot&#39;, now_func.return_value), call(database, &#39;Fluffy&#39;, now_func.return_value), ], any_order=True) # Example 15 from unittest.mock import patch print(&#39;Outside patch:&#39;, get_animals) with patch(&#39;__main__.get_animals&#39;): print(&#39;Inside patch: &#39;, get_animals) print(&#39;Outside again:&#39;, get_animals) # Example 16 # try: # fake_now = datetime(2019, 6, 5, 15, 45) # # with patch(&#39;datetime.datetime.utcnow&#39;): # datetime.utcnow.return_value = fake_now # except: # logging.exception(&#39;Expected&#39;) # else: # assert False # Example 17 def get_do_rounds_time(): return datetime.datetime.utcnow() def do_rounds(database, species): now = get_do_rounds_time() with patch(&#39;__main__.get_do_rounds_time&#39;): pass # Example 18 def do_rounds(database, species, *, utcnow=datetime.utcnow): now = utcnow() feeding_timedelta = get_food_period(database, species) animals = get_animals(database, species) fed = 0 for name, last_mealtime in animals: if (now - last_mealtime) &gt; feeding_timedelta: feed_animal(database, name, now) fed += 1 return fed # Example 19 from unittest.mock import DEFAULT with patch.multiple(&#39;__main__&#39;, autospec=True, get_food_period=DEFAULT, get_animals=DEFAULT, feed_animal=DEFAULT): now_func = Mock(spec=datetime.utcnow) now_func.return_value = datetime(2019, 6, 5, 15, 45) get_food_period.return_value = timedelta(hours=3) get_animals.return_value = [ (&#39;Spot&#39;, datetime(2019, 6, 5, 11, 15)), (&#39;Fluffy&#39;, datetime(2019, 6, 5, 12, 30)), (&#39;Jojo&#39;, datetime(2019, 6, 5, 12, 45)) ] # Example 20 result = do_rounds(database, &#39;Meerkat&#39;, utcnow=now_func) assert result == 2 get_food_period.assert_called_once_with(database, &#39;Meerkat&#39;) get_animals.assert_called_once_with(database, &#39;Meerkat&#39;) feed_animal.assert_has_calls( [ call(database, &#39;Spot&#39;, now_func.return_value), call(database, &#39;Fluffy&#39;, now_func.return_value), ], any_order=True) 79. 把受测代码所依赖的系统封装起来，以便于模拟和测试# Example 1 class ZooDatabase: def get_animals(self, species): pass def get_food_period(self, species): pass def feed_animal(self, name, when): pass # Example 2 from datetime import datetime def do_rounds(database, species, *, utcnow=datetime.utcnow): now = utcnow() feeding_timedelta = database.get_food_period(species) animals = database.get_animals(species) fed = 0 for name, last_mealtime in animals: if (now - last_mealtime) &gt;= feeding_timedelta: database.feed_animal(name, now) fed += 1 return fed # Example 3 from unittest.mock import Mock database = Mock(spec=ZooDatabase) print(database.feed_animal) database.feed_animal() database.feed_animal.assert_any_call() # Example 4 from datetime import timedelta from unittest.mock import call now_func = Mock(spec=datetime.utcnow) now_func.return_value = datetime(2019, 6, 5, 15, 45) database = Mock(spec=ZooDatabase) database.get_food_period.return_value = timedelta(hours=3) database.get_animals.return_value = [ (&#39;Spot&#39;, datetime(2019, 6, 5, 11, 15)), (&#39;Fluffy&#39;, datetime(2019, 6, 5, 12, 30)), (&#39;Jojo&#39;, datetime(2019, 6, 5, 12, 55)) ] # Example 5 result = do_rounds(database, &#39;Meerkat&#39;, utcnow=now_func) assert result == 2 database.get_food_period.assert_called_once_with(&#39;Meerkat&#39;) database.get_animals.assert_called_once_with(&#39;Meerkat&#39;) database.feed_animal.assert_has_calls( [ call(&#39;Spot&#39;, now_func.return_value), call(&#39;Fluffy&#39;, now_func.return_value), ], any_order=True) # # Example 6 # try: # database.bad_method_name() # except: # logging.exception(&#39;Expected&#39;) # else: # assert False # Example 7 DATABASE = None def get_database(): global DATABASE if DATABASE is None: DATABASE = ZooDatabase() return DATABASE def main(argv): database = get_database() species = argv[1] count = do_rounds(database, species) print(f&#39;Fed {count} {species}(s)&#39;) return 0 # Example 8 import contextlib import io from unittest.mock import patch with patch(&#39;__main__.DATABASE&#39;, spec=ZooDatabase): now = datetime.utcnow() DATABASE.get_food_period.return_value = timedelta(hours=3) DATABASE.get_animals.return_value = [ (&#39;Spot&#39;, now - timedelta(minutes=4.5)), (&#39;Fluffy&#39;, now - timedelta(hours=3.25)), (&#39;Jojo&#39;, now - timedelta(hours=3)), ] fake_stdout = io.StringIO() with contextlib.redirect_stdout(fake_stdout): main([&#39;program name&#39;, &#39;Meerkat&#39;]) found = fake_stdout.getvalue() expected = &#39;Fed 2 Meerkat(s)\n&#39; assert found == expected 80. 考虑用pdb做交互调试import math def compute_rmse(observed, ideal): total_err_2 = 0 count = 0 for got, wanted in zip(observed, ideal): err_2 = (got - wanted) ** 2 breakpoint() # Start the debugger here total_err_2 += err_2 count += 1 mean_err = total_err_2 / count rmse = math.sqrt(mean_err) return rmse result = compute_rmse( [1.8, 1.7, 3.2, 6], [2, 1.5, 3, 5]) print(result) 81. 用tracemalloc来掌握内存的使用与泄漏情况 gc模块可以帮助我们了解垃圾回收器追踪到了哪些对象，但并不能告诉我们那些对象是如何分配的； import gc found_objects = gc.get_objects() print(&#39;Before:&#39;, len(found_objects)) import waste_memory hold_reference = waste_memory.run() found_objects = gc.get_objects() print(&#39;After: &#39;, len(found_objects)) for obj in found_objects[:3]: print(repr(obj)[:100]) print(&#39;...&#39;) python内置的tracemalloc模块提供了一套强大的工具，可以帮助我们了解内存的使用情况，并且找到这些内存由那一行代码所分配。 import tracemalloc tracemalloc.start(10) # Set stack depth time1 = tracemalloc.take_snapshot() # Before snapshot import os class MyObject: def __init__(self): self.data = os.urandom(100) def get_data(): values = [] for _ in range(100): obj = MyObject() values.append(obj) return values def run(): deep_values = [] for _ in range(100): deep_values.append(get_data()) return deep_values x = run() # Usage to debug time2 = tracemalloc.take_snapshot() # After snapshot stats = time2.compare_to(time1, &#39;lineno&#39;) # Compare snapshots for stat in stats[:3]: print(stat) import tracemalloc tracemalloc.start(10) time1 = tracemalloc.take_snapshot() import os class MyObject: def __init__(self): self.data = os.urandom(100) def get_data(): values = [] for _ in range(100): obj = MyObject() values.append(obj) return values def run(): deep_values = [] for _ in range(100): deep_values.append(get_data()) return deep_values x = run() time2 = tracemalloc.take_snapshot() stats = time2.compare_to(time1, &#39;traceback&#39;) top = stats[0] print(&#39;Biggest offender is:&#39;) print(&#39;\n&#39;.join(top.traceback.format())) 十. 协作并发82. 学会寻找由其他Python开发者所构建的模块python集中存放模块的地方：https://pypi.org 。 83. 用虚拟环境隔离项目，并重建依赖关系通过pip show可以查看它的依赖关系：python3 -m pip show flask, 结果如下： Name: Flask Version: 2.0.1 Summary: A simple framework for building complex web applications. Home-page: https://palletsprojects.com/p/flask Author: Armin Ronacher Author-email: armin.ronacher@active-4.com License: BSD-3-Clause Location: /usr/local/lib/python3.9/site-packages Requires: itsdangerous, click, Jinja2, Werkzeug Required-by: 在命令行界面执行venv命令： python3 -m venv 虚拟环境名 # 创建虚拟环境 source bin/activate 和 deactivate # 启用和禁用该环境 python3 -m pip install -r requirements.txt # 安装包 84. 每一个函数、类与模块都要写docstringimport itertools def find_anagrams(word, dictionary): &quot;&quot;&quot;Find all anagrams for a word. This function only runs as fast as the test for membership in the &#39;dictionary&#39; container. Args: word: String of the target word. dictionary: collections.abc.Container with all strings that are known to be actual words. Returns: List of anagrams that were found. Empty if none were found. &quot;&quot;&quot; permutations = itertools.permutations(word, len(word)) possible = (&#39;&#39;.join(x) for x in permutations) found = {word for word in possible if word in dictionary} return list(found) assert find_anagrams(&#39;pancakes&#39;, [&#39;scanpeak&#39;]) == [&#39;scanpeak&#39;] 85. 用包来安排模块，以提供稳固的API如我们想设计一个包，用来计算抛射物之间的碰撞 # mypackage/models.py __all__ = [&#39;Projectile&#39;] class Projectile: def __init__(self, mass, velocity): self.mass = mass self.velocity = velocity # mypackage/utils.py from . models import Projectile __all__ = [&#39;simulate_collision&#39;] def _dot_product(a, b): pass def simulate_collision(a, b): after_a = Projectile(-a.mass, -a.velocity) after_b = Projectile(-b.mass, -b.velocity) return after_a, after_b # mypackage/__init__.py __all__ = [] from . models import * __all__ += models.__all__ from . utils import * __all__ += utils.__all__ 没有出现在__all___之中的，都不会随着from mypackage import *语句引入，对外部使用者隐藏了这些名字。 # api_consumer.py from mypackage import * a = Projectile(1.5, 3) b = Projectile(4, 1.7) after_a, after_b = simulate_collision(a, b) print(after_a.__dict__, after_b.__dict__) # {&#39;mass&#39;: -1.5, &#39;velocity&#39;: -3} {&#39;mass&#39;: -4, &#39;velocity&#39;: -1.7} 86. 考虑用模块级别的代码配置不同的部署环境class TestingDatabase: pass class RealDatabase: pass TESTING = True if TESTING: Database = TestingDatabase else: Database = RealDatabase 87. 为自编的模块定义根异常，让调用者能够专门处理与此API有关的异常import logging # Example 1 # my_module.py def determine_weight(volume, density): if density &lt;= 0: raise ValueError(&#39;Density must be positive&#39;) try: determine_weight(1, 0) except ValueError: pass else: assert False # Example 2 # my_module.py class Error(Exception): &quot;&quot;&quot;Base-class for all exceptions raised by this module.&quot;&quot;&quot; class InvalidDensityError(Error): &quot;&quot;&quot;There was a problem with a provided density value.&quot;&quot;&quot; class InvalidVolumeError(Error): &quot;&quot;&quot;There was a problem with the provided weight value.&quot;&quot;&quot; def determine_weight(volume, density): if density &lt; 0: raise InvalidDensityError(&#39;Density must be positive&#39;) if volume &lt; 0: raise InvalidVolumeError(&#39;Volume must be positive&#39;) if volume == 0: density / volume # Example 3 class my_module: Error = Error InvalidDensityError = InvalidDensityError @staticmethod def determine_weight(volume, density): if density &lt; 0: raise InvalidDensityError(&#39;Density must be positive&#39;) if volume &lt; 0: raise InvalidVolumeError(&#39;Volume must be positive&#39;) if volume == 0: density / volume try: weight = my_module.determine_weight(1, -1) except my_module.Error: logging.exception(&#39;Unexpected error&#39;) else: assert False # Example 4 SENTINEL = object() weight = SENTINEL try: weight = my_module.determine_weight(-1, 1) except my_module.InvalidDensityError: weight = 0 except my_module.Error: logging.exception(&#39;Bug in the calling code&#39;) else: assert False assert weight is SENTINEL # Example 5 try: weight = SENTINEL try: weight = my_module.determine_weight(0, 1) except my_module.InvalidDensityError: weight = 0 except my_module.Error: logging.exception(&#39;Bug in the calling code&#39;) except Exception: logging.exception(&#39;Bug in the API code!&#39;) raise # Re-raise exception to the caller else: assert False assert weight == 0 except: logging.exception(&#39;Expected&#39;) else: assert False # Example 6 # my_module.py class NegativeDensityError(InvalidDensityError): &quot;&quot;&quot;A provided density value was negative.&quot;&quot;&quot; def determine_weight(volume, density): if density &lt; 0: raise NegativeDensityError(&#39;Density must be positive&#39;) # Example 7 try: my_module.NegativeDensityError = NegativeDensityError my_module.determine_weight = determine_weight try: weight = my_module.determine_weight(1, -1) except my_module.NegativeDensityError: raise ValueError(&#39;Must supply non-negative density&#39;) except my_module.InvalidDensityError: weight = 0 except my_module.Error: logging.exception(&#39;Bug in the calling code&#39;) except Exception: logging.exception(&#39;Bug in the API code!&#39;) raise else: assert False except: logging.exception(&#39;Expected&#39;) else: assert False 88. 用适当的方式打破循环依赖关系 如果两个模块都要在开头引入对方，那就会形成循环依赖关系，可能会导致程序启动时崩溃； 想要打破循环依赖，最好的办法是把这两个模块都用到的代码重构到整个依赖的最底层； 如果不想大幅度重构代码，也不想让代码太复杂，最简单的方法就是通过动态引入来消除循环依赖关系。 # dialog.py class Dialog: def __init__(self): pass # Using this instead will break things # save_dialog = Dialog(app.prefs.get(&#39;save_dir&#39;)) save_dialog = Dialog() def show(): import app # Dynamic import 程序运行时才触发 save_dialog.save_dir = app.prefs.get(&#39;save_dir&#39;) print(&#39;Showing the dialog!&#39;) # app.py import dialog class Prefs: def get(self, name): pass prefs = Prefs() dialog.show() 一般来说，还是应该尽量避免动态引入，因为import语句毕竟是有开销的，如果它出现在频繁执行的循环体里面，这种开销会更大。虽然如此，但是比大幅度修改整个程序要好。 89. 重构时考虑通过warnings提醒开发者API已经发生变化 # Example 1 def print_distance(speed, duration): distance = speed * duration print(f&#39;{distance} miles&#39;) print_distance(5, 2.5) # Example 2 print_distance(1000, 3) # Example 3 CONVERSIONS = { &#39;mph&#39;: 1.60934 / 3600 * 1000, # m/s &#39;hours&#39;: 3600, # seconds &#39;miles&#39;: 1.60934 * 1000, # m &#39;meters&#39;: 1, # m &#39;m/s&#39;: 1, # m &#39;seconds&#39;: 1, # s } def convert(value, units): rate = CONVERSIONS[units] return rate * value def localize(value, units): rate = CONVERSIONS[units] return value / rate def print_distance(speed, duration, *, speed_units=&#39;mph&#39;, time_units=&#39;hours&#39;, distance_units=&#39;miles&#39;): norm_speed = convert(speed, speed_units) norm_duration = convert(duration, time_units) norm_distance = norm_speed * norm_duration distance = localize(norm_distance, distance_units) print(f&#39;{distance} {distance_units}&#39;) # Example 4 print_distance(1000, 3, speed_units=&#39;meters&#39;, time_units=&#39;seconds&#39;) # Example 5 import warnings def print_distance(speed, duration, *, speed_units=None, time_units=None, distance_units=None): if speed_units is None: warnings.warn( &#39;speed_units required&#39;, DeprecationWarning) speed_units = &#39;mph&#39; if time_units is None: warnings.warn( &#39;time_units required&#39;, DeprecationWarning) time_units = &#39;hours&#39; if distance_units is None: warnings.warn( &#39;distance_units required&#39;, DeprecationWarning) distance_units = &#39;miles&#39; norm_speed = convert(speed, speed_units) norm_duration = convert(duration, time_units) norm_distance = norm_speed * norm_duration distance = localize(norm_distance, distance_units) print(f&#39;{distance} {distance_units}&#39;) # Example 6 import contextlib import io fake_stderr = io.StringIO() with contextlib.redirect_stderr(fake_stderr): print_distance(1000, 3, speed_units=&#39;meters&#39;, time_units=&#39;seconds&#39;) print(fake_stderr.getvalue()) # Example 7 def require(name, value, default): if value is not None: return value warnings.warn( f&#39;{name} will be required soon, update your code&#39;, DeprecationWarning, stacklevel=3) return default def print_distance(speed, duration, *, speed_units=None, time_units=None, distance_units=None): speed_units = require(&#39;speed_units&#39;, speed_units, &#39;mph&#39;) time_units = require(&#39;time_units&#39;, time_units, &#39;hours&#39;) distance_units = require( &#39;distance_units&#39;, distance_units, &#39;miles&#39;) norm_speed = convert(speed, speed_units) norm_duration = convert(duration, time_units) norm_distance = norm_speed * norm_duration distance = localize(norm_distance, distance_units) print(f&#39;{distance} {distance_units}&#39;) # Example 8 import contextlib import io fake_stderr = io.StringIO() with contextlib.redirect_stderr(fake_stderr): print_distance(1000, 3, speed_units=&#39;meters&#39;, time_units=&#39;seconds&#39;) print(fake_stderr.getvalue()) # Example 9 warnings.simplefilter(&#39;error&#39;) try: warnings.warn(&#39;This usage is deprecated&#39;, DeprecationWarning) except DeprecationWarning: pass # Expected else: assert False warnings.resetwarnings() # Example 10 warnings.resetwarnings() warnings.simplefilter(&#39;ignore&#39;) warnings.warn(&#39;This will not be printed to stderr&#39;) warnings.resetwarnings() # Example 11 import logging fake_stderr = io.StringIO() handler = logging.StreamHandler(fake_stderr) formatter = logging.Formatter( &#39;%(asctime)-15s WARNING] %(message)s&#39;) handler.setFormatter(formatter) logging.captureWarnings(True) logger = logging.getLogger(&#39;py.warnings&#39;) logger.addHandler(handler) logger.setLevel(logging.DEBUG) warnings.resetwarnings() warnings.simplefilter(&#39;default&#39;) warnings.warn(&#39;This will go to the logs output&#39;) print(fake_stderr.getvalue()) warnings.resetwarnings() # Example 12 with warnings.catch_warnings(record=True) as found_warnings: found = require(&#39;my_arg&#39;, None, &#39;fake units&#39;) expected = &#39;fake units&#39; assert found == expected # Example 13 assert len(found_warnings) == 1 single_warning = found_warnings[0] assert str(single_warning.message) == ( &#39;my_arg will be required soon, update your code&#39;) assert single_warning.category == DeprecationWarning 90. 考虑通过typing做静态分析，以消除bugtyping模块：https://docs.python.org/3.8/library/typing.html。可以给变量，字段，函数与方法标注类型信息。 from typing import Callable, List, TypeVar Value = TypeVar(&#39;Value&#39;) Func = Callable[[Value, Value], Value] def combine(func: Func[Value], values: List[Value]) -&gt; Value: assert len(values) &gt; 0 result = values[0] for next_value in values[1:]: result = func(result, next_value) return result Real = TypeVar(&#39;Real&#39;, int, float) def add(x: Real, y: Real) -&gt; Real: return x + y inputs = [1, 2, 3, 4j] # Oops: included a complex number result = combine(add, inputs) print(result) # (6+4j) assert result == 10 下面的python3.7开始支持，程序执行时，忽略类型注解里提到的值，于是就解决了提前引用的问题，而且程序在启动时的性能也会提升。 from __future__ import annotations class FirstClass: def __init__(self, value: SecondClass) -&gt; None: # OK self.value = value class SecondClass: def __init__(self, value: int) -&gt; None: self.value = value second = SecondClass(5) print(second) # &lt;__main__.SecondClass object at 0x7fafc12cd4d0&gt; first = FirstClass(second) print(first) # &lt;__main__.FirstClass object at 0x7fafc12cd510&gt;]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
        <tag>python优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将excel中的内容存入mysql]]></title>
    <url>%2F2020%2F12%2Fpython%2Fmy_application%2F20201202_%E5%B0%86excel%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9%E5%AD%98%E5%85%A5mysql%2F</url>
    <content type="text"><![CDATA[将excel中的内容存入mysql # -*- encoding: utf-8 -*- import time import xlrd import hashlib from sqlalchemy.orm import sessionmaker from sqlalchemy.ext.declarative import declarative_base from sqlalchemy import create_engine, Column, Integer, TIMESTAMP, CHAR, VARCHAR # mysql数据库 ENGINE = create_engine(&#39;mysql+pymysql://wxx:654321@***/weixx?charset=utf8&#39;) # ENGINE = create_engine(&#39;mysql+pymysql://cuh:123456@***/zk?charset=utf8&#39;) DBSession = sessionmaker(bind=ENGINE) session = DBSession() Base = declarative_base() class YonghuiGoodsInfoItem(Base): &quot;&quot;&quot;永辉超市部分商品表&quot;&quot;&quot; __tablename__ = &#39;yonghui_goods_info&#39; id = Column(Integer, primary_key=True, autoincrement=True) sha = Column(CHAR(40), unique=True) crawled_time = Column(TIMESTAMP, doc={&#39;zh&#39;: &#39;数据存入的时间&#39;}) shop_name = Column(VARCHAR(200), doc={&#39;zh&#39;: &#39;超市名称&#39;}) goods_id = Column(VARCHAR(200), doc={&#39;zh&#39;: &#39;商品id&#39;}) goods_name = Column(VARCHAR(200), doc={&#39;zh&#39;: &#39;商品名称&#39;}) goods_category = Column(VARCHAR(200), doc={&#39;zh&#39;: &#39;商品分类&#39;}) goods_price = Column(VARCHAR(200), doc={&#39;zh&#39;: &#39;商品价格&#39;}) goods_stock = Column(VARCHAR(200), doc={&#39;zh&#39;: &#39;商品库存&#39;}) goods_unit = Column(VARCHAR(200), doc={&#39;zh&#39;: &#39;商品单位&#39;}) goods_image = Column(VARCHAR(200), doc={&#39;zh&#39;: &#39;商品图片url&#39;}) goods_desc = Column(VARCHAR(200), doc={&#39;zh&#39;: &#39;商品描述&#39;}) @classmethod def creat_table(cls): &quot;&quot;&quot;创建数据表&quot;&quot;&quot; cls.__table__.create(bind=ENGINE, checkfirst=True) def insert(): &quot;&quot;&quot;插入数据&quot;&quot;&quot; wb = xlrd.open_workbook(filename=&#39;yonghui.xls&#39;) # 打开文件 sheet1 = wb.sheet_by_index(0) # 通过索引获取表格sheet1.nrows for i in range(1, sheet1.nrows): rows = sheet1.row_values(i) # 获取行内容 shop_name = rows[1] goods_id = rows[4] goods_name = rows[5] goods_category = rows[6] goods_price = rows[7] goods_stock = rows[9] goods_unit = rows[10] goods_image = rows[11] goods_desc = rows[12] time_now = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) sha = get_hash(goods_id+goods_name) print(goods_id, goods_name) try: result = session.query(YonghuiGoodsInfoItem).filter(YonghuiGoodsInfoItem.sha == sha).first() if not result: item = YonghuiGoodsInfoItem(sha=sha, crawled_time=time_now, shop_name=shop_name, goods_id=goods_id, goods_name=goods_name, goods_category=goods_category, goods_price=goods_price, goods_stock=goods_stock, goods_unit=goods_unit, goods_image=goods_image, goods_desc=goods_desc) session.add(item) else: result.crawled_time = time_now result.sha = sha session.commit() print(f&#39;时间:{time_now}, cookie:{goods_name} 已存入数据库！&#39;) except BaseException as e: session.rollback() session.close() raise BaseException(f&quot;数据插入失败: {e}&quot;) def get_hash(hash_str): hash = hashlib.sha1() hash.update(str(hash_str).encode(&#39;utf-8&#39;)) url_sha = hash.hexdigest() return url_sha if __name__ == &#39;__main__&#39;: table = YonghuiGoodsInfoItem() table.creat_table() insert()]]></content>
      <categories>
        <category>python</category>
        <category>python案例</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python案例</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用python实现代码雨]]></title>
    <url>%2F2020%2F10%2Fpython%2Fmy_application%2FPython3%E4%BB%A3%E7%A0%81%E9%9B%A8%2F</url>
    <content type="text"><![CDATA[用python实现代码雨：电影黑客帝国里的效果，代码可直接运行 # -*- coding:utf-8 -*- import random import pygame from pygame.locals import * from sys import exit PANEL_width = 1920 PANEL_highly = 1080 FONT_PX = 40 pygame.init() # 创建一个可视窗口, 如果不想全屏运行，可以把 FULLSCREEN 参数去掉 winSur = pygame.display.set_mode((PANEL_width, PANEL_highly), FULLSCREEN, 32) font = pygame.font.SysFont(&quot;SimHei&quot;, 35) bg_suface = pygame.Surface((PANEL_width, PANEL_highly), flags=pygame.SRCALPHA) pygame.Surface.convert(bg_suface) bg_suface.fill(pygame.Color(0, 0, 0, 20)) winSur.fill((0, 0, 0)) # 数字版 # texts = [font.render(str(i), True, (0, 255, 0)) for i in range(10)] # # 二进制版 # letter = [&#39;1&#39;, &#39;0&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;1&#39;, &#39;0&#39;, &#39;1&#39;, &#39;0&#39;, &#39;1&#39;, &#39;0&#39;, &#39;0&#39;, &#39;1&#39;, &#39;1&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;1&#39;, &#39;1&#39; # ,&#39;1&#39;, &#39;0&#39;, &#39;1&#39;, &#39;0&#39;, &#39;0&#39;, &#39;1&#39;, &#39;0&#39;, &#39;1&#39;] # # 汉字版,但看不到字 # letter = [&#39;我&#39;, &#39;爱&#39;, &#39;你&#39;, &#39;我&#39;, &#39;爱你&#39;, &#39;我爱你&#39;, &#39;我非常爱你&#39;, &#39;我爱你&#39;, &#39;我爱&#39;, &#39;我&#39;, &#39;爱&#39;, &#39;你&#39;, # &#39;我爱你&#39;, &#39;爱&#39;, &#39;我&#39;, &#39;爱你&#39;, &#39;我&#39;, &#39;我爱&#39;, &#39;爱你&#39;, &#39;你&#39;] # # # 字母版 letter = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;, &#39;h&#39;, &#39;i&#39;, &#39;j&#39;, &#39;k&#39;, &#39;l&#39;, &#39;m&#39;, &#39;n&#39;, &#39;o&#39;, &#39;p&#39;, &#39;q&#39;, &#39;r&#39;, &#39;s&#39;, &#39;t&#39;, &#39;u&#39;, &#39;v&#39; ,&#39;w&#39;, &#39;x&#39;, &#39;y&#39;, &#39;z&#39;] texts = [ font.render(str(letter[i]), True, (0, 255, 0)) for i in range(20) ] # 按屏幕的宽带计算可以在画板上放几列坐标并生成一个列表 column = int(PANEL_width / FONT_PX) drops = [0 for i in range(column)] while True: # 从队列中获取事件, 如果退出程序, 按两下确认键即可 for event in pygame.event.get(): if event.type == pygame.QUIT: exit() elif event.type == pygame.KEYDOWN: chang = pygame.key.get_pressed() if (chang[32]): exit() # 将暂停一段给定的毫秒数 pygame.time.delay(30) # 重新编辑图像第二个参数是坐上角坐标 winSur.blit(bg_suface, (0, 0)) for i in range(len(drops)): text = random.choice(texts) # 重新编辑每个坐标点的图像 winSur.blit(text, (i * FONT_PX, drops[i] * FONT_PX)) drops[i] += 1 if drops[i] * 10 &gt; PANEL_highly or random.random() &gt; 0.95: drops[i] = 0 pygame.display.flip() 实现效果截图如下：]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>python案例</tag>
        <tag>代码雨</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDK9到14的重要新特性]]></title>
    <url>%2F2020%2F10%2Fjava%2F%E5%85%B6%E4%BB%96%2F20201002_java9%E5%88%B014%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[文章来自：https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/new-features/%E4%B8%80%E6%96%87%E5%B8%A6%E4%BD%A0%E7%9C%8B%E9%81%8DJDK9%E5%88%B014%E7%9A%84%E9%87%8D%E8%A6%81%E6%96%B0%E7%89%B9%E6%80%A7.md Java9发布于 2017 年 9 月 21 日 。作为 Java8 之后 3 年半才发布的新版本，Java 9 带 来了很多重大的变化其中最重要的改动是 Java 平台模块系统的引入,其他还有诸如集合、Stream 流 Java 平台模块系统Java 平台模块系统，也就是 Project Jigsaw，把模块化开发实践引入到了 Java 平台中。在引入了模块系统之后，JDK 被重新组织成 94 个模块。Java 应用可以通过新增的 jlink 工具，创建出只包含所依赖的 JDK 模块的自定义运行时镜像。这样可以极大的减少 Java 运行时环境的大小。 Java 9 模块的重要特征是在其工件（artifact）的根目录中包含了一个描述模块的 module-info.class 文 件。 工件的格式可以是传统的 JAR 文件或是 Java 9 新增的 JMOD 文件。 Jshelljshell 是 Java 9 新增的一个实用工具。为 Java 提供了类似于 Python 的实时命令行交互工具。 在 Jshell 中可以直接输入表达式并查看其执行结果 集合、Stream 和 Optional 增加 了 List.of()、Set.of()、Map.of() 和 Map.ofEntries()等工厂方法来创建不可变集合，比如List.of(&quot;Java&quot;, &quot;C++&quot;);、Map.of(&quot;Java&quot;, 1, &quot;C++&quot;, 2);（这部分内容有点参考 Guava 的味道） Stream 中增加了新的方法 ofNullable、dropWhile、takeWhile 和 iterate 方法。Collectors 中增加了新的方法 filtering 和 flatMapping Optional 类中新增了 ifPresentOrElse、or 和 stream 等方法 进程 APIJava 9 增加了 ProcessHandle 接口，可以对原生进程进行管理，尤其适合于管理长时间运行的进程 平台日志 API 和服务Java 9 允许为 JDK 和应用配置同样的日志实现。新增了 System.LoggerFinder 用来管理 JDK 使 用的日志记录器实现。JVM 在运行时只有一个系统范围的 LoggerFinder 实例。 我们可以通过添加自己的 System.LoggerFinder 实现来让 JDK 和应用使用 SLF4J 等其他日志记录框架。 反应式流 （ Reactive Streams ） 在 Java9 中的 java.util.concurrent.Flow 类中新增了反应式流规范的核心接口 Flow 中包含了 Flow.Publisher、Flow.Subscriber、Flow.Subscription 和 Flow.Processor 等 4 个核心接口。Java 9 还提供了SubmissionPublisher 作为Flow.Publisher 的一个实现。 变量句柄 变量句柄是一个变量或一组变量的引用，包括静态域，非静态域，数组元素和堆外数据结构中的组成部分等 变量句柄的含义类似于已有的方法句柄MethodHandle 由 Java 类java.lang.invoke.VarHandle 来表示，可以使用类 java.lang.invoke.MethodHandles.Lookup 中的静态工厂方法来创建 VarHandle 对 象 改进方法句柄（Method Handle） 方法句柄从 Java7 开始引入，Java9 在类java.lang.invoke.MethodHandles 中新增了更多的静态方法来创建不同类型的方法句柄 其它新特性 接口私有方法 ：Java 9 允许在接口中使用私有方法 try-with-resources 增强 ：在 try-with-resources 语句中可以使用 effectively-final 变量（什么是 effectively-final 变量，见这篇文章 http://ilkinulas.github.io/programming/java/2016/03/27/effectively-final-java.html） 类 CompletableFuture 中增加了几个新的方法（completeAsync ，orTimeout 等） Nashorn 引擎的增强 ：Nashorn 从 Java8 开始引入的 JavaScript 引擎，Java9 对 Nashorn 做了些增强，实现了一些 ES6 的新特性 I/O 流的新特性 ：增加了新的方法来读取和复制 InputStream 中包含的数据 改进应用的安全性能 ：Java 9 新增了 4 个 SHA- 3 哈希算法，SHA3-224、SHA3-256、SHA3-384 和 S HA3-512 …… Java10发布于 2018 年 3 月 20 日，最知名的特性应该是 var 关键字（局部变量类型推断）的引入了，其他还有垃圾收集器改善、GC 改进、性能提升、线程管控等一批新特性 var 关键字 介绍 :提供了 var 关键字声明局部变量：var list = new ArrayList&lt;String&gt;(); // ArrayList&lt;String&gt; 局限性 ：只能用于带有构造器的局部变量和 for 循环中 Guide 哥：实际上 Lombok 早就体用了一个类似的关键字，使用它可以简化代码，但是可能会降低程序的易读性、可维护性。一般情况下，我个人都不太推荐使用。 不可变集合list，set，map 提供了静态方法copyOf()返回入参集合的一个不可变拷贝（以下为 JDK 的源码） static &lt;E&gt; List&lt;E&gt; copyOf(Collection&lt;? extends E&gt; coll) { return ImmutableCollections.listCopy(coll); } java.util.stream.Collectors中新增了静态方法，用于将流中的元素收集为不可变的集合 Optional 新增了orElseThrow()方法来在没有值时抛出异常 并行全垃圾回收器 G1从 Java9 开始 G1 就了默认的垃圾回收器，G1 是以一种低延时的垃圾回收器来设计的，旨在避免进行 Full GC,但是 Java9 的 G1 的 FullGC 依然是使用单线程去完成标记清除算法,这可能会导致垃圾回收期在无法回收内存的时候触发 Full GC。 为了最大限度地减少 Full GC 造成的应用停顿的影响，从 Java10 开始，G1 的 FullGC 改为并行的标记清除算法，同时会使用与年轻代回收和混合回收相同的并行工作线程数量，从而减少了 Full GC 的发生，以带来更好的性能提升、更大的吞吐量。 应用程序类数据共享在 Java 5 中就已经引入了类数据共享机制 (Class Data Sharing，简称 CDS)，允许将一组类预处理为共享归档文件，以便在运行时能够进行内存映射以减少 Java 程序的启动时间，当多个 Java 虚拟机（JVM）共享相同的归档文件时，还可以减少动态内存的占用量，同时减少多个虚拟机在同一个物理或虚拟的机器上运行时的资源占用 Java 10 在现有的 CDS 功能基础上再次拓展，以允许应用类放置在共享存档中。CDS 特性在原来的 bootstrap 类基础之上，扩展加入了应用类的 CDS (Application Class-Data Sharing) 支持。其原理为：在启动时记录加载类的过程，写入到文本文件中，再次启动时直接读取此启动文本并加载。设想如果应用环境没有大的变化，启动速度就会得到提升 其他特性 线程-局部管控：Java 10 中线程管控引入 JVM 安全点的概念，将允许在不运行全局 JVM 安全点的情况下实现线程回调，由线程本身或者 JVM 线程来执行，同时保持线程处于阻塞状态，这种方式使得停止单个线程变成可能，而不是只能启用或停止所有线程 备用存储装置上的堆分配：Java 10 中将使得 JVM 能够使用适用于不同类型的存储机制的堆，在可选内存设备上进行堆内存分配 统一的垃圾回收接口：Java 10 中，hotspot/gc 代码实现方面，引入一个干净的 GC 接口，改进不同 GC 源代码的隔离性，多个 GC 之间共享的实现细节代码应该存在于辅助类中。统一垃圾回收接口的主要原因是：让垃圾回收器（GC）这部分代码更加整洁，便于新人上手开发，便于后续排查相关问题。 Java11Java11 于 2018 年 9 月 25 日正式发布，这是很重要的一个版本！Java 11 和 2017 年 9 月份发布的 Java 9 以及 2018 年 3 月份发布的 Java 10 相比，其最大的区别就是：在长期支持(Long-Term-Support)方面，Oracle 表示会对 Java 11 提供大力支持，这一支持将会持续至 2026 年 9 月。这是据 Java 8 以后支持的首个长期版本。 字符串加强Java 11 增加了一系列的字符串处理方法，如以下所示。 Guide 哥：说白点就是多了层封装，JDK 开发组的人没少看市面上常见的工具类框架啊! //判断字符串是否为空 &quot; &quot;.isBlank();//true //去除字符串首尾空格 &quot; Java &quot;.strip();// &quot;Java&quot; //去除字符串首部空格 &quot; Java &quot;.stripLeading(); // &quot;Java &quot; //去除字符串尾部空格 &quot; Java &quot;.stripTrailing(); // &quot; Java&quot; //重复字符串多少次 &quot;Java&quot;.repeat(3); // &quot;JavaJavaJava&quot; //返回由行终止符分隔的字符串集合。 &quot;A\nB\nC&quot;.lines().count(); // 3 &quot;A\nB\nC&quot;.lines().collect(Collectors.toList()); ZGC：可伸缩低延迟垃圾收集器ZGC 即 Z Garbage Collector，是一个可伸缩的、低延迟的垃圾收集器。 ZGC 主要为了满足如下目标进行设计： GC 停顿时间不超过 10ms 即能处理几百 MB 的小堆，也能处理几个 TB 的大堆 应用吞吐能力不会下降超过 15%（与 G1 回收算法相比） 方便在此基础上引入新的 GC 特性和利用 colord 针以及 Load barriers 优化奠定基础 当前只支持 Linux/x64 位平台 ZGC 目前 处在实验阶段，只支持 Linux/x64 平台 标准 HTTP Client 升级Java 11 对 Java 9 中引入并在 Java 10 中进行了更新的 Http Client API 进行了标准化，在前两个版本中进行孵化的同时，Http Client 几乎被完全重写，并且现在完全支持异步非阻塞。 并且，Java11 中，Http Client 的包名由 jdk.incubator.http 改为java.net.http，该 API 通过 CompleteableFuture 提供非阻塞请求和响应语义。 使用起来也很简单，如下： var request = HttpRequest.newBuilder() .uri(URI.create(&quot;https://javastack.cn&quot;)) .GET() .build(); var client = HttpClient.newHttpClient(); // 同步 HttpResponse&lt;String&gt; response = client.send(request, HttpResponse.BodyHandlers.ofString()); System.out.println(response.body()); // 异步 client.sendAsync(request, HttpResponse.BodyHandlers.ofString()) .thenApply(HttpResponse::body) .thenAccept(System.out::println); 简化启动单个源代码文件的方法 增强了 Java 启动器，使其能够运行单一文件的 Java 源代码。此功能允许使用 Java 解释器直接执行 Java 源代码。源代码在内存中编译，然后由解释器执行。唯一的约束在于所有相关的类必须定义在同一个 Java 文件中 对于 Java 初学者并希望尝试简单程序的人特别有用，并且能和 jshell 一起使用 一定能程度上增强了使用 Java 来写脚本程序的能力 用于 Lambda 参数的局部变量语法 从 Java 10 开始，便引入了局部变量类型推断这一关键特性。类型推断允许使用关键字 var 作为局部变量的类型而不是实际类型，编译器根据分配给变量的值推断出类型 Java 10 中对 var 关键字存在几个限制 只能用于局部变量上 声明时必须初始化 不能用作方法参数 不能在 Lambda 表达式中使用 Java11 开始允许开发者在 Lambda 表达式中使用 var 进行参数声明 其他特性 新的垃圾回收器 Epsilon，一个完全消极的 GC 实现，分配有限的内存资源，最大限度的降低内存占用和内存吞吐延迟时间 低开销的 Heap Profiling：Java 11 中提供一种低开销的 Java 堆分配采样方法，能够得到堆分配的 Java 对象信息，并且能够通过 JVMTI 访问堆信息 TLS1.3 协议：Java 11 中包含了传输层安全性（TLS）1.3 规范（RFC 8446）的实现，替换了之前版本中包含的 TLS，包括 TLS 1.2，同时还改进了其他 TLS 功能，例如 OCSP 装订扩展（RFC 6066，RFC 6961），以及会话散列和扩展主密钥扩展（RFC 7627），在安全性和性能方面也做了很多提升 飞行记录器：飞行记录器之前是商业版 JDK 的一项分析工具，但在 Java 11 中，其代码被包含到公开代码库中，这样所有人都能使用该功能了 Java12增强 Switch 传统的 switch 语法存在容易漏写 break 的问题，而且从代码整洁性层面来看，多个 break 本质也是一种重复 Java12 提供了 swtich 表达式，使用类似 lambda 语法条件匹配成功后的执行块，不需要多写 break 作为预览特性加入，需要在javac编译和java运行时增加参数--enable-preview switch (day) { case MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(6); case TUESDAY -&gt; System.out.println(7); case THURSDAY, SATURDAY -&gt; System.out.println(8); case WEDNESDAY -&gt; System.out.println(9); } 数字格式化工具类 NumberFormat 新增了对复杂的数字进行格式化的支持 NumberFormat fmt = NumberFormat.getCompactNumberInstance(Locale.US, NumberFormat.Style.SHORT); String result = fmt.format(1000); System.out.println(result); // 输出为 1K，计算工资是多少K更方便了。。。 Shenandoah GC Redhat 主导开发的 Pauseless GC 实现，主要目标是 99.9% 的暂停小于 10ms，暂停与堆大小无关等 和 Java11 开源的 ZGC 相比（需要升级到 JDK11 才能使用），Shenandoah GC 有稳定的 JDK8u 版本，在 Java8 占据主要市场份额的今天有更大的可落地性 G1 收集器提升 Java12 为默认的垃圾收集器 G1 带来了两项更新: 可中止的混合收集集合：JEP344 的实现，为了达到用户提供的停顿时间目标，JEP 344 通过把要被回收的区域集（混合收集集合）拆分为强制和可选部分，使 G1 垃圾回收器能中止垃圾回收过程。 G1 可以中止可选部分的回收以达到停顿时间目标 及时返回未使用的已分配内存：JEP346 的实现，增强 G1 GC，以便在空闲时自动将 Java 堆内存返回给操作系统 Java13引入 yield 关键字到 Switch 中 Switch 表达式中就多了一个关键字用于跳出 Switch 块的关键字 yield，主要用于返回一个值 yield和 return 的区别在于：return 会直接跳出当前循环或者方法，而 yield 只会跳出当前 Switch 块，同时在使用 yield 时，需要有 default 条件 private static String descLanguage(String name) { return switch (name) { case &quot;Java&quot;: yield &quot;object-oriented, platform independent and secured&quot;; case &quot;Ruby&quot;: yield &quot;a programmer&#39;s best friend&quot;; default: yield name +&quot; is a good language&quot;; }; } 文本块 解决 Java 定义多行字符串时只能通过换行转义或者换行连接符来变通支持的问题，引入三重双引号来定义多行文本 两个&quot;&quot;&quot;中间的任何内容都会被解释为字符串的一部分，包括换行符 String json =&quot;{\n&quot; + &quot; \&quot;name\&quot;:\&quot;mkyong\&quot;,\n&quot; + &quot; \&quot;age\&quot;:38\n&quot; + &quot;}\n&quot;; // 未支持文本块之前 String json = &quot;&quot;&quot; { &quot;name&quot;:&quot;mkyong&quot;, &quot;age&quot;:38 } &quot;&quot;&quot;; 增强 ZGC 释放未使用内存 在 Java 11 中是实验性的引入的 ZGC 在实际的使用中存在未能主动将未使用的内存释放给操作系统的问题 ZGC 堆由一组称为 ZPages 的堆区域组成。在 GC 周期中清空 ZPages 区域时，它们将被释放并返回到页面缓存 ZPageCache 中，此缓存中的 ZPages 按最近最少使用（LRU）的顺序，并按照大小进行组织 在 Java 13 中，ZGC 将向操作系统返回被标识为长时间未使用的页面，这样它们将可以被其他进程重用 SocketAPI 重构 Java 13 为 Socket API 带来了新的底层实现方法，并且在 Java 13 中是默认使用新的 Socket 实现，使其易于发现并在排除问题同时增加可维护性 动态应用程序类-数据共享 Java 13 中对 Java 10 中引入的 应用程序类数据共享进行了进一步的简化、改进和扩展，即：允许在 Java 应用程序执行结束时动态进行类归档，具体能够被归档的类包括：所有已被加载，但不属于默认基层 CDS 的应用程序类和引用类库中的类 Java14record 关键字 简化数据类的定义方式，使用 record 代替 class 定义的类，只需要声明属性，就可以在获得属性的访问方法，以及 toString，hashCode,equals 方法 类似于使用 Class 定义类，同时使用了 lomobok 插件，并打上了@Getter,@ToString,@EqualsAndHashCode注解 作为预览特性引入 /** * 这个类具有两个特征 * 1. 所有成员属性都是final * 2. 全部方法由构造方法，和两个成员属性访问器组成（共三个） * 那么这种类就很适合使用record来声明 */ final class Rectangle implements Shape { final double length; final double width; public Rectangle(double length, double width) { this.length = length; this.width = width; } double length() { return length; } double width() { return width; } } /** * 1. 使用record声明的类会自动拥有上面类中的三个方法 * 2. 在这基础上还附赠了equals()，hashCode()方法以及toString()方法 * 3. toString方法中包括所有成员属性的字符串表示形式及其名称 */ record Rectangle(float length, float width) { } 空指针异常精准提示 通过 JVM 参数中添加-XX:+ShowCodeDetailsInExceptionMessages，可以在空指针异常中获取更为详细的调用信息，更快的定位和解决问题 a.b.c.i = 99; // 假设这段代码会发生空指针 Exception in thread &quot;main&quot; java.lang.NullPointerException: Cannot read field &#39;c&#39; because &#39;a.b&#39; is null. at Prog.main(Prog.java:5) // 增加参数后提示的异常中很明确的告知了哪里为空导致 switch 的增强终于转正 JDK12 引入的 switch（预览特性）在 JDK14 变为正式版本，不需要增加参数来启用，直接在 JDK14 中就能使用 主要是用-&gt;来替代以前的:+break；另外就是提供了 yield 来在 block 中返回值 Before Java 14 switch (day) { case MONDAY: case FRIDAY: case SUNDAY: System.out.println(6); break; case TUESDAY: System.out.println(7); break; case THURSDAY: case SATURDAY: System.out.println(8); break; case WEDNESDAY: System.out.println(9); break; } Java 14 enhancements switch (day) { case MONDAY, FRIDAY, SUNDAY -&gt; System.out.println(6); case TUESDAY -&gt; System.out.println(7); case THURSDAY, SATURDAY -&gt; System.out.println(8); case WEDNESDAY -&gt; System.out.println(9); } instanceof 增强 instanceof 主要在类型强转前探测对象的具体类型，然后执行具体的强转 新版的 instanceof 可以在判断的是否属于具体的类型同时完成转换 Object obj = &quot;我是字符串&quot;; if(obj instanceof String str){ System.out.println(str); } 其他特性 从 Java11 引入的 ZGC 作为继 G1 过后的下一代 GC 算法，从支持 Linux 平台到 Java14 开始支持 MacOS 和 Window（个人感觉是终于可以在日常开发工具中先体验下 ZGC 的效果了，虽然其实 G1 也够用） 移除了 CMS 垃圾收集器（功成而退） 新增了 jpackage 工具，标配将应用打成 jar 包外，还支持不同平台的特性包，比如 linux 下的deb和rpm，window 平台下的msi和exe 总结关于预览特性 先贴一段 oracle 官网原文：This is a preview feature, which is a feature whose design, specification, and implementation are complete, but is not permanent, which means that the feature may exist in a different form or not at all in future JDK releases. To compile and run code that contains preview features, you must specify additional command-line options. 这是一个预览功能，该功能的设计，规格和实现是完整的，但不是永久性的，这意味着该功能可能以其他形式存在或在将来的 JDK 版本中根本不存在。 要编译和运行包含预览功能的代码，必须指定其他命令行选项。 就以switch的增强为例子，从 Java12 中推出，到 Java13 中将继续增强，直到 Java14 才正式转正进入 JDK 可以放心使用，不用考虑后续 JDK 版本对其的改动或修改 一方面可以看出 JDK 作为标准平台在增加新特性的严谨态度，另一方面个人认为是对于预览特性应该采取审慎使用的态度。特性的设计和实现容易，但是其实际价值依然需要在使用中去验证 JVM 虚拟机优化 每次 Java 版本的发布都伴随着对 JVM 虚拟机的优化，包括对现有垃圾回收算法的改进，引入新的垃圾回收算法，移除老旧的不再适用于今天的垃圾回收算法等 整体优化的方向是高效，低时延的垃圾回收表现 对于日常的应用开发者可能比较关注新的语法特性，但是从一个公司角度来说，在考虑是否升级 Java 平台时更加考虑的是JVM 运行时的提升 参考信息 IBM Developer Java9 https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-9/ Guide to Java10 https://www.baeldung.com/java-10-overview Java 10 新特性介绍https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-10/index.html IBM Devloper Java11 https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-11/index.html Java 11 – Features and Comparison： https://www.geeksforgeeks.org/java-11-features-and-comparison/ Oracle Java12 ReleaseNote https://www.oracle.com/technetwork/java/javase/12all-relnotes-5211423.html#NewFeature Oracle Java13 ReleaseNote https://www.oracle.com/technetwork/java/javase/13all-relnotes-5461743.html#NewFeature New Java13 Features https://www.baeldung.com/java-13-new-features Java13 新特性概述 https://www.ibm.com/developerworks/cn/java/the-new-features-of-Java-13/index.html Oracle Java14 record https://docs.oracle.com/en/java/javase/14/language/records.html java14-features https://www.techgeeknext.com/java/java14-features]]></content>
      <categories>
        <category>Java</category>
        <category>新特性</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8新特性总结]]></title>
    <url>%2F2020%2F10%2Fjava%2F%E5%85%B6%E4%BB%96%2F20201001_java8%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[文章来自：https://github.com/Snailclimb/JavaGuide/edit/master/docs/java/new-features/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93.md Github 上有一个相关的仓库，地址：https://github.com/winterbe/java8-tutorial。这个仓库是英文的，下面是中文了。 Java 8 Tutorial 接口的默认方法(Default Methods for Interfaces) Lambda表达式(Lambda expressions) 函数式接口(Functional Interfaces) 方法和构造函数引用(Method and Constructor References) Lamda 表达式作用域(Lambda Scopes) 访问局部变量 访问字段和静态变量 访问默认接口方法 内置函数式接口(Built-in Functional Interfaces) Predicate Function Supplier Consumer Comparator Optional Streams(流) Filter(过滤) Sorted(排序) Map(映射) Match(匹配) Count(计数) Reduce(规约) Parallel Streams(并行流) Sequential Sort(串行排序) Parallel Sort(并行排序) Maps Date API(日期相关API) Clock Timezones(时区) LocalTime(本地时间) LocalDate(本地日期) LocalDateTime(本地日期时间) Annotations(注解) Where to go from here? Java 8 Tutorial欢迎阅读我对Java 8的介绍。本教程将逐步指导您完成所有新语言功能。 在简短的代码示例的基础上，您将学习如何使用默认接口方法，lambda表达式，方法引用和可重复注释。 在本文的最后，您将熟悉最新的 API 更改，如流，函数式接口(Functional Interfaces)，Map 类的扩展和新的 Date API。 没有大段枯燥的文字，只有一堆注释的代码片段。 接口的默认方法(Default Methods for Interfaces)Java 8使我们能够通过使用 default 关键字向接口添加非抽象方法实现。 此功能也称为虚拟扩展方法。 第一个例子： interface Formula{ double calculate(int a); default double sqrt(int a) { return Math.sqrt(a); } } Formula 接口中除了抽象方法计算接口公式还定义了默认方法 sqrt。 实现该接口的类只需要实现抽象方法 calculate。 默认方法sqrt 可以直接使用。当然你也可以直接通过接口创建对象，然后实现接口中的默认方法就可以了，我们通过代码演示一下这种方式。 public class Main { public static void main(String[] args) { // 通过匿名内部类方式访问接口 Formula formula = new Formula() { @Override public double calculate(int a) { return sqrt(a * 100); } }; System.out.println(formula.calculate(100)); // 100.0 System.out.println(formula.sqrt(16)); // 4.0 } } formula 是作为匿名对象实现的。该代码非常容易理解，6行代码实现了计算 sqrt(a * 100)。在下一节中，我们将会看到在 Java 8 中实现单个方法对象有一种更好更方便的方法。 译者注： 不管是抽象类还是接口，都可以通过匿名内部类的方式访问。不能通过抽象类或者接口直接创建对象。对于上面通过匿名内部类方式访问接口，我们可以这样理解：一个内部类实现了接口里的抽象方法并且返回一个内部类对象，之后我们让接口的引用来指向这个对象。 Lambda表达式(Lambda expressions)首先看看在老版本的Java中是如何排列字符串的： List&lt;String&gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;); Collections.sort(names, new Comparator&lt;String&gt;() { @Override public int compare(String a, String b) { return b.compareTo(a); } }); 只需要给静态方法Collections.sort 传入一个 List 对象以及一个比较器来按指定顺序排列。通常做法都是创建一个匿名的比较器对象然后将其传递给 sort 方法。 在Java 8 中你就没必要使用这种传统的匿名对象的方式了，Java 8提供了更简洁的语法，lambda表达式： Collections.sort(names, (String a, String b) -&gt; { return b.compareTo(a); }); 可以看出，代码变得更段且更具有可读性，但是实际上还可以写得更短： Collections.sort(names, (String a, String b) -&gt; b.compareTo(a)); 对于函数体只有一行代码的，你可以去掉大括号{}以及return关键字，但是你还可以写得更短点： names.sort((a, b) -&gt; b.compareTo(a)); List 类本身就有一个 sort 方法。并且Java编译器可以自动推导出参数类型，所以你可以不用再写一次类型。接下来我们看看lambda表达式还有什么其他用法。 函数式接口(Functional Interfaces)译者注： 原文对这部分解释不太清楚，故做了修改！ Java 语言设计者们投入了大量精力来思考如何使现有的函数友好地支持Lambda。最终采取的方法是：增加函数式接口的概念。“函数式接口”是指仅仅只包含一个抽象方法,但是可以有多个非抽象方法(也就是上面提到的默认方法)的接口。 像这样的接口，可以被隐式转换为lambda表达式。java.lang.Runnable 与 java.util.concurrent.Callable 是函数式接口最典型的两个例子。Java 8增加了一种特殊的注解@FunctionalInterface,但是这个注解通常不是必须的(某些情况建议使用)，只要接口只包含一个抽象方法，虚拟机会自动判断该接口为函数式接口。一般建议在接口上使用@FunctionalInterface 注解进行声明，这样的话，编译器如果发现你标注了这个注解的接口有多于一个抽象方法的时候会报错的，如下图所示 示例： @FunctionalInterface public interface Converter&lt;F, T&gt; { T convert(F from); } // TODO 将数字字符串转换为整数类型 Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from); Integer converted = converter.convert(&quot;123&quot;); System.out.println(converted.getClass()); //class java.lang.Integer 译者注： 大部分函数式接口都不用我们自己写，Java8都给我们实现好了，这些接口都在java.util.function包里。 方法和构造函数引用(Method and Constructor References)前一节中的代码还可以通过静态方法引用来表示： Converter&lt;String, Integer&gt; converter = Integer::valueOf; Integer converted = converter.convert(&quot;123&quot;); System.out.println(converted.getClass()); //class java.lang.Integer Java 8允许您通过::关键字传递方法或构造函数的引用。 上面的示例显示了如何引用静态方法。 但我们也可以引用对象方法： class Something { String startsWith(String s) { return String.valueOf(s.charAt(0)); } } Something something = new Something(); Converter&lt;String, String&gt; converter = something::startsWith; String converted = converter.convert(&quot;Java&quot;); System.out.println(converted); // &quot;J&quot; 接下来看看构造函数是如何使用::关键字来引用的，首先我们定义一个包含多个构造函数的简单类： class Person { String firstName; String lastName; Person() {} Person(String firstName, String lastName) { this.firstName = firstName; this.lastName = lastName; } } 接下来我们指定一个用来创建Person对象的对象工厂接口： interface PersonFactory&lt;P extends Person&gt; { P create(String firstName, String lastName); } 这里我们使用构造函数引用来将他们关联起来，而不是手动实现一个完整的工厂： PersonFactory&lt;Person&gt; personFactory = Person::new; Person person = personFactory.create(&quot;Peter&quot;, &quot;Parker&quot;); 我们只需要使用 Person::new 来获取Person类构造函数的引用，Java编译器会自动根据PersonFactory.create方法的参数类型来选择合适的构造函数。 Lamda 表达式作用域(Lambda Scopes)访问局部变量我们可以直接在 lambda 表达式中访问外部的局部变量： final int num = 1; Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num); stringConverter.convert(2); // 3 但是和匿名对象不同的是，这里的变量num可以不用声明为final，该代码同样正确： int num = 1; Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num); stringConverter.convert(2); // 3 不过这里的 num 必须不可被后面的代码修改（即隐性的具有final的语义），例如下面的就无法编译： int num = 1; Converter&lt;Integer, String&gt; stringConverter = (from) -&gt; String.valueOf(from + num); num = 3;//在lambda表达式中试图修改num同样是不允许的。 访问字段和静态变量与局部变量相比，我们对lambda表达式中的实例字段和静态变量都有读写访问权限。 该行为和匿名对象是一致的。 class Lambda4 { static int outerStaticNum; int outerNum; void testScopes() { Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; { outerNum = 23; return String.valueOf(from); }; Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; { outerStaticNum = 72; return String.valueOf(from); }; } } 访问默认接口方法还记得第一节中的 formula 示例吗？ Formula 接口定义了一个默认方法sqrt，可以从包含匿名对象的每个 formula 实例访问该方法。 这不适用于lambda表达式。 无法从 lambda 表达式中访问默认方法,故以下代码无法编译： Formula formula = (a) -&gt; sqrt(a * 100); 内置函数式接口(Built-in Functional Interfaces)JDK 1.8 API包含许多内置函数式接口。 其中一些借口在老版本的 Java 中是比较常见的比如： Comparator 或Runnable，这些接口都增加了@FunctionalInterface注解以便能用在 lambda 表达式上。 但是 Java 8 API 同样还提供了很多全新的函数式接口来让你的编程工作更加方便，有一些接口是来自 Google Guava 库里的，即便你对这些很熟悉了，还是有必要看看这些是如何扩展到lambda上使用的。 PredicatePredicate 接口是只有一个参数的返回布尔类型值的 断言型 接口。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）： 译者注： Predicate 接口源码如下 package java.util.function; import java.util.Objects; @FunctionalInterface public interface Predicate&lt;T&gt; { // 该方法是接受一个传入类型,返回一个布尔值.此方法应用于判断. boolean test(T t); //and方法与关系型运算符&quot;&amp;&amp;&quot;相似，两边都成立才返回true default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) { Objects.requireNonNull(other); return (t) -&gt; test(t) &amp;&amp; other.test(t); } // 与关系运算符&quot;!&quot;相似，对判断进行取反 default Predicate&lt;T&gt; negate() { return (t) -&gt; !test(t); } //or方法与关系型运算符&quot;||&quot;相似，两边只要有一个成立就返回true default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) { Objects.requireNonNull(other); return (t) -&gt; test(t) || other.test(t); } // 该方法接收一个Object对象,返回一个Predicate类型.此方法用于判断第一个test的方法与第二个test方法相同(equal). static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) { return (null == targetRef) ? Objects::isNull : object -&gt; targetRef.equals(object); } 示例： Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; 0; predicate.test(&quot;foo&quot;); // true predicate.negate().test(&quot;foo&quot;); // false Predicate&lt;Boolean&gt; nonNull = Objects::nonNull; Predicate&lt;Boolean&gt; isNull = Objects::isNull; Predicate&lt;String&gt; isEmpty = String::isEmpty; Predicate&lt;String&gt; isNotEmpty = isEmpty.negate(); FunctionFunction 接口接受一个参数并生成结果。默认方法可用于将多个函数链接在一起（compose, andThen）： 译者注： Function 接口源码如下 package java.util.function; import java.util.Objects; @FunctionalInterface public interface Function&lt;T, R&gt; { //将Function对象应用到输入的参数上，然后返回计算结果。 R apply(T t); //将两个Function整合，并返回一个能够执行两个Function对象功能的Function对象。 default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) { Objects.requireNonNull(before); return (V v) -&gt; apply(before.apply(v)); } // default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) { Objects.requireNonNull(after); return (T t) -&gt; after.apply(apply(t)); } static &lt;T&gt; Function&lt;T, T&gt; identity() { return t -&gt; t; } } Function&lt;String, Integer&gt; toInteger = Integer::valueOf; Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf); backToString.apply(&quot;123&quot;); // &quot;123&quot; SupplierSupplier 接口产生给定泛型类型的结果。 与 Function 接口不同，Supplier 接口不接受参数。 Supplier&lt;Person&gt; personSupplier = Person::new; personSupplier.get(); // new Person ConsumerConsumer 接口表示要对单个输入参数执行的操作。 Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(&quot;Hello, &quot; + p.firstName); greeter.accept(new Person(&quot;Luke&quot;, &quot;Skywalker&quot;)); ComparatorComparator 是老Java中的经典接口， Java 8在此之上添加了多种默认方法： Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName); Person p1 = new Person(&quot;John&quot;, &quot;Doe&quot;); Person p2 = new Person(&quot;Alice&quot;, &quot;Wonderland&quot;); comparator.compare(p1, p2); // &gt; 0 comparator.reversed().compare(p1, p2); // &lt; 0 OptionalOptional不是函数式接口，而是用于防止 NullPointerException 的漂亮工具。这是下一节的一个重要概念，让我们快速了解一下Optional的工作原理。 Optional 是一个简单的容器，其值可能是null或者不是null。在Java 8之前一般某个函数应该返回非空对象但是有时却什么也没有返回，而在Java 8中，你应该返回 Optional 而不是 null。 译者注：示例中每个方法的作用已经添加。 //of（）：为非null的值创建一个Optional Optional&lt;String&gt; optional = Optional.of(&quot;bam&quot;); // isPresent（）： 如果值存在返回true，否则返回false optional.isPresent(); // true //get()：如果Optional有值则将其返回，否则抛出NoSuchElementException optional.get(); // &quot;bam&quot; //orElse（）：如果有值则将其返回，否则返回指定的其它值 optional.orElse(&quot;fallback&quot;); // &quot;bam&quot; //ifPresent（）：如果Optional实例有值则为其调用consumer，否则不做处理 optional.ifPresent((s) -&gt; System.out.println(s.charAt(0))); // &quot;b&quot; 推荐阅读：[Java8]如何正确使用Optional Streams(流)java.util.Stream 表示能应用在一组元素上一次执行的操作序列。Stream 操作分为中间操作或者最终操作两种，最终操作返回一特定类型的计算结果，而中间操作返回Stream本身，这样你就可以将多个操作依次串起来。Stream 的创建需要指定一个数据源，比如java.util.Collection 的子类，List 或者 Set， Map 不支持。Stream 的操作可以串行执行或者并行执行。 首先看看Stream是怎么用，首先创建实例代码的用到的数据List： List&lt;String&gt; stringList = new ArrayList&lt;&gt;(); stringList.add(&quot;ddd2&quot;); stringList.add(&quot;aaa2&quot;); stringList.add(&quot;bbb1&quot;); stringList.add(&quot;aaa1&quot;); stringList.add(&quot;bbb3&quot;); stringList.add(&quot;ccc&quot;); stringList.add(&quot;bbb2&quot;); stringList.add(&quot;ddd1&quot;); Java 8扩展了集合类，可以通过 Collection.stream() 或者 Collection.parallelStream() 来创建一个Stream。下面几节将详细解释常用的Stream操作： Filter(过滤)过滤通过一个predicate接口来过滤并只保留符合条件的元素，该操作属于中间操作，所以我们可以在过滤后的结果来应用其他Stream操作（比如forEach）。forEach需要一个函数来对过滤后的元素依次执行。forEach是一个最终操作，所以我们不能在forEach之后来执行其他Stream操作。 // 测试 Filter(过滤) stringList .stream() .filter((s) -&gt; s.startsWith(&quot;a&quot;)) .forEach(System.out::println);//aaa2 aaa1 forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。 Sorted(排序)排序是一个 中间操作，返回的是排序好后的 Stream。如果你不指定一个自定义的 Comparator 则会使用默认排序。 // 测试 Sort (排序) stringList .stream() .sorted() .filter((s) -&gt; s.startsWith(&quot;a&quot;)) .forEach(System.out::println);// aaa1 aaa2 需要注意的是，排序只创建了一个排列好后的Stream，而不会影响原有的数据源，排序之后原数据stringCollection是不会被修改的： System.out.println(stringList);// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1 Map(映射)中间操作 map 会将元素根据指定的 Function 接口来依次将元素转成另外的对象。 下面的示例展示了将字符串转换为大写字符串。你也可以通过map来将对象转换成其他类型，map返回的Stream类型是根据你map传递进去的函数的返回值决定的。 // 测试 Map 操作 stringList .stream() .map(String::toUpperCase) .sorted((a, b) -&gt; b.compareTo(a)) .forEach(System.out::println);// &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;AAA2&quot;, &quot;AAA1&quot; Match(匹配)Stream提供了多种匹配操作，允许检测指定的Predicate是否匹配整个Stream。所有的匹配操作都是 最终操作 ，并返回一个 boolean 类型的值。 // 测试 Match (匹配)操作 boolean anyStartsWithA = stringList .stream() .anyMatch((s) -&gt; s.startsWith(&quot;a&quot;)); System.out.println(anyStartsWithA); // true boolean allStartsWithA = stringList .stream() .allMatch((s) -&gt; s.startsWith(&quot;a&quot;)); System.out.println(allStartsWithA); // false boolean noneStartsWithZ = stringList .stream() .noneMatch((s) -&gt; s.startsWith(&quot;z&quot;)); System.out.println(noneStartsWithZ); // true Count(计数)计数是一个 最终操作，返回Stream中元素的个数，返回值类型是 long。 //测试 Count (计数)操作 long startsWithB = stringList .stream() .filter((s) -&gt; s.startsWith(&quot;b&quot;)) .count(); System.out.println(startsWithB); // 3 Reduce(规约)这是一个 最终操作 ，允许通过指定的函数来讲stream中的多个元素规约为一个元素，规约后的结果是通过Optional 接口表示的： //测试 Reduce (规约)操作 Optional&lt;String&gt; reduced = stringList .stream() .sorted() .reduce((s1, s2) -&gt; s1 + &quot;#&quot; + s2); reduced.ifPresent(System.out::println);//aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2 译者注： 这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于Integer sum = integers.reduce(0, (a, b) -&gt; a+b);也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。 // 字符串连接，concat = &quot;ABCD&quot; String concat = Stream.of(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;).reduce(&quot;&quot;, String::concat); // 求最小值，minValue = -3.0 double minValue = Stream.of(-1.5, 1.0, -3.0, -2.0).reduce(Double.MAX_VALUE, Double::min); // 求和，sumValue = 10, 有起始值 int sumValue = Stream.of(1, 2, 3, 4).reduce(0, Integer::sum); // 求和，sumValue = 10, 无起始值 sumValue = Stream.of(1, 2, 3, 4).reduce(Integer::sum).get(); // 过滤，字符串连接，concat = &quot;ace&quot; concat = Stream.of(&quot;a&quot;, &quot;B&quot;, &quot;c&quot;, &quot;D&quot;, &quot;e&quot;, &quot;F&quot;). filter(x -&gt; x.compareTo(&quot;Z&quot;) &gt; 0). reduce(&quot;&quot;, String::concat); 上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。更多内容查看： IBM：Java 8 中的 Streams API 详解 Parallel Streams(并行流)前面提到过Stream有串行和并行两种，串行Stream上的操作是在一个线程中依次完成，而并行Stream则是在多个线程上同时执行。 下面的例子展示了是如何通过并行Stream来提升性能： 首先我们创建一个没有重复元素的大表： int max = 1000000; List&lt;String&gt; values = new ArrayList&lt;&gt;(max); for (int i = 0; i &lt; max; i++) { UUID uuid = UUID.randomUUID(); values.add(uuid.toString()); } 我们分别用串行和并行两种方式对其进行排序，最后看看所用时间的对比。 Sequential Sort(串行排序)//串行排序 long t0 = System.nanoTime(); long count = values.stream().sorted().count(); System.out.println(count); long t1 = System.nanoTime(); long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0); System.out.println(String.format(&quot;sequential sort took: %d ms&quot;, millis)); 1000000 sequential sort took: 709 ms//串行排序所用的时间 Parallel Sort(并行排序)//并行排序 long t0 = System.nanoTime(); long count = values.parallelStream().sorted().count(); System.out.println(count); long t1 = System.nanoTime(); long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0); System.out.println(String.format(&quot;parallel sort took: %d ms&quot;, millis)); 1000000 parallel sort took: 475 ms//串行排序所用的时间 上面两个代码几乎是一样的，但是并行版的快了 50% 左右，唯一需要做的改动就是将 stream() 改为parallelStream()。 Maps前面提到过，Map 类型不支持 streams，不过Map提供了一些新的有用的方法来处理一些日常任务。Map接口本身没有可用的 stream（）方法，但是你可以在键，值上创建专门的流或者通过 map.keySet().stream(),map.values().stream()和map.entrySet().stream()。 此外,Maps 支持各种新的和有用的方法来执行常见任务。 Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; 10; i++) { map.putIfAbsent(i, &quot;val&quot; + i); } map.forEach((id, val) -&gt; System.out.println(val));//val0 val1 val2 val3 val4 val5 val6 val7 val8 val9 putIfAbsent 阻止我们在null检查时写入额外的代码;forEach接受一个 consumer 来对 map 中的每个元素操作。 此示例显示如何使用函数在 map 上计算代码： map.computeIfPresent(3, (num, val) -&gt; val + num); map.get(3); // val33 map.computeIfPresent(9, (num, val) -&gt; null); map.containsKey(9); // false map.computeIfAbsent(23, num -&gt; &quot;val&quot; + num); map.containsKey(23); // true map.computeIfAbsent(3, num -&gt; &quot;bam&quot;); map.get(3); // val33 接下来展示如何在Map里删除一个键值全都匹配的项： map.remove(3, &quot;val3&quot;); map.get(3); // val33 map.remove(3, &quot;val33&quot;); map.get(3); // null 另外一个有用的方法： map.getOrDefault(42, &quot;not found&quot;); // not found 对Map的元素做合并也变得很容易了： map.merge(9, &quot;val9&quot;, (value, newValue) -&gt; value.concat(newValue)); map.get(9); // val9 map.merge(9, &quot;concat&quot;, (value, newValue) -&gt; value.concat(newValue)); map.get(9); // val9concat Merge 做的事情是如果键名不存在则插入，否则则对原键对应的值做合并操作并重新插入到map中。 Date API(日期相关API)Java 8在 java.time 包下包含一个全新的日期和时间API。新的Date API与Joda-Time库相似，但它们不一样。以下示例涵盖了此新 API 的最重要部分。译者对这部分内容参考相关书籍做了大部分修改。 译者注(总结)： Clock 类提供了访问当前日期和时间的方法，Clock 是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用 Instant 类来表示，Instant 类也可以用来创建旧版本的java.util.Date 对象。 在新API中时区使用 ZoneId 来表示。时区可以很方便的使用静态方法of来获取到。 抽象类ZoneId（在java.time包中）表示一个区域标识符。 它有一个名为getAvailableZoneIds的静态方法，它返回所有区域标识符。 jdk1.8中新增了 LocalDate 与 LocalDateTime等类来解决日期处理方法，同时引入了一个新的类DateTimeFormatter 来解决日期格式化问题。可以使用Instant代替 Date，LocalDateTime代替 Calendar，DateTimeFormatter 代替 SimpleDateFormat。 ClockClock 类提供了访问当前日期和时间的方法，Clock 是时区敏感的，可以用来取代 System.currentTimeMillis() 来获取当前的微秒数。某一个特定的时间点也可以使用 Instant 类来表示，Instant 类也可以用来创建旧版本的java.util.Date 对象。 Clock clock = Clock.systemDefaultZone(); long millis = clock.millis(); System.out.println(millis);//1552379579043 Instant instant = clock.instant(); System.out.println(instant); Date legacyDate = Date.from(instant); //2019-03-12T08:46:42.588Z System.out.println(legacyDate);//Tue Mar 12 16:32:59 CST 2019 Timezones(时区)在新API中时区使用 ZoneId 来表示。时区可以很方便的使用静态方法of来获取到。 抽象类ZoneId（在java.time包中）表示一个区域标识符。 它有一个名为getAvailableZoneIds的静态方法，它返回所有区域标识符。 //输出所有区域标识符 System.out.println(ZoneId.getAvailableZoneIds()); ZoneId zone1 = ZoneId.of(&quot;Europe/Berlin&quot;); ZoneId zone2 = ZoneId.of(&quot;Brazil/East&quot;); System.out.println(zone1.getRules());// ZoneRules[currentStandardOffset=+01:00] System.out.println(zone2.getRules());// ZoneRules[currentStandardOffset=-03:00] LocalTime(本地时间)LocalTime 定义了一个没有时区信息的时间，例如 晚上10点或者 17:30:15。下面的例子使用前面代码创建的时区创建了两个本地时间。之后比较时间并以小时和分钟为单位计算两个时间的时间差： LocalTime now1 = LocalTime.now(zone1); LocalTime now2 = LocalTime.now(zone2); System.out.println(now1.isBefore(now2)); // false long hoursBetween = ChronoUnit.HOURS.between(now1, now2); long minutesBetween = ChronoUnit.MINUTES.between(now1, now2); System.out.println(hoursBetween); // -3 System.out.println(minutesBetween); // -239 LocalTime 提供了多种工厂方法来简化对象的创建，包括解析时间字符串. LocalTime late = LocalTime.of(23, 59, 59); System.out.println(late); // 23:59:59 DateTimeFormatter germanFormatter = DateTimeFormatter .ofLocalizedTime(FormatStyle.SHORT) .withLocale(Locale.GERMAN); LocalTime leetTime = LocalTime.parse(&quot;13:37&quot;, germanFormatter); System.out.println(leetTime); // 13:37 LocalDate(本地日期)LocalDate 表示了一个确切的日期，比如 2014-03-11。该对象值是不可变的，用起来和LocalTime基本一致。下面的例子展示了如何给Date对象加减天/月/年。另外要注意的是这些对象是不可变的，操作返回的总是一个新实例。 LocalDate today = LocalDate.now();//获取现在的日期 System.out.println(&quot;今天的日期: &quot;+today);//2019-03-12 LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS); System.out.println(&quot;明天的日期: &quot;+tomorrow);//2019-03-13 LocalDate yesterday = tomorrow.minusDays(2); System.out.println(&quot;昨天的日期: &quot;+yesterday);//2019-03-11 LocalDate independenceDay = LocalDate.of(2019, Month.MARCH, 12); DayOfWeek dayOfWeek = independenceDay.getDayOfWeek(); System.out.println(&quot;今天是周几:&quot;+dayOfWeek);//TUESDAY 从字符串解析一个 LocalDate 类型和解析 LocalTime 一样简单,下面是使用 DateTimeFormatter 解析字符串的例子： String str1 = &quot;2014==04==12 01时06分09秒&quot;; // 根据需要解析的日期、时间字符串定义解析所用的格式器 DateTimeFormatter fomatter1 = DateTimeFormatter .ofPattern(&quot;yyyy==MM==dd HH时mm分ss秒&quot;); LocalDateTime dt1 = LocalDateTime.parse(str1, fomatter1); System.out.println(dt1); // 输出 2014-04-12T01:06:09 String str2 = &quot;2014$$$四月$$$13 20小时&quot;; DateTimeFormatter fomatter2 = DateTimeFormatter .ofPattern(&quot;yyy$$$MMM$$$dd HH小时&quot;); LocalDateTime dt2 = LocalDateTime.parse(str2, fomatter2); System.out.println(dt2); // 输出 2014-04-13T20:00 再来看一个使用 DateTimeFormatter 格式化日期的示例 LocalDateTime rightNow=LocalDateTime.now(); String date=DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(rightNow); System.out.println(date);//2019-03-12T16:26:48.29 DateTimeFormatter formatter=DateTimeFormatter.ofPattern(&quot;YYYY-MM-dd HH:mm:ss&quot;); System.out.println(formatter.format(rightNow));//2019-03-12 16:26:48 LocalDateTime(本地日期时间)LocalDateTime 同时表示了时间和日期，相当于前两节内容合并到一个对象上了。LocalDateTime 和 LocalTime还有 LocalDate 一样，都是不可变的。LocalDateTime 提供了一些能访问具体字段的方法。 LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59); DayOfWeek dayOfWeek = sylvester.getDayOfWeek(); System.out.println(dayOfWeek); // WEDNESDAY Month month = sylvester.getMonth(); System.out.println(month); // DECEMBER long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY); System.out.println(minuteOfDay); // 1439 只要附加上时区信息，就可以将其转换为一个时间点Instant对象，Instant时间点对象可以很容易的转换为老式的java.util.Date。 Instant instant = sylvester .atZone(ZoneId.systemDefault()) .toInstant(); Date legacyDate = Date.from(instant); System.out.println(legacyDate); // Wed Dec 31 23:59:59 CET 2014 格式化LocalDateTime和格式化时间和日期一样的，除了使用预定义好的格式外，我们也可以自己定义格式： DateTimeFormatter formatter = DateTimeFormatter .ofPattern(&quot;MMM dd, yyyy - HH:mm&quot;); LocalDateTime parsed = LocalDateTime.parse(&quot;Nov 03, 2014 - 07:13&quot;, formatter); String string = formatter.format(parsed); System.out.println(string); // Nov 03, 2014 - 07:13 和java.text.NumberFormat不一样的是新版的DateTimeFormatter是不可变的，所以它是线程安全的。关于时间日期格式的详细信息在这里。 Annotations(注解)在Java 8中支持多重注解了，先看个例子来理解一下是什么意思。首先定义一个包装类Hints注解用来放置一组具体的Hint注解： @interface Hints { Hint[] value(); } @Repeatable(Hints.class) @interface Hint { String value(); } Java 8允许我们把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。 例 1: 使用包装类当容器来存多个注解（老方法） @Hints({@Hint(&quot;hint1&quot;), @Hint(&quot;hint2&quot;)}) class Person {} 例 2：使用多重注解（新方法） @Hint(&quot;hint1&quot;) @Hint(&quot;hint2&quot;) class Person {} 第二个例子里java编译器会隐性的帮你定义好@Hints注解，了解这一点有助于你用反射来获取这些信息： Hint hint = Person.class.getAnnotation(Hint.class); System.out.println(hint); // null Hints hints1 = Person.class.getAnnotation(Hints.class); System.out.println(hints1.value().length); // 2 Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class); System.out.println(hints2.length); // 2 即便我们没有在 Person类上定义 @Hints注解，我们还是可以通过 getAnnotation(Hints.class)来获取 @Hints注解，更加方便的方法是使用 getAnnotationsByType 可以直接获取到所有的@Hint注解。另外Java 8的注解还增加到两种新的target上了： @Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE}) @interface MyAnnotation {} Where to go from here?关于Java 8的新特性就写到这了，肯定还有更多的特性等待发掘。JDK 1.8里还有很多很有用的东西，比如Arrays.parallelSort, StampedLock和CompletableFuture等等。]]></content>
      <categories>
        <category>Java</category>
        <category>新特性</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java新特性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三种加密方式 sha1加密、MD5加密、Base64加密 (附H5源码和js源码)]]></title>
    <url>%2F2020%2F09%2Fpython%2Fspider%2F20200929_%E4%B8%89%E7%A7%8D%E5%8A%A0%E5%AF%86%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[js的加密没特别多的办法，常见的就三种， MD5加密、Base64加密和sha1加密 一. sha1加密 H5源码： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;shal加密&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;script src=&quot;js/jquery.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/shal.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;password&quot; name=&quot;&quot; id=&quot;md5&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;hex_sha1加密&quot; οnclick=&quot;testshal(1)&quot; /&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;b64_sha1加密&quot; οnclick=&quot;testshal(2)&quot; /&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;str_sha1加密&quot; οnclick=&quot;testshal(3)&quot; /&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testshal(e){ var password = $(&quot;#md5&quot;).val(); console.log(&quot;没有加密之前的是：&quot;+password); if(e == 1){ var shalpassword = hex_sha1(password); console.log(&quot;hex_sha1方式加密后是：&quot;+shalpassword); } else if(e == 2){ var shalpassword = b64_sha1(password); console.log(&quot;b64_sha1方式加密后是：&quot;+shalpassword); } else if(e == 3){ var shalpassword = str_sha1(password); console.log(&quot;str_sha1方式加密后是：&quot;+shalpassword); } } &lt;/script&gt; &lt;/html&gt; js源码： var hexcase = 0; /* 十六进制输出格式。0 -小写；1 -大写 */ var b64pad = &quot;&quot;; /* base- 64填充字符。“=”表示严格的RFC合规性 */ var chrsz = 8; /* 每个输入字符的位数。8 - ASCII；16 -统一码 */ function hex_sha1(s) { return binb2hex(core_sha1(str2binb(s), s.length * chrsz)); } function b64_sha1(s) { return binb2b64(core_sha1(str2binb(s), s.length * chrsz)); } function str_sha1(s) { return binb2str(core_sha1(str2binb(s), s.length * chrsz)); } function hex_hmac_sha1(key, data) { return binb2hex(core_hmac_sha1(key, data)); } function b64_hmac_sha1(key, data) { return binb2b64(core_hmac_sha1(key, data)); } function str_hmac_sha1(key, data) { return binb2str(core_hmac_sha1(key, data)); } function sha1_vm_test() { return hex_sha1(&quot;abc&quot;) == &quot;a9993e364706816aba3e25717850c26c9cd0d89d&quot;; } function core_sha1(x, len) { x[len &gt;&gt; 5] |= 0x80 &lt;&lt; (24 - len % 32); x[((len + 64 &gt;&gt; 9) &lt;&lt; 4) + 15] = len; var w = Array(80); var a = 1732584193; var b = -271733879; var c = -1732584194; var d = 271733878; var e = -1009589776; for (var i = 0; i &lt; x.length; i += 16) { var olda = a; var oldb = b; var oldc = c; var oldd = d; var olde = e; for (var j = 0; j &lt; 80; j++) { if (j &lt; 16) w[j] = x[i + j]; else w[j] = rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1); var t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j))); e = d; d = c; c = rol(b, 30); b = a; a = t; } a = safe_add(a, olda); b = safe_add(b, oldb); c = safe_add(c, oldc); d = safe_add(d, oldd); e = safe_add(e, olde); } return Array(a, b, c, d, e); } function sha1_ft(t, b, c, d) { if (t &lt; 20) return (b &amp; c) | ((~b) &amp; d); if (t &lt; 40) return b ^ c ^ d; if (t &lt; 60) return (b &amp; c) | (b &amp; d) | (c &amp; d); return b ^ c ^ d; } function sha1_kt(t) { return (t &lt; 20) ? 1518500249 : (t &lt; 40) ? 1859775393 : (t &lt; 60) ? -1894007588 : -899497514; } function core_hmac_sha1(key, data) { var bkey = str2binb(key); if (bkey.length &gt; 16) bkey = core_sha1(bkey, key.length * chrsz); var ipad = Array(16), opad = Array(16); for (var i = 0; i &lt; 16; i++) { ipad[i] = bkey[i] ^ 0x36363636; opad[i] = bkey[i] ^ 0x5C5C5C5C; } var hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz); return core_sha1(opad.concat(hash), 512 + 160); } function safe_add(x, y) { var lsw = (x &amp; 0xFFFF) + (y &amp; 0xFFFF); var msw = (x &gt;&gt; 16) + (y &gt;&gt; 16) + (lsw &gt;&gt; 16); return (msw &lt;&lt; 16) | (lsw &amp; 0xFFFF); } function rol(num, cnt) { return (num &lt;&lt; cnt) | (num &gt;&gt;&gt; (32 - cnt)); } function str2binb(str) { var bin = Array(); var mask = (1 &lt;&lt; chrsz) - 1; for (var i = 0; i &lt; str.length * chrsz; i += chrsz) bin[i &gt;&gt; 5] |= (str.charCodeAt(i / chrsz) &amp; mask) &lt;&lt; (24 - i % 32); return bin; } function binb2str(bin) { var str = &quot;&quot;; var mask = (1 &lt;&lt; chrsz) - 1; for (var i = 0; i &lt; bin.length * 32; i += chrsz) str += String.fromCharCode((bin[i &gt;&gt; 5] &gt;&gt;&gt; (24 - i % 32)) &amp; mask); return str; } function binb2hex(binarray) { var hex_tab = hexcase ? &quot;0123456789ABCDEF&quot; : &quot;0123456789abcdef&quot;; var str = &quot;&quot;; for (var i = 0; i &lt; binarray.length * 4; i++) { str += hex_tab.charAt((binarray[i &gt;&gt; 2] &gt;&gt; ((3 - i % 4) * 8 + 4)) &amp; 0xF) + hex_tab.charAt((binarray[i &gt;&gt; 2] &gt;&gt; ((3 - i % 4) * 8)) &amp; 0xF); } return str; } function binb2b64(binarray) { var tab = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;; var str = &quot;&quot;; for (var i = 0; i &lt; binarray.length * 4; i += 3) { var triplet = (((binarray[i &gt;&gt; 2] &gt;&gt; 8 * (3 - i % 4)) &amp; 0xFF) &lt;&lt; 16) | (((binarray[i + 1 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i + 1) % 4)) &amp; 0xFF) &lt;&lt; 8) | ((binarray[i + 2 &gt;&gt; 2] &gt;&gt; 8 * (3 - (i + 2) % 4)) &amp; 0xFF); for (var j = 0; j &lt; 4; j++) { if (i * 8 + j * 6 &gt; binarray.length * 32) str += b64pad; else str += tab.charAt((triplet &gt;&gt; 6 * (3 - j)) &amp; 0x3F); } } return str; } 二. MD5加密 H5源码： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;md5加密&lt;/title&gt; &lt;script src=&quot;js/jquery.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/md5.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;password&quot; name=&quot;&quot; id=&quot;md5&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;MD5加密&quot; οnclick=&quot;testmd5()&quot; /&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; function testmd5(){ var password = $(&quot;#md5&quot;).val(); var md5password = $.md5(password); console.log(&quot;没有加密之前的是：&quot;+password); console.log(&quot;加密以后是：&quot;+md5password); } &lt;/script&gt; &lt;/html&gt; js源码 (function($){ var rotateLeft = function(lValue, iShiftBits) { return (lValue &lt;&lt; iShiftBits) | (lValue &gt;&gt;&gt; (32 - iShiftBits)); } var addUnsigned = function(lX, lY) { var lX4, lY4, lX8, lY8, lResult; lX8 = (lX &amp; 0x80000000); lY8 = (lY &amp; 0x80000000); lX4 = (lX &amp; 0x40000000); lY4 = (lY &amp; 0x40000000); lResult = (lX &amp; 0x3FFFFFFF) + (lY &amp; 0x3FFFFFFF); if (lX4 &amp; lY4) return (lResult ^ 0x80000000 ^ lX8 ^ lY8); if (lX4 | lY4) { if (lResult &amp; 0x40000000) return (lResult ^ 0xC0000000 ^ lX8 ^ lY8); else return (lResult ^ 0x40000000 ^ lX8 ^ lY8); } else { return (lResult ^ lX8 ^ lY8); } } var F = function(x, y, z) { return (x &amp; y) | ((~ x) &amp; z); } var G = function(x, y, z) { return (x &amp; z) | (y &amp; (~ z)); } var H = function(x, y, z) { return (x ^ y ^ z); } var I = function(x, y, z) { return (y ^ (x | (~ z))); } var FF = function(a, b, c, d, x, s, ac) { a = addUnsigned(a, addUnsigned(addUnsigned(F(b, c, d), x), ac)); return addUnsigned(rotateLeft(a, s), b); }; var GG = function(a, b, c, d, x, s, ac) { a = addUnsigned(a, addUnsigned(addUnsigned(G(b, c, d), x), ac)); return addUnsigned(rotateLeft(a, s), b); }; var HH = function(a, b, c, d, x, s, ac) { a = addUnsigned(a, addUnsigned(addUnsigned(H(b, c, d), x), ac)); return addUnsigned(rotateLeft(a, s), b); }; var II = function(a, b, c, d, x, s, ac) { a = addUnsigned(a, addUnsigned(addUnsigned(I(b, c, d), x), ac)); return addUnsigned(rotateLeft(a, s), b); }; var convertToWordArray = function(string) { var lWordCount; var lMessageLength = string.length; var lNumberOfWordsTempOne = lMessageLength + 8; var lNumberOfWordsTempTwo = (lNumberOfWordsTempOne - (lNumberOfWordsTempOne % 64)) / 64; var lNumberOfWords = (lNumberOfWordsTempTwo + 1) * 16; var lWordArray = Array(lNumberOfWords - 1); var lBytePosition = 0; var lByteCount = 0; while (lByteCount &lt; lMessageLength) { lWordCount = (lByteCount - (lByteCount % 4)) / 4; lBytePosition = (lByteCount % 4) * 8; lWordArray[lWordCount] = (lWordArray[lWordCount] | (string.charCodeAt(lByteCount) &lt;&lt; lBytePosition)); lByteCount++; } lWordCount = (lByteCount - (lByteCount % 4)) / 4; lBytePosition = (lByteCount % 4) * 8; lWordArray[lWordCount] = lWordArray[lWordCount] | (0x80 &lt;&lt; lBytePosition); lWordArray[lNumberOfWords - 2] = lMessageLength &lt;&lt; 3; lWordArray[lNumberOfWords - 1] = lMessageLength &gt;&gt;&gt; 29; return lWordArray; }; var wordToHex = function(lValue) { var WordToHexValue = &quot;&quot;, WordToHexValueTemp = &quot;&quot;, lByte, lCount; for (lCount = 0; lCount &lt;= 3; lCount++) { lByte = (lValue &gt;&gt;&gt; (lCount * 8)) &amp; 255; WordToHexValueTemp = &quot;0&quot; + lByte.toString(16); WordToHexValue = WordToHexValue + WordToHexValueTemp.substr(WordToHexValueTemp.length - 2, 2); } return WordToHexValue; }; var uTF8Encode = function(string) { string = string.replace(/\x0d\x0a/g, &quot;\x0a&quot;); var output = &quot;&quot;; for (var n = 0; n &lt; string.length; n++) { var c = string.charCodeAt(n); if (c &lt; 128) { output += String.fromCharCode(c); } else if ((c &gt; 127) &amp;&amp; (c &lt; 2048)) { output += String.fromCharCode((c &gt;&gt; 6) | 192); output += String.fromCharCode((c &amp; 63) | 128); } else { output += String.fromCharCode((c &gt;&gt; 12) | 224); output += String.fromCharCode(((c &gt;&gt; 6) &amp; 63) | 128); output += String.fromCharCode((c &amp; 63) | 128); } } return output; }; $.extend({ md5: function(string) { var x = Array(); var k, AA, BB, CC, DD, a, b, c, d; var S11=7, S12=12, S13=17, S14=22; var S21=5, S22=9 , S23=14, S24=20; var S31=4, S32=11, S33=16, S34=23; var S41=6, S42=10, S43=15, S44=21; string = uTF8Encode(string); x = convertToWordArray(string); a = 0x67452301; b = 0xEFCDAB89; c = 0x98BADCFE; d = 0x10325476; for (k = 0; k &lt; x.length; k += 16) { AA = a; BB = b; CC = c; DD = d; a = FF(a, b, c, d, x[k+0], S11, 0xD76AA478); d = FF(d, a, b, c, x[k+1], S12, 0xE8C7B756); c = FF(c, d, a, b, x[k+2], S13, 0x242070DB); b = FF(b, c, d, a, x[k+3], S14, 0xC1BDCEEE); a = FF(a, b, c, d, x[k+4], S11, 0xF57C0FAF); d = FF(d, a, b, c, x[k+5], S12, 0x4787C62A); c = FF(c, d, a, b, x[k+6], S13, 0xA8304613); b = FF(b, c, d, a, x[k+7], S14, 0xFD469501); a = FF(a, b, c, d, x[k+8], S11, 0x698098D8); d = FF(d, a, b, c, x[k+9], S12, 0x8B44F7AF); c = FF(c, d, a, b, x[k+10], S13, 0xFFFF5BB1); b = FF(b, c, d, a, x[k+11], S14, 0x895CD7BE); a = FF(a, b, c, d, x[k+12], S11, 0x6B901122); d = FF(d, a, b, c, x[k+13], S12, 0xFD987193); c = FF(c, d, a, b, x[k+14], S13, 0xA679438E); b = FF(b, c, d, a, x[k+15], S14, 0x49B40821); a = GG(a, b, c, d, x[k+1], S21, 0xF61E2562); d = GG(d, a, b, c, x[k+6], S22, 0xC040B340); c = GG(c, d, a, b, x[k+11], S23, 0x265E5A51); b = GG(b, c, d, a, x[k+0], S24, 0xE9B6C7AA); a = GG(a, b, c, d, x[k+5], S21, 0xD62F105D); d = GG(d, a, b, c, x[k+10], S22, 0x2441453); c = GG(c, d, a, b, x[k+15], S23, 0xD8A1E681); b = GG(b, c, d, a, x[k+4], S24, 0xE7D3FBC8); a = GG(a, b, c, d, x[k+9], S21, 0x21E1CDE6); d = GG(d, a, b, c, x[k+14], S22, 0xC33707D6); c = GG(c, d, a, b, x[k+3], S23, 0xF4D50D87); b = GG(b, c, d, a, x[k+8], S24, 0x455A14ED); a = GG(a, b, c, d, x[k+13], S21, 0xA9E3E905); d = GG(d, a, b, c, x[k+2], S22, 0xFCEFA3F8); c = GG(c, d, a, b, x[k+7], S23, 0x676F02D9); b = GG(b, c, d, a, x[k+12], S24, 0x8D2A4C8A); a = HH(a, b, c, d, x[k+5], S31, 0xFFFA3942); d = HH(d, a, b, c, x[k+8], S32, 0x8771F681); c = HH(c, d, a, b, x[k+11], S33, 0x6D9D6122); b = HH(b, c, d, a, x[k+14], S34, 0xFDE5380C); a = HH(a, b, c, d, x[k+1], S31, 0xA4BEEA44); d = HH(d, a, b, c, x[k+4], S32, 0x4BDECFA9); c = HH(c, d, a, b, x[k+7], S33, 0xF6BB4B60); b = HH(b, c, d, a, x[k+10], S34, 0xBEBFBC70); a = HH(a, b, c, d, x[k+13], S31, 0x289B7EC6); d = HH(d, a, b, c, x[k+0], S32, 0xEAA127FA); c = HH(c, d, a, b, x[k+3], S33, 0xD4EF3085); b = HH(b, c, d, a, x[k+6], S34, 0x4881D05); a = HH(a, b, c, d, x[k+9], S31, 0xD9D4D039); d = HH(d, a, b, c, x[k+12], S32, 0xE6DB99E5); c = HH(c, d, a, b, x[k+15], S33, 0x1FA27CF8); b = HH(b, c, d, a, x[k+2], S34, 0xC4AC5665); a = II(a, b, c, d, x[k+0], S41, 0xF4292244); d = II(d, a, b, c, x[k+7], S42, 0x432AFF97); c = II(c, d, a, b, x[k+14], S43, 0xAB9423A7); b = II(b, c, d, a, x[k+5], S44, 0xFC93A039); a = II(a, b, c, d, x[k+12], S41, 0x655B59C3); d = II(d, a, b, c, x[k+3], S42, 0x8F0CCC92); c = II(c, d, a, b, x[k+10], S43, 0xFFEFF47D); b = II(b, c, d, a, x[k+1], S44, 0x85845DD1); a = II(a, b, c, d, x[k+8], S41, 0x6FA87E4F); d = II(d, a, b, c, x[k+15], S42, 0xFE2CE6E0); c = II(c, d, a, b, x[k+6], S43, 0xA3014314); b = II(b, c, d, a, x[k+13], S44, 0x4E0811A1); a = II(a, b, c, d, x[k+4], S41, 0xF7537E82); d = II(d, a, b, c, x[k+11], S42, 0xBD3AF235); c = II(c, d, a, b, x[k+2], S43, 0x2AD7D2BB); b = II(b, c, d, a, x[k+9], S44, 0xEB86D391); a = addUnsigned(a, AA); b = addUnsigned(b, BB); c = addUnsigned(c, CC); d = addUnsigned(d, DD); } var tempValue = wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d); return tempValue.toLowerCase(); } }); })(jQuery); 三. Base64加密 H5源码 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;base64加密&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;script src=&quot;js/jquery.min.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;password&quot; name=&quot;&quot; id=&quot;basepass&quot; value=&quot;&quot; /&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;base加密&quot; οnclick=&quot;basefunc(1)&quot;/&gt; &lt;input type=&quot;button&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;base解密&quot; οnclick=&quot;basefunc(2)&quot;/&gt; &lt;/body&gt; &lt;script src=&quot;js/funcbase64.js&quot; type=&quot;text/javascript&quot; charset=&quot;utf-8&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; function basefunc(e){ var password = $(&quot;#basepass&quot;).val(); var base = new Base64(); var encypass = base.encode(password); var decryptpass = base.decode(encypass); if(e == 1){ console.log(&quot;加密之前的密码是：&quot;+password); console.log(&quot;加密之后的结果是：&quot;+encypass); } else if(e == 2){ console.log(&quot;解密之前的结果是：&quot;+encypass); console.log(&quot;解密之后的结果是：&quot;+decryptpass); } } &lt;/script&gt; &lt;/html&gt; js源码 function Base64() { // private property _keyStr = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;; // public method for encoding this.encode = function (input) { var output = &quot;&quot;; var chr1, chr2, chr3, enc1, enc2, enc3, enc4; var i = 0; input = _utf8_encode(input); while (i &lt; input.length) { chr1 = input.charCodeAt(i++); chr2 = input.charCodeAt(i++); chr3 = input.charCodeAt(i++); enc1 = chr1 &gt;&gt; 2; enc2 = ((chr1 &amp; 3) &lt;&lt; 4) | (chr2 &gt;&gt; 4); enc3 = ((chr2 &amp; 15) &lt;&lt; 2) | (chr3 &gt;&gt; 6); enc4 = chr3 &amp; 63; if (isNaN(chr2)) { enc3 = enc4 = 64; } else if (isNaN(chr3)) { enc4 = 64; } output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4); } return output; } // public method for decoding this.decode = function (input) { var output = &quot;&quot;; var chr1, chr2, chr3; var enc1, enc2, enc3, enc4; var i = 0; input = input.replace(/[^A-Za-z0-9\+\/\=]/g, &quot;&quot;); while (i &lt; input.length) { enc1 = _keyStr.indexOf(input.charAt(i++)); enc2 = _keyStr.indexOf(input.charAt(i++)); enc3 = _keyStr.indexOf(input.charAt(i++)); enc4 = _keyStr.indexOf(input.charAt(i++)); chr1 = (enc1 &lt;&lt; 2) | (enc2 &gt;&gt; 4); chr2 = ((enc2 &amp; 15) &lt;&lt; 4) | (enc3 &gt;&gt; 2); chr3 = ((enc3 &amp; 3) &lt;&lt; 6) | enc4; output = output + String.fromCharCode(chr1); if (enc3 != 64) { output = output + String.fromCharCode(chr2); } if (enc4 != 64) { output = output + String.fromCharCode(chr3); } } output = _utf8_decode(output); return output; } // private method for UTF-8 encoding _utf8_encode = function (string) { string = string.replace(/\r\n/g,&quot;\n&quot;); var utftext = &quot;&quot;; for (var n = 0; n &lt; string.length; n++) { var c = string.charCodeAt(n); if (c &lt; 128) { utftext += String.fromCharCode(c); } else if((c &gt; 127) &amp;&amp; (c &lt; 2048)) { utftext += String.fromCharCode((c &gt;&gt; 6) | 192); utftext += String.fromCharCode((c &amp; 63) | 128); } else { utftext += String.fromCharCode((c &gt;&gt; 12) | 224); utftext += String.fromCharCode(((c &gt;&gt; 6) &amp; 63) | 128); utftext += String.fromCharCode((c &amp; 63) | 128); } } return utftext; } // private method for UTF-8 decoding _utf8_decode = function (utftext) { var string = &quot;&quot;; var i = 0; var c = c1 = c2 = 0; while ( i &lt; utftext.length ) { c = utftext.charCodeAt(i); if (c &lt; 128) { string += String.fromCharCode(c); i++; } else if((c &gt; 191) &amp;&amp; (c &lt; 224)) { c2 = utftext.charCodeAt(i+1); string += String.fromCharCode(((c &amp; 31) &lt;&lt; 6) | (c2 &amp; 63)); i += 2; } else { c2 = utftext.charCodeAt(i+1); c3 = utftext.charCodeAt(i+2); string += String.fromCharCode(((c &amp; 15) &lt;&lt; 12) | ((c2 &amp; 63) &lt;&lt; 6) | (c3 &amp; 63)); i += 3; } } return string; } }]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>反爬</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy源码12 - ajaxcrawl]]></title>
    <url>%2F2020%2F07%2Fpython%2Fspider%2Fscrapy%2F20200715_%20ajaxcrawl%2F</url>
    <content type="text"><![CDATA[ajaxcrawl # -*- coding: utf-8 -*- from __future__ import absolute_import import re import logging import six from w3lib import html from scrapy.exceptions import NotConfigured from scrapy.http import HtmlResponse logger = logging.getLogger(__name__) ` 这些也是导入几个包， 主要看下第一个absolute_import 关于这句from __future__ import absolute_import的作用: 直观地看就是说”加入绝对引入这个新特性”。说到绝对引入，当然就会想到相对引入。那么什么是相对引入呢?比如说，你的包结构是这样的: pkg/ pkg/init.py pkg/main.py pkg/string.py 如果你在main.py中写import string,那么在Python 2.4或之前, Python会先查找当前目录下有没有string.py, 若找到了，则引入该模块，然后你在main.py中可以直接用string了。如果你是真的想用同目录下的string.py那就好，但是如果你是想用系统自带的标准string.py呢？那其实没有什么好的简洁的方式可以忽略掉同目录的string.py而引入系统自带的标准string.py。这时候你就需要from __future__ import absolute_import了。这样，你就可以用import string来引入系统的标准string.py, 而用from pkg import string来引入当前目录下的string.py了 构造函数 def __init__(self, settings): if not settings.getbool(&#39;AJAXCRAWL_ENABLED&#39;): raise NotConfigured # XXX: Google parses at least first 100k bytes; scrapy&#39;s redirect # middleware parses first 4k. 4k turns out to be insufficient # for this middleware, and parsing 100k could be slow. # We use something in between (32K) by default. self.lookup_bytes = settings.getint(&#39;AJAXCRAWL_MAXSIZE&#39;, 32768) 我们可以看出， 先从设置中获取AJAXCTRAWL_ENABLED是否启用， 如果没有设置，就抛出一个没有配置的异常设置获取AJAXCRAWL_MAXSIZE ,提供默认值32768 from_crawler方法 @classmethod def from_crawler(cls, crawler): return cls(crawler.settings) 这个方法，就是根据一个crawler抓取者去构造一个ajaxcrawl中间件 process_response方法 def process_response(self, request, response, spider): if not isinstance(response, HtmlResponse) or response.status != 200: return response if request.method != &#39;GET&#39;: # other HTTP methods are either not safe or don&#39;t have a body return response if &#39;ajax_crawlable&#39; in request.meta: # prevent loops return response if not self._has_ajax_crawlable_variant(response): return response # scrapy already handles #! links properly ajax_crawl_request = request.replace(url=request.url+&#39;#!&#39;) logger.debug(&quot;Downloading AJAX crawlable %(ajax_crawl_request)s instead of %(request)s&quot;, {&#39;ajax_crawl_request&#39;: ajax_crawl_request, &#39;request&#39;: request}, extra={&#39;spider&#39;: spider}) ajax_crawl_request.meta[&#39;ajax_crawlable&#39;] = True return ajax_crawl_request 这段代码先判断response不HtmlResponse响应流或者状态码不是200就直接返回响应流，如果请求方法不是get也直接返回，如果在request.meta中有ajax_crawlable就直接返回，如果响应流中没有ajax可抓取的变量也是直接返回，构造请求，请求的url为原来的url+“#!” _has_ajax_crawlable_variant def _has_ajax_crawlable_variant(self, response): &quot;&quot;&quot; Return True if a page without hash fragment could be &quot;AJAX crawlable&quot; according to https://developers.google.com/webmasters/ajax-crawling/docs/getting-started. &quot;&quot;&quot; body = response.text[:self.lookup_bytes] return _has_ajaxcrawlable_meta(body) 这个方法就是判断下系那个应留是否有ajax可以提取的信息 变量定义_ajax_crawlable_re = re.compile(six.u(r&#39;&lt;meta\s+name=[&quot;\&#39;]fragment[&quot;\&#39;]\s+content=[&quot;\&#39;]![&quot;\&#39;]/?&gt;&#39;)) _has_ajaxcrawlable_metadef _has_ajaxcrawlable_meta(text): &quot;&quot;&quot; &gt;&gt;&gt; _has_ajaxcrawlable_meta(&#39;&lt;html&gt;&lt;head&gt;&lt;meta name=&quot;fragment&quot; content=&quot;!&quot;/&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&#39;) True &gt;&gt;&gt; _has_ajaxcrawlable_meta(&quot;&lt;html&gt;&lt;head&gt;&lt;meta name=&#39;fragment&#39; content=&#39;!&#39;&gt;&lt;/head&gt;&lt;/html&gt;&quot;) True &gt;&gt;&gt; _has_ajaxcrawlable_meta(&#39;&lt;html&gt;&lt;head&gt;&lt;!--&lt;meta name=&quot;fragment&quot; content=&quot;!&quot;/&gt;--&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&#39;) False &gt;&gt;&gt; _has_ajaxcrawlable_meta(&#39;&lt;html&gt;&lt;/html&gt;&#39;) False &quot;&quot;&quot; # Stripping scripts and comments is slow (about 20x slower than # just checking if a string is in text); this is a quick fail-fast # path that should work for most pages. if &#39;fragment&#39; not in text: return False if &#39;content&#39; not in text: return False text = html.remove_tags_with_content(text, (&#39;script&#39;, &#39;noscript&#39;)) text = html.replace_entities(text) text = html.remove_comments(text) return _ajax_crawlable_re.search(text) is not None 找到页面上名字为frgment，并且有content，然后调用3个方法去处理text,然后使用正则表达式去匹配他。 remove_tags_with_content:这个方法就是从一个html文本中去除指定的标签及其内容 replace_entities: 转化指定的html内容为unicode charactor remove_comments: 提取注释以外的内容。]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>scrapy</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL用户管理与PostgreSQL用户管理的对比]]></title>
    <url>%2F2020%2F07%2Fdatabase%2Fmysql%2F20200713_mysql%E4%B8%8Epg%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%E5%AF%B9%E6%AF%94%2F</url>
    <content type="text"><![CDATA[原表为： 执行sql语句： 一. MySQL用户管理【例1.1】使用root用户登录到本地mysql服务器的test库中 mysql -uroot -p -hlocalhost test 【例1.2】使用root用户登录到本地mysql服务器的test库中，执行一条查询语句 mysql -uroot -p -hlocalhost test -e &quot;DESC person;&quot; 【例1.3】使用CREATE USER创建一个用户，用户名是jeffrey，密码是mypass，主机名是localhost CREATE USER &#39;jeffrey&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;mypass&#39;; 【例1.4】使用GRANT语句创建一个新的用户testUser，密码为testpwd。用户 testUser对所有的数据有查询和更新权限，并授于对所有数据表的SELECT和UPDATE权限 GRANT SELECT,UPDATE ON *.* TO &#39;testUser&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;testpwd&#39;; /*创建账户并授予权限*/ SELECT Host,User,Select_priv,Update_priv, FROM mysql.user where user=&#39;testUser&#39;; /*查看账户权限信息*/ 【例1.5】使用INSERT创建一个新账户，其用户名称为customer1，主机名称为localhost，密码为customer1： INSERT INTO user (Host,User,Password) VALUES(&#39;localhost&#39;,&#39;customer1&#39;,PASSWORD(&#39;customer1&#39;)); 【例1.6】使用DROP USER删除用户‘jeffrey‘@’localhost’ DROP USER &#39;jeffrey&#39;@&#39;localhost&#39;; 【例1.7】使用DELETE删除用户‘customer1‘@’localhost’ DELETE FROM mysql.user WHERE host=&#39;localhost&#39; and user=&#39;customer1&#39;; 【例1.8】使用mysqladmin将root用户的密码修改为“rootpwd” mysqladmin -u root -p password &quot;123456&quot; 【例1.9】使用UPDATE语句将root用户的密码修改为“rootpwd2”： UPDATE mysql.user set Password=password(&quot;rootpwd2&quot;) WHERE User=&quot;root&quot; and Host=&quot;localhost&quot;; 【例1.10】使用SET语句将root用户的密码修改为“rootpwd3”： SET PASSWORD=password(&quot;rootpwd3&quot;); 【例1.11】使用SET语句将testUser用户的密码修改为“newpwd”： SET PASSWORD FOR &#39;testUser&#39;@&#39;localhost&#39;=password(&quot;newpwd&quot;); 【例1.12】使用UPDATE语句将testUser用户的密码修改为“newpwd2”： UPDATE mysql.user set Password=PASSWORD(&quot;newpwd2&quot;) WHERE User=&quot;testUser&quot; and Host=&quot;localhost&quot;; 【例1.13】使用GRANT语句将testUser用户的密码修改为“newpwd3”：sql 【例1.14】testUser用户使用SET语句将自身的密码修改为“newpwd4”： SET PASSWORD = PASSWORD(&quot;newpwd4&quot;); 【例1.15】使用GRANT语句创建一个新的用户grantUser，密码为“grantpwd”。用户grantUser对所有的数据有查询、插入权限，并授于GRANT权限。GRANT语句及其执行结果如下： MySQL&gt; GRANT SELECT,INSERT ON *.* TO &#39;grantUser&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;grantpwd&#39; WITH GRANT OPTION; Query OK, 0 rows affected (0.03 sec) 结果显示执行成功，使用SELECT语句查询用户testUser2的权限： MySQL&gt; SELECT Host,User,Select_priv,Insert_priv, Grant_priv FROM mysql.user where user=&#39;grantUser&#39;; +-----------+------------+-------------+--------------+-------------+ | Host | User | Select_priv | Insert_priv | Grant_priv | +-----------+------------+-------------+--------------+--------------+ | localhost | testUser2 | Y | Y | Y | +-----------+------------+-------------+--------------+--------------+ 1 row in set (0.00 sec) 【例1.16】使用REVOKE语句取消用户testUser的更新权限。REVOKE语句及其执行结果如下： MySQL&gt; REVOKE UPDATE ON *.* FROM &#39;testUser&#39;@&#39;localhost&#39;; Query OK, 0 rows affected (0.00 sec) 执行结果显示执行成功，使用SELECT语句查询用户test的权限： MySQL&gt; SELECT Host,User,Select_priv,Update_priv,Grant_priv FROM MySQL.user where user=&#39;testUser&#39;; 【例1.17】使用SHOW GRANTS语句查询用户testUser的权限信息。SHOW GRANTS语句及其执行结果如下： MySQL&gt; SHOW GRANTS FOR &#39;testUser&#39;@&#39;localhost&#39;; 案例操作过程 打开MySQL客户端工具，输入登录命令，登录MySQL。C:\&gt;mysql -u root -p Enter password: ** 输入正确密码，按回车，出现欢迎信息表示登录成功。选择mysql数据库为当前数据库。MySQL&gt; use mysql; Database changed 出现Database changed信息表明切换数据库成功。创建新账户，用户名称为newAdmin，密码为pw1，允许其从本地主机访问MySQL。使用GRANT语句创建新账户，创建过程如下：`MySQL&gt; GRANT SELECT, UPDATE(id, name, age) -&gt; ON test_db.person_old -&gt; TO ‘newAdmin‘@’localhost’ IDENTIFIED BY ‘pw1’ -&gt; WITH MAX_CONNECTIONS_PER_HOUR 30; SELECT host, user, select_priv, update_priv FROM user WHERE user=’newAdmin’; SELECT host, db, user, table_name, table_priv, column_privFROM tables_priv WHERE user=’newAdmin’; SELECT host, db, user, table_name, column_name, column_privFROM columns_priv WHERE user=’newAdmin’; 3条SQL语句的查询结果分别如下： MySQL&gt; SELECT host, user, select_priv, update_priv FROM user WHERE user=’newAdmin’; MySQL&gt; SELECT host, db, user, table_name, table_priv, column_priv -&gt; FROM tables_priv WHERE user=’newAdmin’; MySQL&gt; SELECT host, db, user, table_name, column_name, column_priv -&gt; FROM columns_priv WHERE user=’newAdmin’; 使用SHOW GRANTS语句查看newAdmin的权限信息。 查看newAdmin账户的权限信息，输入语句如下： SHOW GRANTS FOR ‘newAdmin‘@’localhost’; 使用newAdmin用户登录MySQL。 退出当前登录，使用EXIT命令，语句如下： MySQL&gt; exitBye 使用newAdmin账户登录MySQL，语句如下： C:>MySQL -u newAdmin -pEnter password: *** 输入密码正确后，出现“mysql&gt;”提示符，登录成功。 使用newAdmin用户查看test_db数据库中person_dd表中的数据。 newAdmin用户被授予test数据库中person表中3个字段上的查询权限，因此可以执行SELECT语句查看这几个字段的值，执行过程如下： MySQL&gt; SELECT * FROM test_db.person_dd LIMIT 5; 使用newAdmin用户向person_dd表中插入一条新记录，查看语句执行结果。 插入新记录，输入语句如下： ```sql INSERT INTO test_db.person_old(name, age,info) VALUES(&#39;gaga&#39;, 30); 执行结果如下： ERROR 1142 (42000): INSERT command denied to user &#39;newAdmin&#39;@&#39;localhost&#39; for table &#39;person&#39; 可以看到，语句不能执行，错误信息表明newAdmin用户不能对person表进行插入操作。因此，用户不可以执行没有被授权的操作语句。 退出当前登录，使用root用户重新登录，收回newAdmin账户的权限。输入退出命令：exit重新以root用户登录MySQL，并选择mysql数据库为当前数据库。输入语句收回newAdmin账户的权限，执行过程如下： REVOKE SELECT, UPDATE ON test.person FROM &#39;newAdmin&#39;@&#39;localhost&#39;; 执行结果如下： MySQL&gt; REVOKE SELECT, UPDATE ON test.person FROM &#39;newAdmin&#39;@&#39;localhost&#39;; Query OK, 0 rows affected (0.00 sec) 删除newAdmin的账户信息。删除指定账户，可以使用DROP USER语句，输入如下： DROP USER &#39;newAdmin&#39;@&#39;localhost&#39;; 二. PostgreSQL用户管理组角色管理【例2.1】创建一个名称为post2的角色，SQL代码如下： CREATE ROLE post2; 【例2.2】查看系统中的角色，SQL代码如下： SELECT rolname FROM pg_roles; 【例2.3】修改角色post1的名称为post3。SQL语句如下： ALTER ROLE post1 RENAME TO post3; 【例2.4】删除角色post3。SQL语句如下： DROP ROLE post3; 角色的各种权限1、登录 【例2.5】创建角色post4，此角色具有登录权限。SQL语句如下： CREATE ROLE post4 LOGIN; 2超级用户 【例2.6】创建角色post5，此角色具有超级用户权限。SQL语句如下： CREATE ROLE post5 SUPERUSER; 3、创建数据库 【例2.7】创建角色post6，此角色具有创建数据库权限。SQL语句如下： CREATE ROLE post6 CREATEDB; 4、 创建角色角色要想创建角色，必须明确给出该权限（除了超级用户以外）。一旦角色具有CREATEROLE权限，即可更改和删除其他角色，还可以给其它角色赋予或者撤销成员关系。当然，如果想对超级用户进行操作，仅有此权限还不够，必须拥有SUPERUSER权限。创建具有创建角色权限的角色，SQL语法如下： CREATE ROLE name CREATEROLE; 【例2.8】创建角色post7，此角色具有创建数据库权限。SQL语句如下： CREATE ROLE post7 CREATEROLE; 5、口令在客户认证方法要求与数据库建立连接时，需要口令权限。常见的认证方法包括password、md5和crypt。创建具有口令权限的角色，SQL语法如下：CREATE ROLE name 口令认证方法 具体口令【例2.9】创建角色post8，此角色具有口令权限。SQL语句如下： CREATE ROLE post8 PASSWORD &#39;123456&#39;; 账户管理1、创建用户 【例2.10】创建用户名称为postgre02，并具有创建数据库和创建角色的权限，同时登陆密码为“123456789”。SQL语句如下： CREATE USER postgre02 PASSWORD &#39;123456789&#39; CREATEDB CREATEROLE ; 2、删除用户 【例2.11】使用DROP USER删除账户“postgre02”，SQL语句如下： DROP USER postgre02; 3、修改用户密码 【例2.12】将账户“postgre01”的密码修改为“123123”，SQL语句如下： ALTER USER postgre01 PASSWORD &#39;123123&#39;; 组角色和用户角色管理1、对组角色授权 【例2.13】给“post1”角色添加创建数据表和创建角色的权限，SQL语句如下： ALTER ROLE post1 CREATEDB CREATEROLE; 2、对用户授权 【例2.14】给“postgre01”用户添加创建数据表和创建角色的权限，SQL语句如下： ALTER USER postgre01 CREATEDB CREATEROLE; 3、收回组角色权限 【例2.15】将“post1”角色的创建数据表和创建角色权限收回，SQL语句如下： ALTER ROLE post1 NOCREATEDB NOCREATEROLE; 4、收回用户权限 【例2.16】将“postgre01”用户的创建数据表和创建角色权限收回，SQL语句如下： ALTER USER postgre01 NOCREATEDB NOCREATEROLE; 数据库权限管理1、修改数据库的拥有者 【例2.17】将“mytest”数据库的所有者修改为post1。SQL语句如下： ALTER DATABASE mytest OWNER TO post2; 2、增加用户的数据表权限 【例2.18】其中ppo1是一个现有的数据表，postgres是一个现有的用户，允许postgres更新ppo1数据表，用下面的命令更新表的权限： GRANT UPDATE ON ppo1 TO postgres; 如果将上面的语句修改为： GRANT UPDATE ON ppo1 TO PUBLIC; 则表示将数据表ppo1的更新权限赋予系统中的所有角色。如果将上面的语句修改为： GRANT ALL ON ppo1 TO postgres; 则表示把适用于该对象的所有权限都赋予用户postgres。]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>PostgreSQL</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy源码11 - webclient]]></title>
    <url>%2F2020%2F07%2Fpython%2Fspider%2Fscrapy%2F20200713_%20webclient%2F</url>
    <content type="text"><![CDATA[webclient.py 这个文件从名字上看出来应该是定义一个web 客户端的类。 from time import time 导入时间 from six.moves.urllib.parse import urlparse, urlunparse, urldefrag 导入urlparse,urlunparse,urldefrag from twisted.web.client import HTTPClientFactory 导入HTTPClientFactory from twisted.web.http import HTTPClient 导入HTTPClient from twisted.internet import defer 导入defer from scrapy.http import Headers 导入herader from scrapy.utils.httpobj import urlparse_cached 导入urlparse_cached from scrapy.utils.python import to_bytes 导入to_bytes方法 from scrapy.responsetypes import responsetypes 导入responsetypes方法。 def to_bytes(text, encoding=None, errors=&#39;strict&#39;): &quot;&quot;&quot;Return the binary representation of `text`. If `text` is already a bytes object, return it as-is.&quot;&quot;&quot; if isinstance(text, bytes): return text if not isinstance(text, six.string_types): raise TypeError(&#39;to_bytes must receive a unicode, str or bytes &#39; &#39;object, got %s&#39; % type(text).__name__) if encoding is None: encoding = &#39;utf-8&#39; return text.encode(encoding, errors) 这个方法就是转字节的方法， 如果就是bytes就直接返回， 如果是不是unicode,str,就抛出异常， 设置下默认的encoding, 转化为bytes,这个方法所在的文件里面还有to——unicode unicode_to_str的方法等等。 def _parsed_url_args(parsed): # Assume parsed is urlparse-d from Request.url, # which was passed via safe_url_string and is ascii-only. b = lambda s: to_bytes(s, encoding=&#39;ascii&#39;) path = urlunparse((&#39;&#39;, &#39;&#39;, parsed.path or &#39;/&#39;, parsed.params, parsed.query, &#39;&#39;)) path = b(path) host = b(parsed.hostname) port = parsed.port scheme = b(parsed.scheme) netloc = b(parsed.netloc) if port is None: port = 443 if scheme == b&#39;https&#39; else 80 return scheme, netloc, host, port, path 这个方法从名字上看是解析url参数的。 设置b变量为一个匿名的方法， 使用urlunparse获取路径 将路径to_bytes, host 也to_bytes,port不用， scheme,netloc bytes话， 如果端口没有指定的话， 如果scheme是https就设置443， 其他情况下是80端口。 def _parse(url): &quot;&quot;&quot; Return tuple of (scheme, netloc, host, port, path), all in bytes except for port which is int. Assume url is from Request.url, which was passed via safe_url_string and is ascii-only. &quot;&quot;&quot; url = url.strip() parsed = urlparse(url) return _parsed_url_args(parsed) 这里返回一个元组(scheme, netloc, host, port, path)， 除了端口号是int之外，其他的都是bytes. 这个url 只能是Request.url传递过来 。 url调用strip去除空格。使用urlparse获取一个parsed对象。 class ScrapyHTTPPageGetter(HTTPClient): 这个类继承了HTTPClient. def connectionMade(self): self.headers = Headers() # bucket for response headers # Method command self.sendCommand(self.factory.method, self.factory.path) # Headers for key, values in self.factory.headers.items(): for value in values: self.sendHeader(key, value) self.endHeaders() # Body if self.factory.body is not None: self.transport.write(self.factory.body) 连接模式方法， 定义一个headers对象， 方法命令 设置头信息。传输body信息。 def lineReceived(self, line): return HTTPClient.lineReceived(self, line.rstrip()) 行接受 def handleHeader(self, key, value): self.headers.appendlist(key, value) 处理头信息 def handleStatus(self, version, status, message): self.factory.gotStatus(version, status, message) 获取状态信息 def handleEndHeaders(self): self.factory.gotHeaders(self.headers) 获取头 def connectionLost(self, reason): self._connection_lost_reason = reason HTTPClient.connectionLost(self, reason) self.factory.noPage(reason) 这个方法不知道是干嘛的 def handleResponse(self, response): if self.factory.method.upper() == b&#39;HEAD&#39;: self.factory.page(b&#39;&#39;) elif self.length is not None and self.length &gt; 0: self.factory.noPage(self._connection_lost_reason) else: self.factory.page(response) self.transport.loseConnection() 处理响应，具体代码不知道做什么 def timeout(self): self.transport.loseConnection() # transport cleanup needed for HTTPS connections if self.factory.url.startswith(b&#39;https&#39;): self.transport.stopProducing() self.factory.noPage(\ defer.TimeoutError(&quot;Getting %s took longer than %s seconds.&quot; % \ (self.factory.url, self.factory.timeout))) 这个方法不知道干嘛的。 class ScrapyHTTPClientFactory(HTTPClientFactory): scrapy实现了HTTPClientFactory，冰鞋部分方法，确保url object 缓存结果。 def __init__(self, request, timeout=180): self._url = urldefrag(request.url)[0] # converting to bytes to comply to Twisted interface self.url = to_bytes(self._url, encoding=&#39;ascii&#39;) self.method = to_bytes(request.method, encoding=&#39;ascii&#39;) self.body = request.body or None self.headers = Headers(request.headers) self.response_headers = None self.timeout = request.meta.get(&#39;download_timeout&#39;) or timeout self.start_time = time() self.deferred = defer.Deferred().addCallback(self._build_response, request) # Fixes Twisted 11.1.0+ support as HTTPClientFactory is expected # to have _disconnectedDeferred. See Twisted r32329. # As Scrapy implements it&#39;s own logic to handle redirects is not # needed to add the callback _waitForDisconnect. # Specifically this avoids the AttributeError exception when # clientConnectionFailed method is called. self._disconnectedDeferred = defer.Deferred() self._set_connection_attributes(request) # set Host header based on url self.headers.setdefault(&#39;Host&#39;, self.netloc) # set Content-Length based len of body if self.body is not None: self.headers[&#39;Content-Length&#39;] = len(self.body) # just in case a broken http/1.1 decides to keep connection alive self.headers.setdefault(&quot;Connection&quot;, &quot;close&quot;) # Content-Length must be specified in POST method even with no body elif self.method == b&#39;POST&#39;: self.headers[&#39;Content-Length&#39;] = 0 定义初始化， 设置url,method,body ,headers , timeout,start_time, defered对象。 如果body 不为空， 获取长度设置headers,如果方法为post，则content_length设置为0 def _build_response(self, body, request): request.meta[&#39;download_latency&#39;] = self.headers_time-self.start_time status = int(self.status) headers = Headers(self.response_headers) respcls = responsetypes.from_args(headers=headers, url=self._url) return respcls(url=self._url, status=status, headers=headers, body=body) 构建响应， 设置meta属性， 状态码为 头信息为响应头 respcls 这个不知道到是啥。 def _set_connection_attributes(self, request): parsed = urlparse_cached(request) self.scheme, self.netloc, self.host, self.port, self.path = _parsed_url_args(parsed) proxy = request.meta.get(&#39;proxy&#39;) if proxy: self.scheme, _, self.host, self.port, _ = _parse(proxy) self.path = self.url 设置连接属性， 获取parsed， 获取请求参数， 获取请求的协议，修改部分属性的设置。 def gotHeaders(self, headers): self.headers_time = time() self.response_headers = headers 这个获取头信息的。]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>scrapy</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy源码10 - tls]]></title>
    <url>%2F2020%2F07%2Fpython%2Fspider%2Fscrapy%2F20200712_tls%2F</url>
    <content type="text"><![CDATA[tls.py 这个文件看起来挺简单的。 import logging from OpenSSL import SSL from scrapy import twisted_version logger = logging.getLogger(__name__) 这里就是导入logging，ssl，twisted_version 包。 全局日志logger METHOD_SSLv3 = &#39;SSLv3&#39; METHOD_TLS = &#39;TLS&#39; METHOD_TLSv10 = &#39;TLSv1.0&#39; METHOD_TLSv11 = &#39;TLSv1.1&#39; METHOD_TLSv12 = &#39;TLSv1.2&#39; openssl_methods = { METHOD_TLS: SSL.SSLv23_METHOD, # protocol negotiation (recommended) METHOD_SSLv3: SSL.SSLv3_METHOD, # SSL 3 (NOT recommended) METHOD_TLSv10: SSL.TLSv1_METHOD, # TLS 1.0 only METHOD_TLSv11: getattr(SSL, &#39;TLSv1_1_METHOD&#39;, 5), # TLS 1.1 only METHOD_TLSv12: getattr(SSL, &#39;TLSv1_2_METHOD&#39;, 6), # TLS 1.2 only } 这段是ssl的设置。 里面的openssl_methods的一个字典。 对应的字符串对应的ssl版本 如果twisted_version 版本大于14.0.0的话。 try: # XXX: this try-except is not needed in Twisted 17.0.0+ because # it requires pyOpenSSL 0.16+. from OpenSSL.SSL import SSL_CB_HANDSHAKE_DONE, SSL_CB_HANDSHAKE_START except ImportError: SSL_CB_HANDSHAKE_START = 0x10 SSL_CB_HANDSHAKE_DONE = 0x20 从ssl里面导入两个变量设置。 from twisted.internet.ssl import AcceptableCiphers from twisted.internet._sslverify import (ClientTLSOptions, verifyHostname, VerificationError) 从twisted.internet ssl 导入对应的几个包 if twisted_version &lt; (17, 0, 0): from twisted.internet._sslverify import _maybeSetHostNameIndication set_tlsext_host_name = _maybeSetHostNameIndication else: def set_tlsext_host_name(connection, hostNameBytes): connection.set_tlsext_host_name(hostNameBytes) 如果版本小于17.0.0 的话， 和大于17.0分别处理 class ScrapyClientTLSOptions(ClientTLSOptions): &quot;&quot;&quot; SSL Client connection creator ignoring certificate verification errors (for genuinely invalid certificates or bugs in verification code). Same as Twisted&#39;s private _sslverify.ClientTLSOptions, except that VerificationError and ValueError exceptions are caught, so that the connection is not closed, only logging warnings. &quot;&quot;&quot; def _identityVerifyingInfoCallback(self, connection, where, ret): if where &amp; SSL_CB_HANDSHAKE_START: set_tlsext_host_name(connection, self._hostnameBytes) elif where &amp; SSL_CB_HANDSHAKE_DONE: try: verifyHostname(connection, self._hostnameASCII) except VerificationError as e: logger.warning( &#39;Remote certificate is not valid for hostname &quot;{}&quot;; {}&#39;.format( self._hostnameASCII, e)) except ValueError as e: logger.warning( &#39;Ignoring error while verifying certificate &#39; &#39;from host &quot;{}&quot; (exception: {})&#39;.format( self._hostnameASCII, repr(e))) DEFAULT_CIPHERS = AcceptableCiphers.fromOpenSSLCipherString(&#39;DEFAULT&#39;) 这里定义了ScrapyClientTLSOptions类， 定义一个认证证书的方法。 对异常进程处理。]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>scrapy</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy源码9 - downloadermiddleware]]></title>
    <url>%2F2020%2F07%2Fpython%2Fspider%2Fscrapy%2F20200711_%20downloadermiddleware%2F</url>
    <content type="text"><![CDATA[下载中间件downloadermiddleware: import six 导入six兼容包 from twisted.internet import defer 导入defer from scrapy.http import Request, Response 导入请求和响应 from scrapy.middleware import MiddlewareManager from scrapy.utils.defer import mustbe_deferred 导入中间件管理 和mustbe_defferred from scrapy.utils.conf import build_component_list 导入构建中间件列表函数 @classmethod def _get_mwlist_from_settings(cls, settings): return build_component_list( settings.getwithbase(&#39;DOWNLOADER_MIDDLEWARES&#39;)) 从设置里面获取下载中间件， 然后构建下载中间件列表 def _add_middleware(self, mw): if hasattr(mw, &#39;process_request&#39;): self.methods[&#39;process_request&#39;].append(mw.process_request) if hasattr(mw, &#39;process_response&#39;): self.methods[&#39;process_response&#39;].insert(0, mw.process_response) if hasattr(mw, &#39;process_exception&#39;): self.methods[&#39;process_exception&#39;].insert(0, mw.process_exception) 添加下载中间件，获取定义的几个方法， 并添加到对应的链上去。 这里可以看出来， 我们自己如果写下载中间件的需要提供如下几个方法。 process_request， process_response，process_exception 这3个方法的。 def download(self, download_func, request, spider): 这个download里面定义了3个方法吧， 也就是上面提到的3个方法。 我们一个一个看看具体写的都是啥。 @defer.inlineCallbacks def process_request(request): for method in self.methods[&#39;process_request&#39;]: response = yield method(request=request, spider=spider) assert response is None or isinstance(response, (Response, Request)), \ &#39;Middleware %s.process_request must return None, Response or Request, got %s&#39; % \ (six.get_method_self(method).__class__.__name__, response.__class__.__name__) if response: defer.returnValue(response) defer.returnValue((yield download_func(request=request,spider=spider))) 先从方法中获取处理请求方法链， 遍历。 获取对应处理方法的响应， 断言响应为none,response,request.如果响应不为空的话， 就直接defer.returnValue, 遍历完毕方法链之后，使用download_func获取结果。 @defer.inlineCallbacks def process_response(response): assert response is not None, &#39;Received None in process_response&#39; if isinstance(response, Request): defer.returnValue(response) for method in self.methods[&#39;process_response&#39;]: response = yield method(request=request, response=response, spider=spider) assert isinstance(response, (Response, Request)), \ &#39;Middleware %s.process_response must return Response or Request, got %s&#39; % \ (six.get_method_self(method).__class__.__name__, type(response)) if isinstance(response, Request): defer.returnValue(response) defer.returnValue(response) 判定是否是响应， 如果响应是请求， 调用defer.returnValue处理。 对于响应， 遍历响应链， 断言响应结果。 如果是request的话， 调用defer.returnValue处理。 最后使用defer.returnValue处理响应。 @defer.inlineCallbacks def process_exception(_failure): exception = _failure.value for method in self.methods[&#39;process_exception&#39;]: response = yield method(request=request, exception=exception, spider=spider) assert response is None or isinstance(response, (Response, Request)), \ &#39;Middleware %s.process_exception must return None, Response or Request, got %s&#39; % \ (six.get_method_self(method).__class__.__name__, type(response)) if response: defer.returnValue(response) defer.returnValue(_failure) 遍历异常处理链， 调用对应的方法处理异常。 断言响应的结果。 返回失败值。]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>scrapy</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy源码8 - contextfactory]]></title>
    <url>%2F2020%2F07%2Fpython%2Fspider%2Fscrapy%2F20200709_%20contextfactory%2F</url>
    <content type="text"><![CDATA[contextfactory.py 这个文件，相对文件内容不多。 from OpenSSL import SSL from twisted.internet.ssl import ClientContextFactory from scrapy import twisted_version 这3句代码， 导入ssl, 导入ClientContextFactory ， 导入twisted_version 我们看看这个version是啥内容 twisted_version = (_txv.major, _txv.minor, _txv.micro) 就是个元组，我们直接在命令端测试下输出。 &gt;&gt;&gt; import scrapy &gt;&gt;&gt; scrapy.twisted_version (17, 5, 0) 这个显示的是主版本， 次版本，最后一个不清楚， 发行版本？ 接下来就是要给大的if else ， 根据上面twisted_version 的版本。 我们只看看 if twisted_version &gt;= (14, 0, 0): 这个分支先。 from zope.interface.declarations import implementer 去官方网站的api查阅下， 这个函数是个装饰器 参数是一个或多个接口或者接口规范。 from twisted.internet.ssl import (optionsForClientTLS, CertificateOptions, platformTrust) from twisted.web.client import BrowserLikePolicyForHTTPS from twisted.web.iweb import IPolicyForHTTPS 这里导入了twisted的几个包。和zope下的一个implementer的包。 from scrapy.core.downloader.tls import ScrapyClientTLSOptions, DEFAULT_CIPHERS 从tls.py里面导入了ScrapyClientTLSOptions, DEFAULT_CIPHERS @implementer(IPolicyForHTTPS) class ScrapyClientContextFactory(BrowserLikePolicyForHTTPS): &quot;&quot;&quot; Non-peer-certificate verifying HTTPS context factory Default OpenSSL method is TLS_METHOD (also called SSLv23_METHOD) which allows TLS protocol negotiation &#39;A TLS/SSL connection established with [this method] may understand the SSLv3, TLSv1, TLSv1.1 and TLSv1.2 protocols.&#39; &quot;&quot;&quot; def __init__(self, method=SSL.SSLv23_METHOD, *args, **kwargs): super(ScrapyClientContextFactory, self).__init__(*args, **kwargs) self._ssl_method = method def getCertificateOptions(self): # setting verify=True will require you to provide CAs # to verify against; in other words: it&#39;s not that simple # backward-compatible SSL/TLS method: # # * this will respect `method` attribute in often recommended # `ScrapyClientContextFactory` subclass # (https://github.com/scrapy/scrapy/issues/1429#issuecomment-131782133) # # * getattr() for `_ssl_method` attribute for context factories # not calling super(..., self).__init__ return CertificateOptions(verify=False, method=getattr(self, &#39;method&#39;, getattr(self, &#39;_ssl_method&#39;, None)), fixBrokenPeers=True, acceptableCiphers=DEFAULT_CIPHERS) # kept for old-style HTTP/1.0 downloader context twisted calls, # e.g. connectSSL() def getContext(self, hostname=None, port=None): return self.getCertificateOptions().getContext() def creatorForNetloc(self, hostname, port): return ScrapyClientTLSOptions(hostname.decode(&quot;ascii&quot;), self.getContext()) 先使用装饰器装饰类。 接口指定为IPolicyForHTTPS def __init__(self, method=SSL.SSLv23_METHOD, *args, **kwargs): super(ScrapyClientContextFactory, self).__init__(*args, **kwargs) self._ssl_method = method 初始化先调用super方法完成父类的初始化工作。 设置sll方法为传递过来的方法， 默认值为SSL.SSLv23_METHOD def getCertificateOptions(self): # setting verify=True will require you to provide CAs # to verify against; in other words: it&#39;s not that simple # backward-compatible SSL/TLS method: # # * this will respect `method` attribute in often recommended # `ScrapyClientContextFactory` subclass # (https://github.com/scrapy/scrapy/issues/1429#issuecomment-131782133) # # * getattr() for `_ssl_method` attribute for context factories # not calling super(..., self).__init__ return CertificateOptions(verify=False, method=getattr(self, &#39;method&#39;, getattr(self, &#39;_ssl_method&#39;, None)), fixBrokenPeers=True, acceptableCiphers=DEFAULT_CIPHERS) # kept for old-style HTTP/1.0 downloader context twisted calls, # e.g. connectSSL() 从方法名上可以推断出来是获取认证选项的 def getContext(self, hostname=None, port=None): return self.getCertificateOptions().getContext() 获取认证选项，获取context. def creatorForNetloc(self, hostname, port): return ScrapyClientTLSOptions(hostname.decode(&quot;ascii&quot;), self.getContext()) 调用getContext获取内容。 class BrowserLikeContextFactory(ScrapyClientContextFactory): &quot;&quot;&quot; Twisted-recommended context factory for web clients. Quoting http://twistedmatrix.com/documents/current/api/twisted.web.client.Agent.html: &quot;The default is to use a BrowserLikePolicyForHTTPS, so unless you have special requirements you can leave this as-is.&quot; creatorForNetloc() is the same as BrowserLikePolicyForHTTPS except this context factory allows setting the TLS/SSL method to use. Default OpenSSL method is TLS_METHOD (also called SSLv23_METHOD) which allows TLS protocol negotiation. &quot;&quot;&quot; def creatorForNetloc(self, hostname, port): # trustRoot set to platformTrust() will use the platform&#39;s root CAs. # # This means that a website like https://www.cacert.org will be rejected # by default, since CAcert.org CA certificate is seldom shipped. return optionsForClientTLS(hostname.decode(&quot;ascii&quot;), trustRoot=platformTrust(), extraCertificateOptions={ &#39;method&#39;: self._ssl_method, }) 这个方法基本和上面的是一样的。 else: class ScrapyClientContextFactory(ClientContextFactory): &quot;A SSL context factory which is more permissive against SSL bugs.&quot; # see https://github.com/scrapy/scrapy/issues/82 # and https://github.com/scrapy/scrapy/issues/26 # and https://github.com/scrapy/scrapy/issues/981 def __init__(self, method=SSL.SSLv23_METHOD): self.method = method def getContext(self, hostname=None, port=None): ctx = ClientContextFactory.getContext(self) # Enable all workarounds to SSL bugs as documented by # http://www.openssl.org/docs/ssl/SSL_CTX_set_options.html ctx.set_options(SSL.OP_ALL) return ctx 初始化并定义getContext方法]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>scrapy</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy源码7：downloader的源码分析]]></title>
    <url>%2F2020%2F07%2Fpython%2Fspider%2Fscrapy%2F20200708_downloader%2F</url>
    <content type="text"><![CDATA[这里我们看看scrapy.core.downloader 这个吧。 from __future__ import absolute_import # 建议尽可能多的使用绝对导入，因此在你的代码中使用from pkg improt string是适宜的。 import random import warnings # 这就是导入随机数和警告 from time import time from datetime import datetime from collections import deque # 这些也是导入基本的包， 没啥问题。 import six from twisted.internet import reactor, defer, task # 这里导入了兼容包six， 以及twisted 下的reactor反应堆， defer以及task。 from scrapy.utils.defer import mustbe_deferred # 导入强制deferred from scrapy.utils.httpobj import urlparse_cached # 这个我们定位过去看看 _urlparse_cache = weakref.WeakKeyDictionary() def urlparse_cached(request_or_response): &quot;&quot;&quot;Return urlparse.urlparse caching the result, where the argument can be a Request or Response object &quot;&quot;&quot; if request_or_response not in _urlparse_cache: _urlparse_cache[request_or_response] = urlparse(request_or_response.url) return _urlparse_cache[request_or_response] # 方法是返回一个结果urlparse,urlparse的缓存结果。 参数可以使请求也可以是响应。 # 如果对象不再字典里面， 就缓存下， 然后返回。 from scrapy.resolver import dnscache # dnscache = LocalCache(10000) ， 说明dnscache 是个dict 的。 from scrapy import signals 导入信号 from .middleware import DownloaderMiddlewareManager from .handlers import DownloadHandlers # 导入了下载中间件和下载处理 # 这个文件2个类， 我们一个一个看。 def __init__(self, concurrency, delay, randomize_delay): self.concurrency = concurrency self.delay = delay self.randomize_delay = randomize_delay self.active = set() self.queue = deque() self.transferring = set() self.lastseen = 0 self.latercall = None # 初始化工作 。 并发，延迟， 是否随机延迟， 活动集合， 队列， 正在传输集合， 最后调用， def free_transfer_slots(self): return self.concurrency - len(self.transferring) # 并发度 - 当前传输的个数= 得到空闲的传输槽 def download_delay(self): if self.randomize_delay: return random.uniform(0.5 * self.delay, 1.5 * self.delay) return self.delay # 下载延迟，如果随机延迟开启的话 在0.5 1.5倍delay之间返回一个值， 否则直接使用delay值。 def close(self): if self.latercall and self.latercall.active(): self.latercall.cancel() # 关闭下载器， 如果最后一个调用存在，代用cancel取消。 def __repr__(self): cls_name = self.__class__.__name__ return &quot;%s(concurrency=%r, delay=%0.2f, randomize_delay=%r)&quot; % ( cls_name, self.concurrency, self.delay, self.randomize_delay) def __str__(self): return ( &quot;&lt;downloader.Slot concurrency=%r delay=%0.2f randomize_delay=%r &quot; &quot;len(active)=%d len(queue)=%d len(transferring)=%d lastseen=%s&gt;&quot; % ( self.concurrency, self.delay, self.randomize_delay, len(self.active), len(self.queue), len(self.transferring), datetime.fromtimestamp(self.lastseen).isoformat() ) ) # 这2个就是基本的方法了。 没啥问题的。 def _get_concurrency_delay(concurrency, spider, settings): delay = settings.getfloat(&#39;DOWNLOAD_DELAY&#39;) if hasattr(spider, &#39;DOWNLOAD_DELAY&#39;): warnings.warn(&quot;%s.DOWNLOAD_DELAY attribute is deprecated, use %s.download_delay instead&quot; % (type(spider).__name__, type(spider).__name__)) delay = spider.DOWNLOAD_DELAY if hasattr(spider, &#39;download_delay&#39;): delay = spider.download_delay if hasattr(spider, &#39;max_concurrent_requests&#39;): concurrency = spider.max_concurrent_requests return concurrency, delay # 获取并发的延迟， 从设置里面获取download_delay 也就是获取下载延迟设置。 # 如果爬虫有对应的下载延迟设置， 提示警告。 还是采用其设置值。 # 如果爬虫有对应的download_delay设置，设置值。 # 如果有最大并发请求个数，最总返回一个最大并发数和延迟量。 # 接下来看看这个下载downloader类 def __init__(self, crawler): self.settings = crawler.settings self.signals = crawler.signals self.slots = {} self.active = set() self.handlers = DownloadHandlers(crawler) self.total_concurrency = self.settings.getint(&#39;CONCURRENT_REQUESTS&#39;) self.domain_concurrency = self.settings.getint(&#39;CONCURRENT_REQUESTS_PER_DOMAIN&#39;) self.ip_concurrency = self.settings.getint(&#39;CONCURRENT_REQUESTS_PER_IP&#39;) self.randomize_delay = self.settings.getbool(&#39;RANDOMIZE_DOWNLOAD_DELAY&#39;) self.middleware = DownloaderMiddlewareManager.from_crawler(crawler) self._slot_gc_loop = task.LoopingCall(self._slot_gc) self._slot_gc_loop.start(60) # 这个是downloader的初始化方法， 根据一个crawler去初始化， # 获取crawler的设置和信号， # 构造一个slots集合， 和一个活动集合。 # 根据crawler构造一个下载处理对象。 # 从设置获取并行请求，每个与的最大请求书， 每个ip的并发请求限制， 随机下载延迟， 中间件通过中间件管理构造。 # task.LoopingCall 百度下， 是一个定时的反复， self._slot_gc_loop = task.LoopingCall(self._slot_gc) self._slot_gc_loop.start(60) # 这2句话的意思就是每60s就去执行下self._slot_gc方法。 def fetch(self, request, spider): def _deactivate(response): self.active.remove(request) return response self.active.add(request) dfd = self.middleware.download(self._enqueue_request, request, spider) return dfd.addBoth(_deactivate) # 活动集合添加请求， 下载中间件完成下载获取deffered对象， 添加一个回调方法移除请求。 def needs_backout(self): return len(self.active) &gt;= self.total_concurrency # 判断当前活动的个数是不是超出了总的并发量 def _get_slot_key(self, request, spider): if &#39;download_slot&#39; in request.meta: return request.meta[&#39;download_slot&#39;] key = urlparse_cached(request).hostname or &#39;&#39; if self.ip_concurrency: key = dnscache.get(key, key) return key # 这个先看看meta有没有download_slot ，如果有的话就直接返回 # 没有话，就从urlparse缓冲里面获取到主机名，如果为空，就设置为‘’ ，如果有ip并发限制 # 从dns缓冲中获取 def _get_slot(self, request, spider): key = self._get_slot_key(request, spider) if key not in self.slots: conc = self.ip_concurrency if self.ip_concurrency else self.domain_concurrency conc, delay = _get_concurrency_delay(conc, spider, self.settings) self.slots[key] = Slot(conc, delay, self.randomize_delay) return key, self.slots[key] # 获取key , 如果key不在slots里面， 如果ip限制了。 就使用ip限制， 否则使用域限制。 # 获取并发和延迟从设置里面， 根据key创建一个slot # 返回key 和slot def _enqueue_request(self, request, spider): key, slot = self._get_slot(request, spider) request.meta[&#39;download_slot&#39;] = key def _deactivate(response): slot.active.remove(request) return response slot.active.add(request) deferred = defer.Deferred().addBoth(_deactivate) slot.queue.append((request, deferred)) self._process_queue(spider, slot) return deferred # 根据请求和爬虫获取key 和slot , 设置请求的meta， slot的active集合添加请求， 添加回调方法去移除活动集合。 # slot的队列添加一个。 调用process_queue 去处理队列。 返回deferred对象。 def _process_queue(self, spider, slot): if slot.latercall and slot.latercall.active(): return # Delay queue processing if a download_delay is configured now = time() delay = slot.download_delay() if delay: penalty = delay - now + slot.lastseen if penalty &gt; 0: slot.latercall = reactor.callLater(penalty, self._process_queue, spider, slot) return # Process enqueued requests if there are free slots to transfer for this slot while slot.queue and slot.free_transfer_slots() &gt; 0: slot.lastseen = now request, deferred = slot.queue.popleft() dfd = self._download(slot, request, spider) dfd.chainDeferred(deferred) # prevent burst if inter-request delays were configured if delay: self._process_queue(spider, slot) break # 处理队列的方法， 如果最后一个调用在，就返回， # 获取当前时间， 从slot获取下载延迟， # 如果有延迟， lastseen 上次slot使用时间， - now 得到 上次使用距离当前时间的差值， 加delay # 如果大于0 说明 等待时间小于延迟时间了。 可以进行下一步操作了。 # 设置下lastcall 设置下几秒之后执行方法。 也就是设置了。等待几秒去执行self._process_queue 方法。 # 如果还有空闲的传输clost的话， # 设置lastseen为now, # 从队列取出一个，调用_download返回一个deferred对象， 添加到deferred链上，如果有延迟，执行#_process_queue方法。 def _download(self, slot, request, spider): # The order is very important for the following deferreds. Do not change! # 1. Create the download deferred dfd = mustbe_deferred(self.handlers.download_request, request, spider) # 2. Notify response_downloaded listeners about the recent download # before querying queue for next request def _downloaded(response): self.signals.send_catch_log(signal=signals.response_downloaded, response=response, request=request, spider=spider) return response dfd.addCallback(_downloaded) # 3. After response arrives, remove the request from transferring # state to free up the transferring slot so it can be used by the # following requests (perhaps those which came from the downloader # middleware itself) slot.transferring.add(request) def finish_transferring(_): slot.transferring.remove(request) self._process_queue(spider, slot) return _ return dfd.addBoth(finish_transferring) # 这个方法写的注释很是详细。 # 创建一个下载deferred， # 通知响应下载监听关于最近的下载，在查询队列为下一次请求之前。 # 在响应接收到到之后， 移除请求从传输状态到free的传输slot上，让其空间给其他请求使用。 def close(self): self._slot_gc_loop.stop() for slot in six.itervalues(self.slots): slot.close() # 关闭方法， 关闭gc_loop # 关闭所有slot。 def _slot_gc(self, age=60): mintime = time() - age for key, slot in list(self.slots.items()): if not slot.active and slot.lastseen + slot.delay &lt; mintime: self.slots.pop(key).close() # 获取近一分钟内，遍历slots。 # 如果slot的状态不是active,上次访问+延迟&lt; mintime的话， 就从slots里面pop出来。 并关闭。]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>scrapy</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy源码6：deffer和parallel的源码分析]]></title>
    <url>%2F2020%2F07%2Fpython%2Fspider%2Fscrapy%2F20200707_deffer%E5%92%8Cparallel%2F</url>
    <content type="text"><![CDATA[deferscrapy的核心的代码大量用到deffer对象，还有一些并行的东西。 这里简单去学习下deffer和并行的方法知识 。twisted.interet.defer 这个官方的api就是下面的网址了。http://twistedmatrix.com/documents/current/api/twisted.internet.defer.html我们可以看到这个defer是twisted提供的internet方法的包 twisted先了解下twisted是个什么。Twisted: The Framework Of Your Internet. 说明twisted是一个网络框架。http://twistedmatrix.com/documents/current/api/twisted.html 这个官方api说的很精简啊， 我们还是看看wiki上怎么说的: Twisted is an event-driven network programming framework written in Python and licensed under the MITLicense.Twisted projects variously support TCP, UDP, SSL/TLS, IP multicast, Unix domain sockets, a large number of protocols (including HTTP, XMPP, NNTP, IMAP, SSH, IRC, FTP, and others), and much more. Twisted is based on the event-driven programming paradigm, which means that users of Twisted write short callbacks which are called by the framework.大概意思如下：Twisted是一个以Python编写的事件驱动的网络编程框架，并根据MIT许可证进行许可。twisted的项目各种支持TCP，UDP，SSL / TLS，IP组播，Unix域套接字，大量协议（包括HTTP，XMPP，NNTP，IMAP，SSH，IRC，FTP等）等等。Twisted是基于事件驱动的编程范例，这意味着Twisted的用户写入框架调用的简短回调。 知道twisted了， 还是应该了解下twisted的异步处理。网址如下: http://blog.csdn.net/fxjtoday/article/details/6396932这个人的博客写的不错。 http://blog.csdn.net/fangjian1204/article/details/42084273 Method addCallbacks Add a pair of callbacks (success and error) to this Deferred.Method addCallback Convenience method for adding just a callback.Method addErrback Convenience method for adding just an errback.Method addBoth Convenience method for adding a single callable as both a callback and an errback. 这里有4个方法， addCallbacks,addBoth 一次添加成功和错误的2个回调。addCallback 添加成功的回调 ， addErrback 添加错误的回调。Method addTimeout Time out this Deferred by scheduling it to be cancelled after timeout seconds. 这个是设置下deferred的时间，超时的话会被取消的。Method chainDeferred Chain another Deferred to this Deferred. Method callback Run all success callbacks that have been added to this Deferred. 运行成功的回调Method errback Run all error callbacks that have been added to this Deferred. 运行所有的错误回调Method pause Stop processing on a Deferred until unpause() is called. 暂定deferred执行， 一直到unpause调用才继续执行Method unpause Process all callbacks made since pause() was called. 解除defered的pause的暂停操作Method cancel Cancel this Deferred. 取消这个defferdMethod str Return a string representation of this Deferred.Method iter UndocumentedMethod send UndocumentedMethod asFuture Adapt a Deferred into a asyncio.Future which is bound to loop.Class Method fromFuture Adapt an asyncio.Future to a Deferred. # 我们在defer.py里面有个方法如下 def parallel(iterable, count, callable, *args, **named): &quot;&quot;&quot;Execute a callable over the objects in the given iterable, in parallel, using no more than ``count`` concurrent calls. Taken from: http://jcalderone.livejournal.com/24285.html &quot;&quot;&quot; coop = task.Cooperator() work = (callable(elem, *args, **named) for elem in iterable) return defer.DeferredList([coop.coiterate(work) for _ in range(count)]) # 先来看看这个task.Cooperator 是什么 # Cooperator的官方api 网址： http://twistedmatrix.com/documents/current/api/twisted.internet.task.Cooperator.html # google翻译了下如下： # 合作任务调度程序。 # 合作任务是一个迭代器，每个迭代代表一个原子工作单元。当迭代器产生时，它允许合作者决定下一个执行其任务。如果迭代器产生defer.Deferred， # 则工作将暂停，直到defer.Deferred触发并完成其回调链。 # 当合作者有多个任务时，它会在所有任务之间分配工作。 # 有两种方法可以向协作者添加任务，进行合作和协调。合作是更有用的两个，因为它返回一个CooperativeTask，可以暂停，恢复和等待。 # coiterate具有相同的效果，但只返回一个延迟。当任务完成时触发。 # 合作者可以用于许多事情，包括但不限于： # 运行一个或多个计算密集型任务而不阻止 # 通过同时运行总任务的子集来限制并行性 # 做一件事，等待延期开火，做下一件事，重复（即序列化一系列异步任务） # 多个合作者不能相互合作，所以在大多数情况下，您应该使用全局的合作伙伴。 # Method __init__ Create a scheduler-like object to which iterators may be added. # 创建可以添加迭代器的类似于调度程序的对象。 # Method coiterate Add an iterator to the list of iterators this Cooperator is #currently running. # 将迭代器添加到此Cooperator当前正在运行的迭代器列表中。 # Method cooperate Start running the given iterator as a long-running cooperative task, by calling next() on it as a periodic timed event. # 开始运行给定的迭代器作为一个长期运行的协作任务，通过调用next（）作为定期定时事件。 # Method start Begin scheduling steps. # 开始安排步骤 # Method stop Stop scheduling steps. Errback the completion Deferreds of all iterators which have been added and forget about them. # 停止调度步骤。 Errback完成所有迭代器已被添加并忘记了它们。 # Method running Is this Cooperator is currently running? # 这个合作伙伴是否正在运行？ # 回到那个代码吧。 第一句 coop = task.Cooperator() 创建一个合作者对象。 # work = (callable(elem, *args, **named) for elem in iterable) 遍历下iterable方法列表， 构造works元组 # coop.coiterate(work) 每一个work都去调用这个方法添加到coop中去， 返回一个deferred数组， 然后转化为defer.DeferredList def process_chain(callbacks, input, *a, **kw): &quot;&quot;&quot;Return a Deferred built by chaining the given callbacks&quot;&quot;&quot; d = defer.Deferred() for x in callbacks: d.addCallback(x, *a, **kw) d.callback(input) return d # 创建一个deferred对象， 添加一系列的成功回调方法， 然后执行所有的成功回调。 返回deffered对象。 def process_chain_both(callbacks, errbacks, input, *a, **kw): &quot;&quot;&quot;Return a Deferred built by chaining the given callbacks and errbacks&quot;&quot;&quot; d = defer.Deferred() for cb, eb in zip(callbacks, errbacks): d.addCallbacks(cb, eb, callbackArgs=a, callbackKeywords=kw, errbackArgs=a, errbackKeywords=kw) if isinstance(input, failure.Failure): d.errback(input) else: d.callback(input) return d # 这个方法， 创建一个deferred对象， 添加成功和失败回调对。 # 如果input是成功的就调用成功回调， 失败调用失败的回调。 def process_parallel(callbacks, input, *a, **kw): &quot;&quot;&quot;Return a Deferred with the output of all successful calls to the given callbacks &quot;&quot;&quot; dfds = [defer.succeed(input).addCallback(x, *a, **kw) for x in callbacks] d = defer.DeferredList(dfds, fireOnOneErrback=1, consumeErrors=1) d.addCallbacks(lambda r: [x[1] for x in r], lambda f: f.value.subFailure) return d # 遍历 callbacks列表， 使用addcallback添加成功的回调。 # defer.succeed(input) 应该是返回一个deferred对象。 # 查看下官方api。 # Function succeed Return a Deferred that has already had .callback(result) called. # 现获取一个dfds 的数组， 然后转为list ， 再有2个参数。 # 添加2个匿名的回调方法。]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>scrapy</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyppeteer的各种案例]]></title>
    <url>%2F2020%2F07%2Fpython%2Fspider%2Fpyppeteer%2F02_%E5%90%84%E7%A7%8D%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[1. 一个简单的案例 import asyncio from pyppeteer import launch async def main(url): browser = await launch() page = await browser.newPage() res = await page.goto(url, options={&#39;timeout&#39;: 30000}) data = await page.content() title = await page.title() resp_cookies = await page.cookies() # cookie resp_headers = res.headers # 响应头 resp_status = res.status # 响应状态 print(data) print(title) print(resp_headers) print(resp_status) if __name__ == &#39;__main__&#39;: url = &quot;http://www.nows.fun/&quot; asyncio.get_event_loop().run_until_complete(main(url)) 2. launch选项:browser = await pyppeteer.launch({ &#39;headless&#39;: False, # 关闭无头模式 &#39;devtools&#39;: True, # 控制界面的显示，用来调试 &#39;executablePath&#39;: &#39;你下载的Chromium.app/Contents/MacOS/Chromiu&#39;, &#39;args&#39;: [ &#39;--disable-extensions&#39;, &#39;--hide-scrollbars&#39;, &#39;--disable-bundled-ppapi-flash&#39;, &#39;--mute-audio&#39;, &#39;--no-sandbox&#39;, # --no-sandbox 在 docker 里使用时需要加入的参数，不然会报错 &#39;--disable-setuid-sandbox&#39;, &#39;--disable-gpu&#39;, &#39;--disable-xss-auditor&#39;, ], &#39;dumpio&#39;: True, # 解决浏览器多开卡死 }) 3. 截图：import asyncio from pyppeteer import launch async def main(url): browser = await launch() page = await browser.newPage() await page.setViewport(viewport={&#39;width&#39;: 1280, &#39;height&#39;: 1800}) res = await page.goto(url, waitUntil=[&quot;networkidle0&quot;, &quot;load&quot;, &quot;domcontentloaded&quot;],options={&#39;timeout&#39;: 0}) await page.screenshot({&#39;path&#39;: &#39;example.png&#39;}) url = &quot;http://www.nows.fun/&quot; asyncio.get_event_loop().run_until_complete(main(url)) 4. 基本使用pyppeteer的一些基本使用，包括网络请求，返回cookie、title、html、响应头、执行js、获取html元素等用法。 import asyncio from pathlib import Path from pyppeteer import launch async def main(url): browser = await launch() page = await browser.newPage() await page.setUserAgent(&#39;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36&#39;) # 是否启用JS，enabled设为False，则无渲染效果 await page.setJavaScriptEnabled(enabled=True) # 注入 js 文件 CURDIR = Path(__file__).parent JS_AJAX_HOOK_LIB = str(CURDIR / &#39;static&#39; / &#39;ajaxhook.min.js&#39;) await page.addScriptTag(path=JS_AJAX_HOOK_LIB) res = await page.goto(url, waitUntil=[&quot;networkidle0&quot;, &quot;load&quot;, &quot;domcontentloaded&quot;],options={&#39;timeout&#39;: 0}) # cookie cookies = await page.cookies() # 网站 title title = await page.title() # html 内容 contents = await page.content() # 响应头 res_headers = res.headers # 响应状态 res_status = res.status # 等待 await asyncio.sleep(2) # 滚动到页面底部 await page.evaluate(&#39;window.scrollBy(0, document.body.scrollHeight)&#39;) # 在网页上执行js 脚本 dimensions = await page.evaluate(pageFunction=&#39;&#39;&#39;() =&gt; { return { width: document.documentElement.clientWidth, // 页面宽度 height: document.documentElement.clientHeight, // 页面高度 deviceScaleFactor: window.devicePixelRatio, // 像素比 1.0000000149011612 } }&#39;&#39;&#39;, force_expr=False) # force_expr=False 执行的是函数 True 则执行表达式 &quot;&quot;&quot; 抓取内容 Page.querySelector() # 选择器 Page.querySelectorAll() Page.xpath() # xpath 表达式 Page.J(), Page.JJ(), and Page.Jx() # 简写 &quot;&quot;&quot; element = await page.querySelector(&quot;.feed-infinite-wrapper &gt; ul&gt;li&quot;) # 只抓取一个 # 获取所有文本内容 执行 js content = await page.evaluate(&#39;(element) =&gt; element.textContent&#39;, element) elements = await page.xpath(&#39;//div[@class=&quot;title-box&quot;]/a&#39;) elements = await page.querySelectorAll(&quot;.title-box a&quot;) for item in elements: print(await item.getProperty(&#39;textContent&#39;)) # &lt;pyppeteer.execution_context.JSHandle object at 0x000002220E7FE518&gt; # 获取文本 title_str = await (await item.getProperty(&#39;textContent&#39;)).jsonValue() # 获取链接 title_link = await (await item.getProperty(&#39;href&#39;)).jsonValue() # 键盘输入 await page.type(&#39;#identifierId&#39;, username) # 点击下一步 await page.click(&#39;#identifierNext &gt; content&#39;) page.mouse # 模拟真实点击 await browser.close() 5. 请求多个url:# -*- encoding: utf-8 -*- import asyncio import pyppeteer from collections import namedtuple Response = namedtuple(&quot;rs&quot;, &quot;title url html cookies headers history status&quot;) async def get_html(url): browser = await pyppeteer.launch(headless=True, args=[&#39;--no-sandbox&#39;]) page = await browser.newPage() res = await page.goto(url, options={&#39;timeout&#39;: 30000}) data = await page.content() title = await page.title() resp_cookies = await page.cookies() # cookie resp_headers = res.headers # 响应头 resp_status = res.status # 响应状态 print(data) print(title) print(resp_headers) print(resp_status) return title if __name__ == &#39;__main__&#39;: url_list = [&quot;https://www.toutiao.com/&quot;, &quot;http://www.nows.fun/&quot;, ] task = [get_html(url) for url in url_list] loop = asyncio.get_event_loop() results = loop.run_until_complete(asyncio.gather(*task)) for res in results: print(res) 6. 模拟输入：# 模拟输入 账号密码 {&#39;delay&#39;: rand_int()} 为输入时间 await page.type(&#39;#TPL_username_1&#39;, &quot;sadfasdfasdf&quot;) await page.type(&#39;#TPL_password_1&#39;, &quot;123456789&quot;, ) await page.waitFor(1000) await page.click(&quot;#J_SubmitStatic&quot;) 7. 爬取京东商城：# -*- encoding: utf-8 -*- import requests from bs4 import BeautifulSoup from pyppeteer import launch import asyncio def screen_size(): &quot;&quot;&quot;使用tkinter获取屏幕大小&quot;&quot;&quot; import tkinter tk = tkinter.Tk() width = tk.winfo_screenwidth() height = tk.winfo_screenheight() tk.quit() return width, height async def main(url): browser = await launch({&#39;args&#39;: [&#39;--no-sandbox&#39;], }) page = await browser.newPage() width, height = screen_size() await page.setViewport(viewport={&quot;width&quot;: width, &quot;height&quot;: height}) await page.setJavaScriptEnabled(enabled=True) await page.setUserAgent(&#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 Edge/16.16299&#39;) await page.goto(url) await page.evaluate(&#39;window.scrollBy(0, document.body.scrollHeight)&#39;) await asyncio.sleep(1) # content = await page.content() li_list = await page.xpath(&#39;//*[@id=&quot;J_goodsList&quot;]/ul/li&#39;) # print(li_list) item_list = [] for li in li_list: a = await li.xpath(&#39;.//div[@class=&quot;p-img&quot;]/a&#39;) detail_url = await (await a[0].getProperty(&quot;href&quot;)).jsonValue() promo_words = await (await a[0].getProperty(&quot;title&quot;)).jsonValue() a_ = await li.xpath(&#39;.//div[@class=&quot;p-commit&quot;]/strong/a&#39;) p_commit = await (await a_[0].getProperty(&quot;textContent&quot;)).jsonValue() i = await li.xpath(&#39;./div/div[3]/strong/i&#39;) price = await (await i[0].getProperty(&quot;textContent&quot;)).jsonValue() em = await li.xpath(&#39;./div/div[4]/a/em&#39;) title = await (await em[0].getProperty(&quot;textContent&quot;)).jsonValue() item = { &quot;title&quot;: title, &quot;detail_url&quot;: detail_url, &quot;promo_words&quot;: promo_words, &#39;p_commit&#39;: p_commit, &#39;price&#39;: price } item_list.append(item) # print(item) # break # print(content) await page_close(browser) return item_list async def page_close(browser): for _page in await browser.pages(): await _page.close() await browser.close() msg = &quot;手机&quot; url = &quot;https://search.jd.com/Search?keyword={}&amp;enc=utf-8&amp;qrst=1&amp;rt=1&amp;stop=1&amp;vt=2&amp;wq={}&amp;cid2=653&amp;cid3=655&amp;page={}&quot; task_list = [] for i in range(1, 6): page = i * 2 - 1 url = url.format(msg, msg, page) task_list.append(main(url)) loop = asyncio.get_event_loop() results = loop.run_until_complete(asyncio.gather(*task_list)) # print(results, len(results)) for i in results: print(i, len(i)) # soup = BeautifulSoup(content, &#39;lxml&#39;) # div = soup.find(&#39;div&#39;, id=&#39;J_goodsList&#39;) # for i, li in enumerate(div.find_all(&#39;li&#39;, class_=&#39;gl-item&#39;)): # if li.select(&#39;.p-img a&#39;): # print(li.select(&#39;.p-img a&#39;)[0][&#39;href&#39;], i) # print(li.select(&#39;.p-price i&#39;)[0].get_text(), i) # print(li.select(&#39;.p-name em&#39;)[0].text, i) # else: # print(&quot;#&quot; * 200) # print(li) 7. xss攻击# -*- encoding: utf-8 -*- import asyncio from pyppeteer import launch payload = &#39;&lt;script&gt;xianzhi(3.1415926535)&lt;/script&gt;&#39; url = &quot;http://192.168.81.132/vuls/sqli/?id=1&#39;&gt;{payload}&quot;.format(payload=payload) def xss_auditor(url, message): if message == 3.1415926535: print(&#39;xss_auditor_found:&#39;, payload) print(url) async def main(): browser = await launch(headless=False, args=[&#39;--disable-xss-auditor&#39;]) page = await browser.newPage() await page.exposeFunction( &#39;xianzhi&#39;, lambda message: xss_auditor(url, message) ) await page.goto(url) await page.close() asyncio.get_event_loop().run_until_complete(main()) 8. 捕获ajax链接启用请求拦截器await page.setRequestInterception(True)，会激活 request.abort，request.continue 和 request.respond 方法，每个请求都将停止，这样可以拦截ajax请求。 page.on(‘request’, get_ajax)遇到request请求时触发。 # -*- encoding: utf-8 -*- import asyncio from pyppeteer import launch async def get_ajax(req): res = {&quot;method&quot;: req.method,&quot;url&quot;:req.url,&quot;data&quot;: &quot;&quot; if req.postData == None else req.postData} print(res) await req.continue_() async def main(url): browser = await launch() page = await browser.newPage() await page.setRequestInterception(True) page.on(&#39;request&#39;, get_ajax) res = await page.goto(url) if __name__ == &#39;__main__&#39;: url = &quot;http://www.nows.fun/&quot; asyncio.get_event_loop().run_until_complete(main(url)) 9. 绕过webdriver检测# -*- encoding: utf-8 -*- import asyncio from pyppeteer import launch async def page_evaluate(page): &#39;&#39;&#39;window.navigator.webdriver=false&#39;&#39;&#39; await page.evaluate(&#39;&#39;&#39;() =&gt;{ Object.defineProperties(navigator,{ webdriver:{ get: () =&gt; undefined } }) }&#39;&#39;&#39;) # 以下为插入中间js，将淘宝会为了检测浏览器而调用的js修改其结果。 await page.evaluate(&#39;&#39;&#39;() =&gt;{ window.navigator.chrome = { runtime: {}, }; }&#39;&#39;&#39;) await page.evaluate(&#39;&#39;&#39;() =&gt;{ Object.defineProperty(navigator, &#39;languages&#39;, { get: () =&gt; [&#39;en-US&#39;, &#39;en&#39;] }); }&#39;&#39;&#39;) await page.evaluate(&#39;&#39;&#39;() =&gt;{ Object.defineProperty(navigator, &#39;plugins&#39;, { get: () =&gt; [1, 2, 3, 4, 5,6], }); }&#39;&#39;&#39;) async def main(): browser = await launch() page = await browser.newPage() await page_evaluate(page) 10. 处理弹框# -*- encoding: utf-8 -*- from pyppeteer import launch async def dialog_control(dialog): await dialog.accept() async def main(self): browser = await launch() page = await browser.newPage() # 用匿名函数：page.on(&#39;dialog&#39;, lambda dialog: dialog.accept()) page.on(&#39;dialog&#39;, self.dialog_control) 11. 过滤掉img, css等请求# -*- encoding: utf-8 -*- import asyncio import pyppeteer from pyppeteer import launch async def goto(page, url): &#39;&#39;&#39;请求加载是否完成，无网都需要处理&#39;&#39;&#39; while True: try: await page.goto(url, { &#39;timeout&#39;: 0, &#39;waitUntil&#39;: &#39;networkidle0&#39; }) break except (pyppeteer.errors.NetworkError, pyppeteer.errors.PageError) as ex: # 无网络 &#39;net::ERR_INTERNET_DISCONNECTED&#39;,&#39;net::ERR_TUNNEL_CONNECTION_FAILED&#39; if &#39;net::&#39; in str(ex): await asyncio.sleep(10) else: raise async def request_check(self, req): &#39;&#39;&#39;filter requests Disable image loading &#39;&#39;&#39; if req.resourceType in [&quot;image&quot;, &quot;media&quot;, &quot;eventsource&quot;, &quot;websocket&quot;, &quot;stylesheet&quot;, &quot;font&quot;]: await req.abort() elif &quot;logout&quot; in req.url or &quot;delete&quot; in req.url or &quot;signout&quot; in req.url: await req.abort() else: await req.continue_() async def main(self): browser = await launch() page = await browser.newPage() await page.setRequestInterception(True) page.on(&#39;request&#39;, self.request_check) 12. 获取表单通过运行js获取表单，先在浏览器中测试通过后再转入脚本运行。 # -*- encoding: utf-8 -*- async def get_urls(page): res = await page.evaluate(&#39;&#39;&#39;() =&gt; { var urls = []; //get form function GetForm() { var f = document.forms; for (var i = 0; i &lt; f.length; i++) { url = f[i].action; //input var inputs = f[i].getElementsByTagName(&#39;*&#39;); var requestdata = &quot;&quot;; var len = inputs.length; for (var j = 0; j &lt; len; j++) { if(inputs[j].hasAttributes(&quot;*&quot;)== true){ if (j &lt; len - 1) { if(inputs[j].hasAttributes(&quot;name&quot;) &amp;&amp; inputs[j].name !=undefined &amp;&amp; inputs[j].name !=&quot;&quot;){ requestdata = requestdata + inputs[j].name } else{ continue } if(inputs[j].hasAttributes(&quot;value&quot;) &amp;&amp; inputs[j].value !=&quot;&quot; &amp;&amp; inputs[j].value !=undefined){ requestdata = requestdata + &quot;=&quot; + inputs[j].value + &quot;&amp;&quot;; } else{ requestdata = requestdata + &quot;=123123&amp;&quot;; } } if (j == len - 1) { if(inputs[j].hasAttributes(&quot;name&quot;) &amp;&amp; inputs[j].name !=undefined &amp;&amp; inputs[j].name !=&quot;&quot;){ requestdata = requestdata + inputs[j].name } else{ continue } if(inputs[j].hasAttributes(&quot;value&quot;) &amp;&amp; inputs[j].value !=&quot;&quot; &amp;&amp; inputs[j].value !=undefined){ requestdata = requestdata + &quot;=&quot; + inputs[j].value ; } else{ requestdata = requestdata + &quot;=123123&quot;; } } } } res = {&quot;method&quot;: &quot;POST&quot;, &quot;url&quot;: url, &quot;data&quot;: requestdata}; if (urls.indexOf(res) &lt; 0) { urls.push(res) } } } GetForm() return urls; }&#39;&#39;&#39;) return res 13. 总的代码： 1 #!/usr/bin/env python3 2 import asyncio 3 import hashlib 4 from pyppeteer import launch 5 from collections import OrderedDict 6 7 &#39;&#39;&#39; 8 pyppeteer/connection.py 9 self._ws = websockets.client.connect( 10 # self._url, max_size=None, loop=self._loop) 11 self._url, max_size=None, loop=self._loop, ping_interval=None, ping_timeout=None) 12 &#39;&#39;&#39; 13 14 class DynamicCrawler(object): 15 &#39;&#39;&#39; Dynamic Crawler 16 crawler ajax onclick tags 17 &#39;&#39;&#39; 18 19 def __init__(self, target): 20 super(DynamicCrawler, self).__init__() 21 self.urls = [] 22 self.target = target 23 self.timeout = 50000 24 self.browser_setting = { 25 &#39;headless&#39;: False, 26 &#39;devtools&#39;: True, # Console 27 # &#39;executablePath&#39;: &#39;Chromium.app/Contents/MacOS/Chromiu&#39;, 28 &#39;ignoreHTTPSErrors&#39;: True, 29 # &#39;slowMo&#39;:100, 30 &#39;args&#39;: [ 31 &#39;--disable-extensions&#39;, 32 &#39;--hide-scrollbars&#39;, 33 &#39;--disable-bundled-ppapi-flash&#39;, 34 &#39;--mute-audio&#39;, 35 &#39;--no-sandbox&#39;, 36 &#39;--disable-setuid-sandbox&#39;, 37 &#39;--disable-gpu&#39;, 38 &#39;--disable-xss-auditor&#39;, 39 ], 40 &#39;dumpio&#39;: True, 41 } 42 43 44 async def request_check(self, req): 45 &#39;&#39;&#39;filter requests 46 Disable image loading 47 &#39;&#39;&#39; 48 49 res = {&quot;method&quot;:req.method,&quot;url&quot;:req.url,&quot;data&quot;: &quot;&quot; if req.postData == None else req.postData} 50 res.update({&quot;hash&quot;:self.get_hash(str(res))}) 51 self.urls.append(res) 52 if req.resourceType in [&quot;image&quot;, &quot;media&quot;, &quot;eventsource&quot;, &quot;websocket&quot;, &quot;stylesheet&quot;, &quot;font&quot;]: 53 # if req.resourceType in [&quot;image&quot;, &quot;media&quot;, &quot;websocket&quot;]: 54 await req.abort() 55 elif &quot;logout&quot; in req.url or &quot;delete&quot; in req.url or &quot;signout&quot; in req.url: 56 await req.abort() 57 else: 58 await req.continue_() 59 60 61 async def frame_nav(self, frameTo): 62 res = {&quot;method&quot;:&quot;Frame&quot;,&quot;url&quot;:frameTo.url} 63 res.update({&quot;hash&quot;:self.get_hash(str(res))}) 64 self.urls.append(res) 65 66 67 async def page_evaluate(self, page): 68 &#39;&#39;&#39;window.navigator.webdriver=false&#39;&#39;&#39; 69 70 await page.evaluate(&#39;&#39;&#39;() =&gt;{ Object.defineProperties(navigator,{ webdriver:{ get: () =&gt; undefined } }) }&#39;&#39;&#39;) # 以下为插入中间js，将淘宝会为了检测浏览器而调用的js修改其结果。 71 await page.evaluate(&#39;&#39;&#39;() =&gt;{ window.navigator.chrome = { runtime: {}, }; }&#39;&#39;&#39;) 72 await page.evaluate(&#39;&#39;&#39;() =&gt;{ Object.defineProperty(navigator, &#39;languages&#39;, { get: () =&gt; [&#39;en-US&#39;, &#39;en&#39;] }); }&#39;&#39;&#39;) 73 await page.evaluate(&#39;&#39;&#39;() =&gt;{ Object.defineProperty(navigator, &#39;plugins&#39;, { get: () =&gt; [1, 2, 3, 4, 5,6], }); }&#39;&#39;&#39;) 74 75 76 async def get_urls(self, page): 77 res = await page.evaluate(&#39;&#39;&#39;() =&gt; { 78 var urls = []; 79 var onevents = []; 80 var onclickstrs = []; 81 //get form 82 function GetForm() { 83 var f = document.forms; 84 for (var i = 0; i &lt; f.length; i++) { 85 url = f[i].action; 86 //input 87 var inputs = f[i].getElementsByTagName(&#39;*&#39;); 88 var requestdata = &quot;&quot;; 89 var len = inputs.length; 90 91 for (var j = 0; j &lt; len; j++) { 92 if(inputs[j].hasAttributes(&quot;*&quot;)== true){ 93 if (j &lt; len - 1) { 94 if(inputs[j].hasAttributes(&quot;name&quot;) &amp;&amp; inputs[j].name !=undefined &amp;&amp; inputs[j].name !=&quot;&quot;){ 95 requestdata = requestdata + inputs[j].name 96 } 97 else{ 98 continue 99 } 100 if(inputs[j].hasAttributes(&quot;value&quot;) &amp;&amp; inputs[j].value !=&quot;&quot; &amp;&amp; inputs[j].value !=undefined){ 101 requestdata = requestdata + &quot;=&quot; + inputs[j].value + &quot;&amp;&quot;; 102 } 103 else{ 104 requestdata = requestdata + &quot;=ATBvea182&amp;&quot;; 105 } 106 } 107 if (j == len - 1) { 108 if(inputs[j].hasAttributes(&quot;name&quot;) &amp;&amp; inputs[j].name !=undefined &amp;&amp; inputs[j].name !=&quot;&quot;){ 109 requestdata = requestdata + inputs[j].name 110 } 111 else{ 112 continue 113 } 114 if(inputs[j].hasAttributes(&quot;value&quot;) &amp;&amp; inputs[j].value !=&quot;&quot; &amp;&amp; inputs[j].value !=undefined){ 115 requestdata = requestdata + &quot;=&quot; + inputs[j].value ; 116 } 117 else{ 118 requestdata = requestdata + &quot;=ATBvea182&quot;; 119 } 120 } 121 } 122 } 123 res = {&quot;method&quot;: &quot;POST&quot;, &quot;url&quot;: url, &quot;data&quot;: requestdata}; 124 if (urls.indexOf(res) &lt; 0) { 125 urls.push(res) 126 } 127 } 128 } 129 130 // get all href 131 function getallurl() { 132 GetForm(); 133 tag_dict = {&#39;a&#39;: &#39;href&#39;,&#39;link&#39;: &#39;href&#39;,&#39;area&#39;: &#39;href&#39;,&#39;img&#39;: &#39;src&#39;,&#39;embed&#39;: &#39;src&#39;,&#39;video&#39;: &#39;src&#39;,&#39;audio&#39;: &#39;src&#39;} 134 for(var tag in tag_dict){ 135 var src = tag_dict[tag]; 136 var elements = document.getElementsByTagName(tag); 137 for (var i = 0; i &lt; elements.length; i++) { 138 res = {&quot;method&quot;:&quot;GET&quot;, &quot;url&quot;: elements[i][src], &quot;data&quot;: &quot;&quot;}; 139 if (urls.indexOf(res) &lt; 0 &amp;&amp; elements[i][src].indexOf(&quot;javascript:&quot;) &lt; 0 &amp;&amp; elements[i][src].indexOf(&quot;mailto:&quot;) &lt; 0) { 140 urls.push(res); 141 } 142 } 143 } 144 } 145 146 //get onevent 147 function getonevents() { 148 // eval all on event 149 var nodes = document.all; 150 for(var i=0;i&lt;nodes.length;i++){ 151 var attrs = nodes[i].attributes; 152 for(var j=0;j&lt;attrs.length;j++){ 153 attr_name = attrs[j].nodeName; 154 attr_value = attrs[j].nodeValue.replace(/return.*/g,&#39;&#39;).replace(/return.*;/g,&#39;&#39;); 155 if(attr_name.substr(0,2) == &quot;on&quot;){ 156 if (onevents.indexOf(attr_value) &lt; 0) { 157 onevents.push(attr_value); 158 } 159 } 160 if(attr_name == &quot;href&quot;){ 161 javascript_code = attr_value.match(&quot;javascript:(.*)&quot;) 162 if (javascript_code) { 163 if (onevents.indexOf(attr_value) &lt; 0) { 164 onevents.push(attr_value); 165 } 166 } 167 } 168 } 169 } 170 } 171 172 function doloop(i) { 173 getallurl(); 174 getonevents(); 175 if (onevents.length ==0) { 176 return; 177 } 178 if (i == (onevents.length - 1)) { 179 try { 180 eval(onevents[i]); 181 }catch(err) { 182 return; 183 } 184 getallurl(); 185 } 186 else { 187 try { 188 eval(onevents[i]); 189 i = i + 1; //1 190 doloop(i); 191 }catch(err) { 192 i = i + 1; //1 193 doloop(i); 194 } 195 } 196 } 197 198 function main() { 199 doloop(0); 200 } 201 main(); 202 return urls; 203 }&#39;&#39;&#39;) 204 return res 205 206 207 def duplicate(self, datas): 208 &#39;&#39;&#39; Data deduplication 209 &#39;&#39;&#39; 210 b = OrderedDict() 211 for item in datas: 212 b.setdefault(item[&#39;hash&#39;],{**item,}) 213 b = list(b.values()) 214 return b 215 216 217 def get_hash(self, content): 218 md = hashlib.md5() 219 md.update(content.encode(&#39;utf-8&#39;)) 220 return md.hexdigest()[:5] 221 222 223 async def main(self): 224 browser = await launch(self.browser_setting) 225 # browser = await launch() 226 page = await browser.newPage() 227 228 await self.page_evaluate(page) 229 230 await page.setUserAgent(&#39;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36&#39;) 231 232 await page.setJavaScriptEnabled(True) 233 # 禁止加载图片接口 234 await page.setRequestInterception(True) 235 page.on(&#39;request&#39;, self.request_check) 236 237 page.on(&#39;framenavigated&#39;, self.frame_nav) 238 # 处理弹框 239 page.on(&#39;dialog&#39;, lambda dialog: dialog.accept()) 240 241 req = await page.goto(self.target, waitUntil=[&quot;networkidle0&quot;, &quot;load&quot;, &quot;domcontentloaded&quot;], options={&#39;timeout&#39;: self.timeout}) 242 cookies = await page.cookies() 243 244 title = await page.title() 245 # html 内容 246 contents = await page.content() 247 248 # 响应头 249 res_headers = req.headers 250 251 # 响应状态 252 res_status = req.status 253 254 getUrls = await self.get_urls(page) 255 for res in getUrls: 256 res.update({&quot;hash&quot;:self.get_hash(str(res))}) 257 self.urls.append(res) 258 259 print (title) 260 print (cookies) 261 # print (res_headers) 262 263 for i in self.duplicate(self.urls): 264 print(i) 265 266 await page.close() 267 await browser.close() 268 269 270 def run(self): 271 asyncio.get_event_loop().run_until_complete(self.main()) 272 273 274 275 # a = DynamicCrawler(&quot;http://demo.aisec.cn/demo/aisec/&quot;) 276 a = DynamicCrawler(&quot;http://192.168.81.132/vuls/config/setup.php&quot;) 277 278 a.run() 14 在docker里使用在 window10 里开发很流程，部署到 windows server 上，可能由于配置比较差或其他原因，网站渲染很慢。可以放在容器里，效果明显。注意点是上面提到了的关闭沙盒模式，需要下一些浏览器的依赖，还有就是最好先把浏览器下好，做到镜像里，这样就不会在容器里一个一个下了。 FROM python:slim WORKDIR /usr/src/app RUN apt-get update &amp;&amp; apt-get install -y gconf-service libasound2 libatk1.0-0 libc6 libcairo2 libcups2 libdbus-1-3 libexpat1 libfontconfig1 libgcc1 libgconf-2-4 libgdk-pixbuf2.0-0 libglib2.0-0 libgtk-3-0 libnspr4 libpango-1.0-0 libpangocairo-1.0-0 libstdc++6 libx11-6 libx11-xcb1 libxcb1 libxcomposite1 libxcursor1 libxdamage1 libxext6 libxfixes3 libxi6 libxrandr2 libxrender1 libxss1 libxtst6 ca-certificates fonts-liberation libappindicator1 libnss3 lsb-release xdg-utils wget RUN apt-get install -y vim COPY requirements.txt ./ RUN pip install --no-cache-dir -r requirements.txt RUN python -c &quot;import pyppeteer;pyppeteer.chromium_downloader.download_chromium();&quot; COPY . . VOLUME /data Puppeteer api手册Pyppeteer 使用笔记pyppeteer使用总结pyppeteer最为核心类Page的接口方法(下)]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>pyppeteer</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pyppeteer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy源码5：middleware的源码分析]]></title>
    <url>%2F2020%2F07%2Fpython%2Fspider%2Fscrapy%2F20200705_%20middleware%2F</url>
    <content type="text"><![CDATA[这个文件是中间件的基类了。 from collections import defaultdict import logging import pprint # 这几个都是引用默认字典， 日志， 打印的，没啥问题。 from scrapy.exceptions import NotConfigured from scrapy.utils.misc import load_object # 导入了notconfigure没有配置的异常， 导入了load_object去完成字符串到对应类对象的方法。前面已经提到了。 from scrapy.utils.defer import process_parallel, process_chain, process_chain_both # 这几个方法都在defer里面。 我们定位过去看看。 def process_parallel(callbacks, input, *a, **kw): &quot;&quot;&quot;Return a Deferred with the output of all successful calls to the given callbacks &quot;&quot;&quot; dfds = [defer.succeed(input).addCallback(x, *a, **kw) for x in callbacks] d = defer.DeferredList(dfds, fireOnOneErrback=1, consumeErrors=1) d.addCallbacks(lambda r: [x[1] for x in r], lambda f: f.value.subFailure) return d # 这个方法完成的功能就是返回一个带有所有成功输出的defrred，通过给定的callback方法。 # 并行处理，得到dfds， 添加一个成功回调。 一个错误回调。 def process_chain(callbacks, input, *a, **kw): &quot;&quot;&quot;Return a Deferred built by chaining the given callbacks&quot;&quot;&quot; d = defer.Deferred() for x in callbacks: d.addCallback(x, *a, **kw) d.callback(input) return d # 这个方法将所有回调方法添加给deferred对象上， 然后给input def process_chain_both(callbacks, errbacks, input, *a, **kw): &quot;&quot;&quot;Return a Deferred built by chaining the given callbacks and errbacks&quot;&quot;&quot; d = defer.Deferred() for cb, eb in zip(callbacks, errbacks): d.addCallbacks(cb, eb, callbackArgs=a, callbackKeywords=kw, errbackArgs=a, errbackKeywords=kw) if isinstance(input, failure.Failure): d.errback(input) else: d.callback(input) return d # 这个是上面的升级版吧， 添加回调。 logger = logging.getLogger(__name__) 全局的一个日志对象。 def __init__(self, *middlewares): self.middlewares = middlewares self.methods = defaultdict(list) for mw in middlewares: self._add_middleware(mw) # 构造函数， 接受中间件列表， 构造方法的默认dict ， 添加中间件。 @classmethod def _get_mwlist_from_settings(cls, settings): raise NotImplementedError # 这个方法什么鬼， 直接抛出异常？， 应该是写一个方法打个桩子吧， 以后可能后去完善它， 然后调用它的吧。 或者子类里面实现吧 。 # 如果子类不实现就抛出异常， 感觉应该是第二种情况， 这个其实和c++的接口是一样的。 强制子类去实现指定的方法。 def from_settings(cls, settings, crawler=None): mwlist = cls._get_mwlist_from_settings(settings) middlewares = [] enabled = [] for clspath in mwlist: try: mwcls = load_object(clspath) if crawler and hasattr(mwcls, &#39;from_crawler&#39;): mw = mwcls.from_crawler(crawler) elif hasattr(mwcls, &#39;from_settings&#39;): mw = mwcls.from_settings(settings) else: mw = mwcls() middlewares.append(mw) enabled.append(clspath) except NotConfigured as e: if e.args: clsname = clspath.split(&#39;.&#39;)[-1] logger.warning(&quot;Disabled %(clsname)s: %(eargs)s&quot;, {&#39;clsname&#39;: clsname, &#39;eargs&#39;: e.args[0]}, extra={&#39;crawler&#39;: crawler}) logger.info(&quot;Enabled %(componentname)ss:\n%(enabledlist)s&quot;, {&#39;componentname&#39;: cls.component_name, &#39;enabledlist&#39;: pprint.pformat(enabled)}, extra={&#39;crawler&#39;: crawler}) return cls(*middlewares) # 使用子类实现的方法_get_mwlist_from_settings 完成从settings里面获取中间件， 遍历中间件列表。 # 如果中间件有from_crawler,from settings 这些方法，就调用下，去构造一个中间件对象。 # 添加到对应的中间件对象列表中去，这里mwlist只是中间件的类名字列表， middlearess存储的是中间件的对象。 # enabled 启用的中间件类列表。如果有异常， 说明配置文件给定的中间件不存在或者没法实例化。 # 日志信息记录启动了那些中间件。返回中间件。 @classmethod def from_crawler(cls, crawler): return cls.from_settings(crawler.settings, crawler) # 调用对应的中间件方法from_settings 方法去完成类实例的创建 def _add_middleware(self, mw): if hasattr(mw, &#39;open_spider&#39;): self.methods[&#39;open_spider&#39;].append(mw.open_spider) if hasattr(mw, &#39;close_spider&#39;): self.methods[&#39;close_spider&#39;].insert(0, mw.close_spider) # 添加中间件的房， 如果有open_spider，close_spider方法的话， 添加到对应方法去。 # 我们这里可以发现， open是append的close是insert 0位置。 # 也就是说， 如果一个中间件的open添加早那么他的close就后关闭的。 def _process_parallel(self, methodname, obj, *args): return process_parallel(self.methods[methodname], obj, *args) # 处理平行的， 这个方法不知道具体怎么并行的。 def _process_chain(self, methodname, obj, *args): return process_chain(self.methods[methodname], obj, *args) # 处理方法链 def _process_chain_both(self, cb_methodname, eb_methodname, obj, *args): return process_chain_both(self.methods[cb_methodname], \ self.methods[eb_methodname], obj, *args) # 处理成功和错误两个链 def open_spider(self, spider): return self._process_parallel(&#39;open_spider&#39;, spider) def close_spider(self, spider): return self._process_parallel(&#39;close_spider&#39;, spider) # 打开爬虫， 关闭爬虫， 都是并行处理的。 # 从这个文件可以看出来， 我们要自己写个中间件的话， 要实现open_spider,close_spider, from_crawler，from_setting这些方法。]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>scrapy</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy源码4：spidermw的源码分析]]></title>
    <url>%2F2020%2F07%2Fpython%2Fspider%2Fscrapy%2F20200704_%20spidermw%2F</url>
    <content type="text"><![CDATA[spidermw的源码分析如下: import six from twisted.python.failure import Failure # 导入six包和导入failure from scrapy.middleware import MiddlewareManager # 这里导入了一个中间件管理的基类，应该适用于后续的继承的吧。 from scrapy.utils.defer import mustbe_deferred from scrapy.utils.conf import build_component_list # 这里从defer里面和conf里面导入2个方法。 先看看具体实现方法吧。 def mustbe_deferred(f, *args, **kw): &quot;&quot;&quot;Same as twisted.internet.defer.maybeDeferred, but delay calling callback/errback to next reactor loop &quot;&quot;&quot; try: result = f(*args, **kw) # FIXME: Hack to avoid introspecting tracebacks. This to speed up # processing of IgnoreRequest errors which are, by far, the most common # exception in Scrapy - see #125 except IgnoreRequest as e: return defer_fail(failure.Failure(e)) except: return defer_fail(failure.Failure()) else: return defer_result(result) # 这个方法有点类似于defer_result 的意思。 不管啥请求都是调用了defer_fail或者defer_result . 都等100ms完成读写。 def build_component_list(compdict, custom=None, convert=update_classpath): &quot;&quot;&quot;Compose a component list from a { class: order } dictionary.&quot;&quot;&quot; def _check_components(complist): if len({convert(c) for c in complist}) != len(complist): raise ValueError(&#39;Some paths in {!r} convert to the same object, &#39; &#39;please update your settings&#39;.format(complist)) def _map_keys(compdict): if isinstance(compdict, BaseSettings): compbs = BaseSettings() for k, v in six.iteritems(compdict): prio = compdict.getpriority(k) if compbs.getpriority(convert(k)) == prio: raise ValueError(&#39;Some paths in {!r} convert to the same &#39; &#39;object, please update your settings&#39; &#39;&#39;.format(list(compdict.keys()))) else: compbs.set(convert(k), v, priority=prio) return compbs else: _check_components(compdict) return {convert(k): v for k, v in six.iteritems(compdict)} def _validate_values(compdict): &quot;&quot;&quot;Fail if a value in the components dict is not a real number or None.&quot;&quot;&quot; for name, value in six.iteritems(compdict): if value is not None and not isinstance(value, numbers.Real): raise ValueError(&#39;Invalid value {} for component {}, please provide &#39; \ &#39;a real number or None instead&#39;.format(value, name)) # BEGIN Backwards compatibility for old (base, custom) call signature if isinstance(custom, (list, tuple)): _check_components(custom) return type(custom)(convert(c) for c in custom) if custom is not None: compdict.update(custom) # END Backwards compatibility _validate_values(compdict) compdict = without_none_values(_map_keys(compdict)) return [k for k, v in sorted(six.iteritems(compdict), key=itemgetter(1))] # 这个方法真的长 啊， 内部嵌套了几个方法。 # 我们把内部嵌套的几个方法都分析下吧。 def _check_components(complist): if len({convert(c) for c in complist}) != len(complist): raise ValueError(&#39;Some paths in {!r} convert to the same object, &#39; &#39;please update your settings&#39;.format(complist)) # 这个方法从名字上看是检查组件的。先判断下长度相等不， 如果不等就抛出异常了。 # 判断过程中用到了convert方法， 发现这个方法有默认值的。也就是convert使用默认的update_classpath方法处理，我们定位过去看看。 def update_classpath(path): &quot;&quot;&quot;Update a deprecated path from an object with its new location&quot;&quot;&quot; for prefix, replacement in DEPRECATION_RULES: if path.startswith(prefix): new_path = path.replace(prefix, replacement, 1) warnings.warn(&quot;`{}` class is deprecated, use `{}` instead&quot;.format(path, new_path), ScrapyDeprecationWarning) return new_path return path # 这里有个规则啊 ，如果以旧的开头， 将他换成新的，然后提示一个警告信息。 返回新的路径。 # 规则我这里也粘贴过来吧。 DEPRECATION_RULES = [ (&#39;scrapy.contrib_exp.downloadermiddleware.decompression.&#39;, &#39;scrapy.downloadermiddlewares.decompression.&#39;), (&#39;scrapy.contrib_exp.iterators.&#39;, &#39;scrapy.utils.iterators.&#39;), (&#39;scrapy.contrib.downloadermiddleware.&#39;, &#39;scrapy.downloadermiddlewares.&#39;), (&#39;scrapy.contrib.exporter.&#39;, &#39;scrapy.exporters.&#39;), (&#39;scrapy.contrib.linkextractors.&#39;, &#39;scrapy.linkextractors.&#39;), (&#39;scrapy.contrib.loader.processor.&#39;, &#39;scrapy.loader.processors.&#39;), (&#39;scrapy.contrib.loader.&#39;, &#39;scrapy.loader.&#39;), (&#39;scrapy.contrib.pipeline.&#39;, &#39;scrapy.pipelines.&#39;), (&#39;scrapy.contrib.spidermiddleware.&#39;, &#39;scrapy.spidermiddlewares.&#39;), (&#39;scrapy.contrib.spiders.&#39;, &#39;scrapy.spiders.&#39;), (&#39;scrapy.contrib.&#39;, &#39;scrapy.extensions.&#39;), (&#39;scrapy.command.&#39;, &#39;scrapy.commands.&#39;), (&#39;scrapy.dupefilter.&#39;, &#39;scrapy.dupefilters.&#39;), (&#39;scrapy.linkextractor.&#39;, &#39;scrapy.linkextractors.&#39;), (&#39;scrapy.telnet.&#39;, &#39;scrapy.extensions.telnet.&#39;), (&#39;scrapy.spider.&#39;, &#39;scrapy.spiders.&#39;), (&#39;scrapy.squeue.&#39;, &#39;scrapy.squeues.&#39;), (&#39;scrapy.statscol.&#39;, &#39;scrapy.statscollectors.&#39;), (&#39;scrapy.utils.decorator.&#39;, &#39;scrapy.utils.decorators.&#39;), (&#39;scrapy.spidermanager.SpiderManager&#39;, &#39;scrapy.spiderloader.SpiderLoader&#39;), ] # 看完这个方法，我们就明白了上面的代码 def _check_components(complist): if len({convert(c) for c in complist}) != len(complist): raise ValueError(&#39;Some paths in {!r} convert to the same object, &#39; &#39;please update your settings&#39;.format(complist)) # 这个他判定长度不等的情况一般是有新的旧的设置，重复导致的。 让你检查你的设置。 def _map_keys(compdict): if isinstance(compdict, BaseSettings): compbs = BaseSettings() for k, v in six.iteritems(compdict): prio = compdict.getpriority(k) if compbs.getpriority(convert(k)) == prio: raise ValueError(&#39;Some paths in {!r} convert to the same &#39; &#39;object, please update your settings&#39; &#39;&#39;.format(list(compdict.keys()))) else: compbs.set(convert(k), v, priority=prio) return compbs else: _check_components(compdict) return {convert(k): v for k, v in six.iteritems(compdict)} # 这个判定下compdict是basesettings的子类， 如果是的话，构造一个basesettings， 遍历compdict # 获取指定key的优先级prio, 如果优先级有相等的是要抛出异常的。其他情况下， 把优先级设置为compdict中指定的优先级。 # 如果不是basesetting的子类。 就调用check_components去检查设置重复，然后返回一个dict对象。 def _validate_values(compdict): &quot;&quot;&quot;Fail if a value in the components dict is not a real number or None.&quot;&quot;&quot; for name, value in six.iteritems(compdict): if value is not None and not isinstance(value, numbers.Real): raise ValueError(&#39;Invalid value {} for component {}, please provide &#39; \ &#39;a real number or None instead&#39;.format(value, name)) # 这个方法就是判定compdict里面value不是none或者real的话就抛出异常。 # 几个内嵌的小方法看完了， 我们还是回到这个build_component_list 这个方法。 # 如果custom是list,tuple的实例的话调用检查个数， 返回指定类对象。 这里返回一个list，或者元组。 # 如果custome 不是none的话，就更新下comdict # 验证下compdict,都是数值的。 def without_none_values(iterable): &quot;&quot;&quot;Return a copy of `iterable` with all `None` entries removed. If `iterable` is a mapping, return a dictionary where all pairs that have value `None` have been removed. &quot;&quot;&quot; try: return {k: v for k, v in six.iteritems(iterable) if v is not None} except AttributeError: return type(iterable)((v for v in iterable if v is not None)) # 这个方法就是把none去掉。 如果是映射的话去掉。 # 这个方法的异常不知道为何要写这个。 方法吧， 可能这个方法其他地方还有其他用地。 # 然后这个方法返回一个排序的key数值， 具体排序方法使用了itemgetter(1) ，定位过去看下。 &quot;&quot;&quot; Return a callable object that fetches the given item(s) from its operand. After f = itemgetter(2), the call f(r) returns r[2]. After g = itemgetter(2, 5, 3), the call g(r) returns (r[2], r[5], r[3]) &quot;&quot;&quot; # 这个说明够详细了吧。 根据value去排序key的上面的语句。 # 接下来就是爬虫中间件的具体实现代码了。 我们这里可以看到他继承了。 中间件管理类， 我们看看， 如果简单的话， 就先看看 # 如果复杂的话就先放放。 def _get_mwlist_from_settings(cls, settings): return build_component_list(settings.getwithbase(&#39;SPIDER_MIDDLEWARES&#39;)) # 从名字上， 我们知道这个是从settings里面获取中间件的列表的。没问题的。 def _add_middleware(self, mw): super(SpiderMiddlewareManager, self)._add_middleware(mw) if hasattr(mw, &#39;process_spider_input&#39;): self.methods[&#39;process_spider_input&#39;].append(mw.process_spider_input) if hasattr(mw, &#39;process_spider_output&#39;): self.methods[&#39;process_spider_output&#39;].insert(0, mw.process_spider_output) if hasattr(mw, &#39;process_spider_exception&#39;): self.methods[&#39;process_spider_exception&#39;].insert(0, mw.process_spider_exception) if hasattr(mw, &#39;process_start_requests&#39;): self.methods[&#39;process_start_requests&#39;].insert(0, mw.process_start_requests) # 这个定义了一个添加中间件的方法 # 先调用基类的add方法， 然后判断判定是否有 process_spider_input 等等方法。 # 如果有的话， 把这个中间件的方法添加到对应的方法链上去。 # 这里有4个。 分别是。 process_spider_input， process_spider_output process_spider_exception process_start_requests # 我们这里可以看出， 如果我们自己要写爬虫中间件， 重点是这4个方法的。 切记切记。 # scrape_response 这个方法太长了。内部也嵌套了几个方法， 我们还是先看看内部的小方法吧。 def process_spider_input(response): for method in self.methods[&#39;process_spider_input&#39;]: try: result = method(response=response, spider=spider) assert result is None, \ &#39;Middleware %s must returns None or &#39; \ &#39;raise an exception, got %s &#39; \ % (fname(method), type(result)) except: return scrape_func(Failure(), request, spider) return scrape_func(response, request, spider) # 处理爬虫的中间件个各个 process_spider_input 方法。 def process_spider_exception(_failure): exception = _failure.value for method in self.methods[&#39;process_spider_exception&#39;]: result = method(response=response, exception=exception, spider=spider) assert result is None or _isiterable(result), \ &#39;Middleware %s must returns None, or an iterable object, got %s &#39; % \ (fname(method), type(result)) if result is not None: return result return _failure # 处理爬虫中间件的各个process_spider_exception方法。结果必须是none或者可迭代的。 def process_spider_output(result): for method in self.methods[&#39;process_spider_output&#39;]: result = method(response=response, result=result, spider=spider) assert _isiterable(result), \ &#39;Middleware %s must returns an iterable object, got %s &#39; % \ (fname(method), type(result)) return result # 处理爬虫中间件的各个process_spider_exception方法。结果可迭代的。 # 这个scrape_response 方法， fname是获取到类的名字， 方法的名字 dfd = mustbe_deferred(process_spider_input, response) dfd.addErrback(process_spider_exception) dfd.addCallback(process_spider_output) # 这段代码， 创建延迟对象， 添加错误回调方法，添加成功回调方法。 def process_start_requests(self, start_requests, spider): return self._process_chain(&#39;process_start_requests&#39;, start_requests, spider) # 这个方法， 就是处理开始请求的。调用了_process_chain处理链， 接受开始的请求和对应的爬虫。 具体还是需要去基类去看看这个方法的。]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>scrapy</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy源码3：scraper的源码分析]]></title>
    <url>%2F2020%2F07%2Fpython%2Fspider%2Fscrapy%2F20200703_%20scraper%2F</url>
    <content type="text"><![CDATA[我们看看scraper.py文件吧。从注释中我们可以看出这个scraper模块是实现爬虫组件去解析响应流并且提取数据的。 import logging from collections import deque # 这2个就是日志的deque队列的导入。 from twisted.python.failure import Failure from twisted.internet import defer # 这2句，导入了一个Failure和一个defer延迟。 from scrapy.utils.defer import defer_result, defer_succeed, parallel, iter_errback # 这个从自己的工具类defer里面导入了好几个方法，基本看是并行，错误，成功，结果的一些相关方法。 我们定位过去一个一个分析下。 def defer_result(result): if isinstance(result, defer.Deferred): return result elif isinstance(result, failure.Failure): return defer_fail(result) else: return defer_succeed(result) # 这里对result进行判定， 如果是Deferred对象，那就返回，如果是Failure结果 返回defer_fail(result) 这个defer_fail应该是对这个错误的result解析的吧。先放放 # 其他的情况就直接使用defer_succeed去解析。既然这里提到了defer_fail，defer_succeed 2个方法， 那我们干脆就先看看这2个方法做了啥。 def defer_fail(_failure): &quot;&quot;&quot;Same as twisted.internet.defer.fail but delay calling errback until next reactor loop It delays by 100ms so reactor has a chance to go trough readers and writers before attending pending delayed calls, so do not set delay to zero. &quot;&quot;&quot; d = defer.Deferred() reactor.callLater(0.1, d.errback, _failure) return d # 这个是google翻译了下twisted.internet.defer.fail相同，但延迟调用errback直到下一个反应器回路它延迟了100ms，所以反应堆有机会通过读写在等待延迟呼叫之前，所以不要将延迟设置为零 # 我们从上面可以知道，他故意延迟0.1为了读写操作的。 def defer_succeed(result): &quot;&quot;&quot;Same as twisted.internet.defer.succeed but delay calling callback until next reactor loop It delays by 100ms so reactor has a chance to go trough readers and writers before attending pending delayed calls, so do not set delay to zero. &quot;&quot;&quot; d = defer.Deferred() reactor.callLater(0.1, d.callback, result) return d # 这个方法不多解释了。 和上面的那个是一样的。 def parallel(iterable, count, callable, *args, **named): &quot;&quot;&quot;Execute a callable over the objects in the given iterable, in parallel, using no more than ``count`` concurrent calls. Taken from: http://jcalderone.livejournal.com/24285.html &quot;&quot;&quot; coop = task.Cooperator() work = (callable(elem, *args, **named) for elem in iterable) return defer.DeferredList([coop.coiterate(work) for _ in range(count)]) # 这个看的不太懂。 就是解决并发问题的。 去了http://jcalderone.livejournal.com/24285.html 也没有看懂。 def iter_errback(iterable, errback, *a, **kw): &quot;&quot;&quot;Wraps an iterable calling an errback if an error is caught while iterating it. &quot;&quot;&quot; it = iter(iterable) while True: try: yield next(it) except StopIteration: break except: errback(failure.Failure(), *a, **kw) # 迭代处理iterable这个对象，google翻译下吧： 如果在迭代时捕获到错误，则可以包装一个可调用的回调函数。这个方法一直迭代，如果错误就使用errback包装一个可回调的函数。 from scrapy.utils.spider import iterate_spider_output def iterate_spider_output(result): return arg_to_iter(result) # 这个方法定位到另一个位置了。 我们追踪过去看看 def arg_to_iter(arg): &quot;&quot;&quot;Convert an argument to an iterable. The argument can be a None, single value, or an iterable. Exception: if arg is a dict, [arg] will be returned &quot;&quot;&quot; if arg is None: return [] elif not isinstance(arg, _ITERABLE_SINGLE_VALUES) and hasattr(arg, &#39;__iter__&#39;): return arg else: return [arg] # 将对象转化为可迭代的对象。 # 如果是none返回[], 如果是不可迭代就返回[arg] 本身迭代的就返回自身。 _ITERABLE_SINGLE_VALUES = dict, BaseItem, six.text_type, bytes # 这里是不是需要还需要判定下arg是不是有__next__呢。 from scrapy.utils.misc import load_object 这个01，02的文档都提到了就是将str转对象的。 from scrapy.utils.log import logformatter_adapter, failure_to_exc_info # 这个是基础日志的。我们也看看吧。 def logformatter_adapter(logkws): &quot;&quot;&quot; Helper that takes the dictionary output from the methods in LogFormatter and adapts it into a tuple of positional arguments for logger.log calls, handling backward compatibility as well. &quot;&quot;&quot; if not {&#39;level&#39;, &#39;msg&#39;, &#39;args&#39;} &lt;= set(logkws): warnings.warn(&#39;Missing keys in LogFormatter method&#39;, ScrapyDeprecationWarning) if &#39;format&#39; in logkws: warnings.warn(&#39;`format` key in LogFormatter methods has been &#39; &#39;deprecated, use `msg` instead&#39;, ScrapyDeprecationWarning) level = logkws.get(&#39;level&#39;, logging.INFO) message = logkws.get(&#39;format&#39;, logkws.get(&#39;msg&#39;)) # NOTE: This also handles &#39;args&#39; being an empty dict, that case doesn&#39;t # play well in logger.log calls args = logkws if not logkws.get(&#39;args&#39;) else logkws[&#39;args&#39;] return (level, message, args) # 这个方法是个适配器，将logkws字典对象最终返回一个元组，日志级别，信息，和详细参数。 def failure_to_exc_info(failure): &quot;&quot;&quot;Extract exc_info from Failure instances&quot;&quot;&quot; if isinstance(failure, Failure): return (failure.type, failure.value, failure.getTracebackObject()) # 方法比较简单， 用于提取错误实例的信息。 from scrapy.exceptions import CloseSpider, DropItem, IgnoreRequest # 这里从异常类导入几个异常吧。 我们也定位过去吧。 class DropItem(Exception): &quot;&quot;&quot;Drop item from the item pipeline&quot;&quot;&quot; pass class CloseSpider(Exception): &quot;&quot;&quot;Raise this from callbacks to request the spider to be closed&quot;&quot;&quot; def __init__(self, reason=&#39;cancelled&#39;): super(CloseSpider, self).__init__() self.reason = reason class IgnoreRequest(Exception): &quot;&quot;&quot;Indicates a decision was made not to process a request&quot;&quot;&quot; # 这三个基本都是异常类而已，继承了exception,无实质代码。 # dropitem: item被丢弃的异常。 # closespider：关闭爬虫的异常。 # IgnoreRequest:忽略请求的异常。 from scrapy import signals # 这里就是导入那几个信号了。 from scrapy.http import Request, Response # 这个导入了请求和响应类。 from scrapy.core.spidermw import SpiderMiddlewareManager # 导入了爬虫中间件管理 from scrapy.utils.request import referer_str # 这个不清楚。 定位过去看下吧。 def referer_str(request): &quot;&quot;&quot; Return Referer HTTP header suitable for logging. &quot;&quot;&quot; referrer = request.headers.get(&#39;Referer&#39;) if referrer is None: return referrer return to_native_str(referrer, errors=&#39;replace&#39;) # 从请求头信息里面获取referer信息。 logger = logging.getLogger(__name__) # 全局的日志对象 # 上面的包分析完毕了。 我们看看下面的类吧，有2个一个是slot，一个是scraper。一个一个看吧。 slot的方法看下 def __init__(self, max_active_size=5000000): self.max_active_size = max_active_size self.queue = deque() self.active = set() self.active_size = 0 self.itemproc_size = 0 self.closing = None # 这里设置了，最大活动大小，默认值为5000000， 这个值为何不放到默认配置文件里面呢。疑惑下。 # 构造一个deques,使用集合去存储活动的， 活动的大小开始为0，itemproc_size item 处理的大小，关闭状态为none. def add_response_request(self, response, request): deferred = defer.Deferred() self.queue.append((response, request, deferred)) if isinstance(response, Response): self.active_size += max(len(response.body), self.MIN_RESPONSE_SIZE) else: self.active_size += self.MIN_RESPONSE_SIZE return deferred # 这个方法从名字上看 ，应该是添加响应请求吧， # 创建一个defer对象，队列里面添加一个(response,request,deferred)元祖，如果response shi REsposne的示例的话 # 活动的大小就是原来活动的大小+ body的长度h或者最小响应的大小。 # 否则，就设置为最小的响应大小。放回那个deferred. def next_response_request_deferred(self): response, request, deferred = self.queue.popleft() self.active.add(request) return response, request, deferred # 从队列中popleft一个元组，活动请求添加request,返回一个元组，response,request,deferred def finish_response(self, response, request): self.active.remove(request) if isinstance(response, Response): self.active_size -= max(len(response.body), self.MIN_RESPONSE_SIZE) else: self.active_size -= self.MIN_RESPONSE_SIZE # 完成响应的话， 就从active活动列表中移除这个请求，active_size 减去对应大小。 def is_idle(self): return not (self.queue or self.active) # 是否空闲的判断， 如果队列不为空， 或者active不为空。 def needs_backout(self): return self.active_size &gt; self.max_active_size # 判断是否超限了。 # 下面看看这个scraper类吧。 def __init__(self, crawler): self.slot = None self.spidermw = SpiderMiddlewareManager.from_crawler(crawler) itemproc_cls = load_object(crawler.settings[&#39;ITEM_PROCESSOR&#39;]) self.itemproc = itemproc_cls.from_crawler(crawler) self.concurrent_items = crawler.settings.getint(&#39;CONCURRENT_ITEMS&#39;) self.crawler = crawler self.signals = crawler.signals self.logformatter = crawler.logformatter # 这个是初始化了，爬虫中间件从crawler获取，item处理类从crawler.settings获取。然后获取一个item处理类的对象。 # 并发item数量，信号和日志formatter设置都是从crawler获取。 @defer.inlineCallbacks def open_spider(self, spider): &quot;&quot;&quot;Open the given spider for scraping and allocate resources for it&quot;&quot;&quot; self.slot = Slot() yield self.itemproc.open_spider(spider) # 这个方法就是打开给定的爬虫，并分配指定的资源， # 创建一个slot，然后调用对应的itemproessor类创建的处理类去打开爬虫。 def close_spider(self, spider): &quot;&quot;&quot;Close a spider being scraped and release its resources&quot;&quot;&quot; slot = self.slot slot.closing = defer.Deferred() slot.closing.addCallback(self.itemproc.close_spider) self._check_if_closing(spider, slot) return slot.closing # 关闭爬虫并且释放资源。 # 获取slot， 然后给slot添加一个closing的事件，然后放回方法。 def is_idle(self): &quot;&quot;&quot;Return True if there isn&#39;t any more spiders to process&quot;&quot;&quot; return not self.slot # 如果没有爬虫去处理了。 就返回true了。 def _check_if_closing(self, spider, slot): if slot.closing and slot.is_idle(): slot.closing.callback(spider) # 如果closing不为空，不为空闲， 就调用指定spider的关闭回调。 def enqueue_scrape(self, response, request, spider): slot = self.slot dfd = slot.add_response_request(response, request) def finish_scraping(_): slot.finish_response(response, request) self._check_if_closing(spider, slot) self._scrape_next(spider, slot) return _ dfd.addBoth(finish_scraping) dfd.addErrback( lambda f: logger.error(&#39;Scraper bug processing %(request)s&#39;, {&#39;request&#39;: request}, exc_info=failure_to_exc_info(f), extra={&#39;spider&#39;: spider})) self._scrape_next(spider, slot) return dfd # 调用add_response_request添加返回一个defferd对象，定义一个完成的方法，给成功和失败都添加一个finish_scraping的回调。 # 给错误的在添加一个匿名的回调方法。 # 调用_scrape_next 处理下一个。 def _scrape_next(self, spider, slot): while slot.queue: response, request, deferred = slot.next_response_request_deferred() self._scrape(response, request, spider).chainDeferred(deferred) # 这里如果slot的queue有内容的haunted， 就一直循环下去， 调用_scrape去处理。 def _scrape(self, response, request, spider): &quot;&quot;&quot;Handle the downloaded response or failure through the spider callback/errback&quot;&quot;&quot; assert isinstance(response, (Response, Failure)) dfd = self._scrape2(response, request, spider) # returns spiders processed output dfd.addErrback(self.handle_spider_error, request, response, spider) dfd.addCallback(self.handle_spider_output, request, response, spider) return dfd # 这个方法就是处理下载响应或者失败，通过给爬虫指定的成功和错误的回调方法。 # 先断言这个是响应流或者failure，调用_scrape2获取爬虫处理的输出 # 添加错误回调和成功回调。 def _scrape2(self, request_result, request, spider): &quot;&quot;&quot;Handle the different cases of request&#39;s result been a Response or a Failure&quot;&quot;&quot; if not isinstance(request_result, Failure): return self.spidermw.scrape_response( self.call_spider, request_result, request, spider) else: # FIXME: don&#39;t ignore errors in spider middleware dfd = self.call_spider(request_result, request, spider) return dfd.addErrback( self._log_download_errors, request_result, request, spider) # 如果响应是成功的的。调用自己的爬虫中间件去处理响应。如果是错误的，调用call_spider方法，给dfd添加一个错误的回调。 def call_spider(self, result, request, spider): result.request = request dfd = defer_result(result) dfd.addCallbacks(request.callback or spider.parse, request.errback) return dfd.addCallback(iterate_spider_output) defer_result 这个方法我们上面已经看了。 主要是等100ms读写的。 添加成功的回调。 # 这个地方注意了。 先使用request。callback , 如果没有指定的话，默认采用spider.parse方法。 # 这就是我们的爬虫为何使用parse方法解析response的原因了。 # 添加一个成功回调。 iterate_spider_output 这个上面已经看过了， 就是返回一个可迭代的对象。 def handle_spider_error(self, _failure, request, response, spider): exc = _failure.value if isinstance(exc, CloseSpider): self.crawler.engine.close_spider(spider, exc.reason or &#39;cancelled&#39;) return logger.error( &quot;Spider error processing %(request)s (referer: %(referer)s)&quot;, {&#39;request&#39;: request, &#39;referer&#39;: referer_str(request)}, exc_info=failure_to_exc_info(_failure), extra={&#39;spider&#39;: spider} ) self.signals.send_catch_log( signal=signals.spider_error, failure=_failure, response=response, spider=spider ) self.crawler.stats.inc_value( &quot;spider_exceptions/%s&quot; % _failure.value.__class__.__name__, spider=spider ) # 这个方法就是处理爬虫错误的 ， 如果是关闭爬虫异常， 调用对应引擎去关闭爬虫，返回 # 其他情况，就记录下日志信息。 发送对应的爬虫错误信号， 统计信息的添加。 def handle_spider_output(self, result, request, response, spider): if not result: return defer_succeed(None) it = iter_errback(result, self.handle_spider_error, request, response, spider) dfd = parallel(it, self.concurrent_items, self._process_spidermw_output, request, response, spider) return dfd # 处理爬虫的输出，如果结果不为空 调用defer_succeed,错误的话调用错误回调，平行处理， _process_spidermw_output去处理 def _process_spidermw_output(self, output, request, response, spider): &quot;&quot;&quot;Process each Request/Item (given in the output parameter) returned from the given spider &quot;&quot;&quot; if isinstance(output, Request): self.crawler.engine.crawl(request=output, spider=spider) elif isinstance(output, (BaseItem, dict)): self.slot.itemproc_size += 1 dfd = self.itemproc.process_item(output, spider) dfd.addBoth(self._itemproc_finished, output, response, spider) return dfd elif output is None: pass else: typename = type(output).__name__ logger.error(&#39;Spider must return Request, BaseItem, dict or None, &#39; &#39;got %(typename)r in %(request)s&#39;, {&#39;request&#39;: request, &#39;typename&#39;: typename}, extra={&#39;spider&#39;: spider}) # 处理每个请求或者从给定的爬虫得到的item # 如果output是个请求的话， 调用engine.crawl抓取。 # 如果是baseitem或者dict的话， 处理个数加1，调用item处理类的process_item去处理item。 # 添加处理完毕事件。 # 其他请求输出日志。 报告你的返回类型不是给定的item类或者字典类。 或者请求。 # 这里就是限定了。 我们爬虫里面的parse方法只能返回这3类的原因了。 def _log_download_errors(self, spider_failure, download_failure, request, spider): &quot;&quot;&quot;Log and silence errors that come from the engine (typically download errors that got propagated thru here) &quot;&quot;&quot; if (isinstance(download_failure, Failure) and not download_failure.check(IgnoreRequest)): if download_failure.frames: logger.error(&#39;Error downloading %(request)s&#39;, {&#39;request&#39;: request}, exc_info=failure_to_exc_info(download_failure), extra={&#39;spider&#39;: spider}) else: errmsg = download_failure.getErrorMessage() if errmsg: logger.error(&#39;Error downloading %(request)s: %(errmsg)s&#39;, {&#39;request&#39;: request, &#39;errmsg&#39;: errmsg}, extra={&#39;spider&#39;: spider}) if spider_failure is not download_failure: return spider_failure # 这里定义个方法下载错误的， 如果是错误 并且不是ignorerequest的话进入if块。 # 如果错误frames不为空，记录错误信息。 # 否则调用geterrmessage方法，记录错误。 # 如果错误不是下载错误，返回爬虫的错误。 def _itemproc_finished(self, output, item, response, spider): &quot;&quot;&quot;ItemProcessor finished for the given ``item`` and returned ``output`` &quot;&quot;&quot; self.slot.itemproc_size -= 1 if isinstance(output, Failure): ex = output.value if isinstance(ex, DropItem): logkws = self.logformatter.dropped(item, ex, response, spider) logger.log(*logformatter_adapter(logkws), extra={&#39;spider&#39;: spider}) return self.signals.send_catch_log_deferred( signal=signals.item_dropped, item=item, response=response, spider=spider, exception=output.value) else: logger.error(&#39;Error processing %(item)s&#39;, {&#39;item&#39;: item}, exc_info=failure_to_exc_info(output), extra={&#39;spider&#39;: spider}) else: logkws = self.logformatter.scraped(output, response, spider) logger.log(*logformatter_adapter(logkws), extra={&#39;spider&#39;: spider}) return self.signals.send_catch_log_deferred( signal=signals.item_scraped, item=output, response=response, spider=spider) # itemprocess处理类结束，如果输出㐊错误。 判定他是不是dropitem。 分别记录日志。 # 正常情况下，记录日志 。通过日志适配器将logkws 转出logger.log方法接受的参数。 # 发送itemscraped信号。]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>scrapy</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy源码2：scheduler的源码分析]]></title>
    <url>%2F2020%2F07%2Fpython%2Fspider%2Fscrapy%2F20200701_scheduler%2F</url>
    <content type="text"><![CDATA[scheduler核心Scheduler主要负责scrapy请求队列的管理，即进队与出队。进一步来说，会涉及到队列的选择，队列去重，序列化。 from_crawler(cls, crawler): settings = crawler.settings dupefilter_cls = load_object(settings[&#39;DUPEFILTER_CLASS&#39;]) dupefilter = dupefilter_cls.from_settings(settings) pqclass = load_object(settings[&#39;SCHEDULER_PRIORITY_QUEUE&#39;]) dqclass = load_object(settings[&#39;SCHEDULER_DISK_QUEUE&#39;]) mqclass = load_object(settings[&#39;SCHEDULER_MEMORY_QUEUE&#39;]) logunser = settings.getbool(&#39;LOG_UNSERIALIZABLE_REQUESTS&#39;, settings.getbool(&#39;SCHEDULER_DEBUG&#39;)) return cls(dupefilter, jobdir=job_dir(settings), logunser=logunser, stats=crawler.stats, pqclass=pqclass, dqclass=dqclass, mqclass=mqclass) 创建了4个对象，分别是dupefilter,pqclass,dqclass,mqclass。 1. dupefilter过滤器（url去重）DUPEFILTER_CLASS = ‘scrapy.dupefilters.RFPDupeFilter’这个类的含义是”Request Fingerprint duplicates filter”，请求指纹副本过滤。也就是对每个request请求做一个指纹，保证相同的请求有相同的指纹。对重复的请求进行过滤。包含查询字符串、cookies字段的相同url也会被去重。 class RFPDupeFilter(BaseDupeFilter): def request_seen(self, request): fp = self.request_fingerprint(request) if fp in self.fingerprints: return True self.fingerprints.add(fp) if self.file: self.file.write(fp + os.linesep) def request_fingerprint(self, request): return request_fingerprint(request) scrapy默认的去重方案：利用request生成fingerprint, 存入set，每次利用set判断，如果用了 disk queue 追加至文件 2. pqclass优先级队列SCHEDULER_PRIORITY_QUEUE = ‘queuelib.PriorityQueue’这是一个优先级队列，使用的是开源的第三方queuelib.它的作用就是对request请求按优先级进行排序，这样我们可以对不同重要性的URL指定优先级（通过设置Request的priority属性）。优先级是一个整数，虽然queuelib使用小的数做为高优化级，但是由于scheduler入队列时取了负值，所以对于我们来说，数值越大优先级越高。 3. dqclass支持序列化的后进先出的磁盘队列SCHEDULER_DISK_QUEUE = ‘scrapy.squeues.PickleLifoDiskQueue’这是一个支持序列化的后进先出的磁盘队列。主要用来帮助我们在停止爬虫后可以接着上一次继续开始爬虫。 4. mqclass后进先出的内存队列SCHEDULER_MEMORY_QUEUE = ‘scrapy.squeues.LifoMemoryQueue’从名字上看，是后进先出的内存队列。这个队列是为了使用2中的队列而存在的，不必单独分析。 scheduler源码解释笔记# scheduler.py import os import json import logging from os.path import join, exists # request_to_dict: 将请求对象转换成dict，如果给定了一个spider，它将尝试找出回调中使用的spider方法的名称，并将其存储为回调。 # request_from_dict：从dict创建请求对象，如果给定了一个spider，它将尝试解析在spider中查找同名方法的回调。 from scrapy.utils.reqser import request_to_dict, request_from_dict from scrapy.utils.misc import load_object, create_instance from scrapy.utils.job import job_dir logger = logging.getLogger(__name__) # 获得一个全局的logger对象。 class Scheduler(object): def __init__(self, dupefilter, jobdir=None, dqclass=None, mqclass=None, logunser=False, stats=None, pqclass=None): self.df = dupefilter # 去重模块 默认利用set在内存去重 self.dqdir = self._dqdir(jobdir) # 磁盘队列路径 持久化队列至硬盘 self.pqclass = pqclass # 带优先级队列 默认来自queuelib self.dqclass = dqclass # 磁盘队列 持久化队列至硬盘 self.mqclass = mqclass # 内存队列 默认来自queuelib self.logunser = logunser self.stats = stats # 状态记录 状态记录通用模块 # 从crawler的设置获取各个属性， 然后使用load_object 获取对应类。 # 主要有以下几个名词， 调度优先级队列，调度磁盘队列，调度内存队列。调度debug开启是否，日志非序列化请求，重复类。 @classmethod def from_crawler(cls, crawler): # 实例化入口 scrapy风格的实例化入口 settings = crawler.settings dupefilter_cls = load_object(settings[&#39;DUPEFILTER_CLASS&#39;]) dupefilter = create_instance(dupefilter_cls, settings, crawler) pqclass = load_object(settings[&#39;SCHEDULER_PRIORITY_QUEUE&#39;]) # &#39;queuelib.PriorityQueue&#39; dqclass = load_object(settings[&#39;SCHEDULER_DISK_QUEUE&#39;]) # &#39;scrapy.squeues.PickleLifoDiskQueue&#39; mqclass = load_object(settings[&#39;SCHEDULER_MEMORY_QUEUE&#39;]) # &#39;scrapy.squeues.LifoMemoryQueue&#39; logunser = settings.getbool(&#39;LOG_UNSERIALIZABLE_REQUESTS&#39;, settings.getbool(&#39;SCHEDULER_DEBUG&#39;)) return cls(dupefilter, jobdir=job_dir(settings), logunser=logunser, stats=crawler.stats, pqclass=pqclass, dqclass=dqclass, mqclass=mqclass) # 获取是否还有请求没处理。 返回true或者false. def has_pending_requests(self): # 检查队列数 指向len return len(self) &gt; 0 # 打开调度器方法： 设置当前的爬虫，设置当前的内存队列，磁盘队列，内存队列初始值为调度优先级队列。 def open(self, spider): # 初始化队列 scrapy模块的初始化入口 self.spider = spider self.mqs = self.pqclass(self._newmq) self.dqs = self._dq() if self.dqdir else None return self.df.open() # 关闭调度器方法： 判断dqs， 关闭dqs，打开active.json文件， 把prios信息写进去。关闭df def close(self, reason): # 安全退出接口 scrapy模块的安全入口 if self.dqs: prios = self.dqs.close() with open(join(self.dqdir, &#39;active.json&#39;), &#39;w&#39;) as f: json.dump(prios, f) return self.df.close(reason) # enqueue_request: 请求进队列 # 如果请求是不过滤的，过滤器df的请求处理过。记录日志， 返回false def enqueue_request(self, request): # 进队api 调度进队 if not request.dont_filter and self.df.request_seen(request): self.df.log(request, self.spider) return False dqok = self._dqpush(request) # self._dqpush 这个是磁盘队列加入这个请求 if dqok: # 如果成功，就给统计信息的disk的对应爬虫加1 self.stats.inc_value(&#39;scheduler/enqueued/disk&#39;, spider=self.spider) else: # 其他情况的话，就给统计信息的memory的对应爬虫加1 self._mqpush(request) self.stats.inc_value(&#39;scheduler/enqueued/memory&#39;, spider=self.spider) self.stats.inc_value(&#39;scheduler/enqueued&#39;, spider=self.spider) # 总的也需要加1，然后返回true return True # next_request：从队列里取出数据进行处理 # 获取下一个请求， 先从内存队列mqs里面pop一个，给memory加1，如果内存中为空就从磁盘队列dq里面pop一个。 # 然后disk加1，如果request不为空， 就给dequed加1 # 注意这个方法和上个方法， 一个是入，一个是出 的。 # 统计信息也是， 一个统计到en队列中， 一个统计到de队列去。 def next_request(self): # 出队api 调度出队，t优先从内存队列里取，然后才是磁盘队列 request = self.mqs.pop() if request: self.stats.inc_value(&#39;scheduler/dequeued/memory&#39;, spider=self.spider) else: request = self._dqpop() if request: self.stats.inc_value(&#39;scheduler/dequeued/disk&#39;, spider=self.spider) if request: self.stats.inc_value(&#39;scheduler/dequeued&#39;, spider=self.spider) return request # 三目运算， 如果磁盘队列不为空的话， 就是磁盘队列加内存队列的长度， 否则就是内存队列的长度。 def __len__(self): return len(self.dqs) + len(self.mqs) if self.dqs else len(self.mqs) &quot;&quot;&quot; 下面的几个方法，_dqpush，_mqpush，_dqpop，_newmq，_newdq，_dq，_dqdir 从方法名字，看看有push,you pop， new ， 大概可以知道这个是构造，添加，删除操作。 _newmq: 构造一个内存队列， _newdq: 构造一个磁盘队列。 具体的列可以看出从setting里面读取过来的。实例化的在这个方面里面的。 返回值就是对应的对象。 _mqpush: 内存队列里面push一个请求， 优先级为请求的负值 _dqpush: 核心就是请求转化为字典， 然后把dict放到磁盘队列中， 如果有异常，说明是无法序列化请求，构造msg信息。 记录警告信息。并记录序列化失败个数，最总返回true，有异常那就返回none _dqpop: 从磁盘队列获取pop一个dict，然后将dict转为request。 返回回去。 _dqdir: 获取dqdir，如果有设置的话， 就会创建一个目录，并返回这个目录 &quot;&quot;&quot; def _dqpush(self, request): if self.dqs is None: return try: reqd = request_to_dict(request, self.spider) self.dqs.push(reqd, -request.priority) except ValueError as e: # non serializable request if self.logunser: msg = (&quot;Unable to serialize request: %(request)s - reason:&quot; &quot; %(reason)s - no more unserializable requests will be&quot; &quot; logged (stats being collected)&quot;) logger.warning(msg, {&#39;request&#39;: request, &#39;reason&#39;: e}, exc_info=True, extra={&#39;spider&#39;: self.spider}) self.logunser = False self.stats.inc_value(&#39;scheduler/unserializable&#39;, spider=self.spider) return else: return True def _mqpush(self, request): self.mqs.push(request, -request.priority) def _dqpop(self): if self.dqs: d = self.dqs.pop() if d: return request_from_dict(d, self.spider) def _newmq(self, priority): return self.mqclass() def _newdq(self, priority): return self.dqclass(join(self.dqdir, &#39;p%s&#39; % priority)) def _dq(self): activef = join(self.dqdir, &#39;active.json&#39;) if exists(activef): with open(activef) as f: prios = json.load(f) else: prios = () q = self.pqclass(self._newdq, startprios=prios) if q: logger.info(&quot;Resuming crawl (%(queuesize)d requests scheduled)&quot;, {&#39;queuesize&#39;: len(q)}, extra={&#39;spider&#39;: self.spider}) return q def _dqdir(self, jobdir): if jobdir: dqdir = join(jobdir, &#39;requests.queue&#39;) if not exists(dqdir): os.makedirs(dqdir) return dqdir]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>scrapy</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy源码1：engine的源码分析]]></title>
    <url>%2F2020%2F06%2Fpython%2Fspider%2Fscrapy%2F20200630_engine%2F</url>
    <content type="text"><![CDATA[scrapy中engine.py的源码分析如下： &quot;&quot;&quot; engine.py提供了2个类：Slot和ExecutionEngine Slot: 提供了几个方法添加请求，删除请求，关闭自己，触发关闭方法 它使用Twisted的主循环reactor来不断的调度执行Engine的&quot;_next_request&quot;方法，这个方法也是核心循环方法。 ExecutionEngine: 引擎的执行任务 爬虫引擎是控制调度器，下载器和爬虫的。 This is the Scrapy engine which controls the Scheduler, Downloader and Spiders. For more information see docs/topics/architecture.rst &quot;&quot;&quot; import logging from time import time # Twisted是用Python实现的基于事件驱动的网络引擎框架，这里引用了它，可能用于网络方面 from twisted.internet import defer, task from twisted.python.failure import Failure # 接下来导入了一些自己的包 from scrapy import signals # 这些信号记录在 docs/topics/signals.rst. 请不要在没有记录的情况下在此处添加新信号。 &#39;&#39;&#39;signals源码如下： &quot;&quot;&quot; Scrapy signals These signals are documented in docs/topics/signals.rst. Please don&#39;t add new signals here without documenting them there. &quot;&quot;&quot; engine_started = object() engine_stopped = object() spider_opened = object() spider_idle = object() # 爬虫空闲 spider_closed = object() spider_error = object() request_scheduled = object() request_dropped = object() request_reached_downloader = object() response_received = object() response_downloaded = object() item_scraped = object() item_dropped = object() item_error = object() # for backwards compatibility stats_spider_opened = spider_opened stats_spider_closing = spider_closed stats_spider_closed = spider_closed item_passed = item_scraped request_received = request_scheduled &#39;&#39;&#39; from scrapy.core.scraper import Scraper # scraper:数据抓取器，主要用于从网页中抓取数据的处理。也就是ItemPipeLine的处理。 from scrapy.exceptions import DontCloseSpider # 从自定义的类里面导入了一个异常类 from scrapy.http import Response, Request # 从http里面导入了response,request from scrapy.utils.misc import load_object # 加载给定对象绝对路径的对象，然后返回它;这个方法是传递一个str，返回一个类，方法，变量或者实例 &#39;&#39;&#39;load_object源码如下： def load_object(path): &quot;&quot;&quot;Load an object given its absolute object path, and return it. object can be a class, function, variable or an instance. path ie: &#39;scrapy.downloadermiddlewares.redirect.RedirectMiddleware&#39; &quot;&quot;&quot; try: dot = path.rindex(&#39;.&#39;) except ValueError: raise ValueError(&quot;Error loading object &#39;%s&#39;: not a full path&quot; % path) module, name = path[:dot], path[dot+1:] mod = import_module(module) try: obj = getattr(mod, name) except AttributeError: raise NameError(&quot;Module &#39;%s&#39; doesn&#39;t define any object named &#39;%s&#39;&quot; % (module, name)) return obj &#39;&#39;&#39; from scrapy.utils.reactor import CallLaterOnce # 调度要在下一个reactor循环中调用的函数，但前提是该函数自上次运行以来尚未被调度 &#39;&#39;&#39;CallLaterOnce源码如下： class CallLaterOnce(object): &quot;&quot;&quot;Schedule a function to be called in the next reactor loop, but only if it hasn&#39;t been already scheduled since the last time it ran. &quot;&quot;&quot; def __init__(self, func, *a, **kw): self._func = func self._a = a self._kw = kw self._call = None def schedule(self, delay=0): if self._call is None: self._call = reactor.callLater(delay, self) def cancel(self): if self._call: self._call.cancel() def __call__(self): self._call = None return self._func(*self._a, **self._kw) &#39;&#39;&#39; from scrapy.utils.log import logformatter_adapter, failure_to_exc_info # 日志相关 logger = logging.getLogger(__name__) # 全局的日志对象 # slot代表一次nextcall的执行，实际上就是执行一次engine的_next_request。 # slot创建了一个hearbeat，即为一个心跳。通过twisted的task.LoopingCall实现。 # 每隔5s执行一次，尝试处理一个新的request，这属于被动执行。后面还会有主动执行的代码。 # slot可以理解为一个request的生命周期。 class Slot(object): def __init__(self, start_requests, close_if_idle, nextcall, scheduler): self.closing = False self.inprogress = set() # requests in progress self.start_requests = iter(start_requests) self.close_if_idle = close_if_idle self.nextcall = nextcall self.scheduler = scheduler self.heartbeat = task.LoopingCall(nextcall.schedule) # heartbeat属性在init的时候初始化了，在close的时候调用stop。 def add_request(self, request): self.inprogress.add(request) def remove_request(self, request): self.inprogress.remove(request) self._maybe_fire_closing() def close(self): self.closing = defer.Deferred() self._maybe_fire_closing() return self.closing def _maybe_fire_closing(self): if self.closing and not self.inprogress: if self.nextcall: self.nextcall.cancel() if self.heartbeat.running: self.heartbeat.stop() self.closing.callback(None) class ExecutionEngine(object): # 接受crawler爬虫，spider_close_callback 完成初始化工作 # 接受初始化的几个参数，设置、信号、日志格式、从crawler那里获取到，从设置中加载日志调度类，从设置加载下载类 # 其中的设置scheduler_cls, downloader_cls, 默认值可以从default_settings.py获取 # SCHEDULER = &#39;scrapy.core.scheduler.Scheduler&#39; # DOWNLOADER = &#39;scrapy.core.downloader.Downloader&#39; def __init__(self, crawler, spider_closed_callback): self.crawler = crawler self.settings = crawler.settings self.signals = crawler.signals self.logformatter = crawler.logformatter self.slot = None self.spider = None self.running = False self.paused = False self.scheduler_cls = load_object(self.settings[&#39;SCHEDULER&#39;]) downloader_cls = load_object(self.settings[&#39;DOWNLOADER&#39;]) self.downloader = downloader_cls(crawler) self.scraper = Scraper(crawler) self._spider_closed_callback = spider_closed_callback # start: 启动爬虫引擎，方法上面带了个装饰器 @defer.inlineCallbacks # 先去断言引擎的运行状态，记录下开始时间，发送一个引擎启动的信号，设置运行状态为运行，设置_closewait为延迟对象，返回_closewait # 或者说：记录启动时间；发送一个&quot;engine_started&quot;消息；设置running标志；创建一个_closewait的Deferred对象并返回。 @defer.inlineCallbacks def start(self): &quot;&quot;&quot;Start the execution engine&quot;&quot;&quot; assert not self.running, &quot;Engine already running&quot; self.start_time = time() yield self.signals.send_catch_log_deferred(signal=signals.engine_started) self.running = True # 这个_closewait会返回给CrawlerProcess， # 这个Deferred在引擎结束时才会调用，因此用它来向CrawlerProcess通知一个Crawler已经爬取完毕。 self._closewait = defer.Deferred() yield self._closewait # stop : 优雅地停止执行引擎 # 标记状态running为false, 关闭所有的爬虫, 调用_finish_stopping_engine def stop(self): &quot;&quot;&quot;Stop the execution engine gracefully&quot;&quot;&quot; assert self.running, &quot;Engine not running&quot; self.running = False dfd = self._close_all_spiders() return dfd.addBoth(lambda _: self._finish_stopping_engine()) # close: 优雅的关闭执行引擎 # 调用stop方法，完成引擎的关闭工作，其他情况下，关闭爬虫和下载器 def close(self): &quot;&quot;&quot;Close the execution engine gracefully. If it has already been started, stop it. In all cases, close all spiders and the downloader. &quot;&quot;&quot; if self.running: # Will also close spiders and downloader return self.stop() elif self.open_spiders: # Will also close downloader return self._close_all_spiders() else: return defer.succeed(self.downloader.close()) # pause:暂停执行引擎 def pause(self): &quot;&quot;&quot;Pause the execution engine&quot;&quot;&quot; self.paused = True # unpause:解除引擎的暂停 def unpause(self): &quot;&quot;&quot;Resume the execution engine&quot;&quot;&quot; self.paused = False # _next_request:下次请求 def _next_request(self, spider): slot = self.slot if not slot: # 状态判断 return if self.paused: # 状态判断 return while not self._needs_backout(spider): if not self._next_request_from_scheduler(spider): break # 下面if语句，请求不为空，并且爬虫没有处理完毕 if slot.start_requests and not self._needs_backout(spider): try: request = next(slot.start_requests) # 调用next方法 except StopIteration: slot.start_requests = None except Exception: slot.start_requests = None logger.error(&#39;Error while obtaining start requests&#39;, exc_info=True, extra={&#39;spider&#39;: spider}) else: self.crawl(request, spider) # 否则去调用crawl方法。 # 如果爬虫是空闲的，并且爬虫空闲则关闭 是true的话，调用_spider_idle方法。 if self.spider_is_idle(spider) and slot.close_if_idle: self._spider_idle(spider) # _needs_backout: 返回一个布尔值 # 如果引擎关闭则返回true, 或者slot关闭，或者下载器那里返回了true, 或者爬虫那里返回true, # 后面的那2个needs_backout需要具体到downloader, scrper类里面去看。 # 我们可以对这个方法的理解为没有接下来的工作了就返回true def _needs_backout(self, spider): slot = self.slot return not self.running \ or slot.closing \ or self.downloader.needs_backout() \ or self.scraper.slot.needs_backout() # _next_request_from_scheduler: 从调度器获取下一个请求， 判断request,下载请求 def _next_request_from_scheduler(self, spider): slot = self.slot request = slot.scheduler.next_request() if not request: return d = self._download(request, spider) d.addBoth(self._handle_downloader_output, request, spider) d.addErrback(lambda f: logger.info(&#39;Error while handling downloader output&#39;, exc_info=failure_to_exc_info(f), extra={&#39;spider&#39;: spider})) d.addBoth(lambda _: slot.remove_request(request)) d.addErrback(lambda f: logger.info(&#39;Error while removing request from slot&#39;, exc_info=failure_to_exc_info(f), extra={&#39;spider&#39;: spider})) d.addBoth(lambda _: slot.nextcall.schedule()) d.addErrback(lambda f: logger.info(&#39;Error while scheduling new request&#39;, exc_info=failure_to_exc_info(f), extra={&#39;spider&#39;: spider})) return d # _handle_downloader_output : 处理下载的输出 # 断言response为request,response,failure ,如果是request则调用crawl方法，如果是响应enqueue_scrape处理。 def _handle_downloader_output(self, response, request, spider): assert isinstance(response, (Request, Response, Failure)), response # downloader middleware can return requests (for example, redirects) if isinstance(response, Request): self.crawl(response, spider) return # response is a Response or Failure d = self.scraper.enqueue_scrape(response, request, spider) d.addErrback(lambda f: logger.error(&#39;Error while enqueuing downloader output&#39;, exc_info=failure_to_exc_info(f), extra={&#39;spider&#39;: spider})) return d # spider_is_idle: 判定爬虫是否是空闲的 # 判定slot空闲，判定下载空闲，判定请求为空，判定调度器没有要处理的请求 def spider_is_idle(self, spider): if not self.scraper.slot.is_idle(): # scraper is not idle return False if self.downloader.active: # downloader has pending requests return False if self.slot.start_requests is not None: # not all start requests are handled return False if self.slot.scheduler.has_pending_requests(): # scheduler has pending requests return False return True # open_spiders: 打开爬虫 @property def open_spiders(self): return [self.spider] if self.spider else [] # has_capacity: 判断是否有能力处理更多的爬虫引擎 def has_capacity(self): &quot;&quot;&quot;Does the engine have capacity to handle more spiders&quot;&quot;&quot; return not bool(self.slot) # 初始化时规定了self.slot = None # crawl : 爬取，先断言爬虫是打开的，执行调度，执行回调的调度 def crawl(self, request, spider): assert spider in self.open_spiders, \ &quot;Spider %r not opened when crawling: %s&quot; % (spider.name, request) self.schedule(request, spider) self.slot.nextcall.schedule() # schedule : 调度，发出请求调度事件，如果enqueue_request , 则触发请求丢弃事件。 def schedule(self, request, spider): self.signals.send_catch_log(signal=signals.request_scheduled, request=request, spider=spider) if not self.slot.scheduler.enqueue_request(request): self.signals.send_catch_log(signal=signals.request_dropped, request=request, spider=spider) # download : 下载, 调用内部方法_download def download(self, request, spider): d = self._download(request, spider) d.addBoth(self._downloaded, self.slot, request, spider) return d # _download : 内部方法 def _downloaded(self, response, slot, request, spider): slot.remove_request(request) return self.download(response, spider) \ if isinstance(response, Request) else response # 添加请求， 定义一个成功的方法，一个完成的方法，从下载器里面提取对象, getaway添加成功回调，添加完成。 # addCallbacks,addBoth 这2个方法用的挺多的 # addcallbacks 接受一个成功的回调方法， 一个失败的回调方法， # addBoth函数向callback与errback链中添加了相同的回调函数 def _download(self, request, spider): slot = self.slot slot.add_request(request) def _on_success(response): assert isinstance(response, (Response, Request)) if isinstance(response, Response): response.request = request # tie request to response received logkws = self.logformatter.crawled(request, response, spider) logger.log(*logformatter_adapter(logkws), extra={&#39;spider&#39;: spider}) self.signals.send_catch_log(signal=signals.response_received, \ response=response, request=request, spider=spider) return response def _on_complete(_): slot.nextcall.schedule() return _ dwld = self.downloader.fetch(request, spider) dwld.addCallbacks(_on_success) dwld.addBoth(_on_complete) return dwld # open_spider：打开爬虫 # 先断言容量，记录info日志，获取nextcall; # 通过crawler构造scheduler调度器，构造slot对象，调度器打开爬虫，爬虫打开，出发爬虫打开事件，启动心跳信息。 @defer.inlineCallbacks def open_spider(self, spider, start_requests=(), close_if_idle=True): assert self.has_capacity(), &quot;No free spider slot when opening %r&quot; % \ spider.name logger.info(&quot;Spider opened&quot;, extra={&#39;spider&#39;: spider}) nextcall = CallLaterOnce(self._next_request, spider) scheduler = self.scheduler_cls.from_crawler(self.crawler) start_requests = yield self.scraper.spidermw.process_start_requests(start_requests, spider) slot = Slot(start_requests, close_if_idle, nextcall, scheduler) self.slot = slot self.spider = spider yield scheduler.open(spider) yield self.scraper.open_spider(spider) self.crawler.stats.open_spider(spider) yield self.signals.send_catch_log_deferred(signals.spider_opened, spider=spider) slot.nextcall.schedule() slot.heartbeat.start(5) # _spider_idle: 爬虫空闲， 判定空闲， 如果空闲的话，关闭爬虫 def _spider_idle(self, spider): &quot;&quot;&quot;Called when a spider gets idle. This function is called when there are no remaining pages to download or schedule. It can be called multiple times. If some extension raises a DontCloseSpider exception (in the spider_idle signal handler) the spider is not closed until the next loop and this function is guaranteed to be called (at least) once again for this spider. 翻译：当爬虫空闲时调用。在没有剩余的页面可供下载或调度时，调用此函数。可以称之为 多次。如果某个扩展引发DontCloseSpider异常（在spider_idle信号处理器中）直到 下一个循环这个爬虫才关闭，这个函数保证爬虫被调用（至少）一次。 &quot;&quot;&quot; res = self.signals.send_catch_log(signal=signals.spider_idle, \ spider=spider, dont_log=DontCloseSpider) if any(isinstance(x, Failure) and isinstance(x.value, DontCloseSpider) \ for _, x in res): return if self.spider_is_idle(spider): self.close_spider(spider, reason=&#39;finished&#39;) # close_spider : 关闭爬虫，绑定各种错误回调。 # 关闭（取消）spider并清除所有未完成的请求 def close_spider(self, spider, reason=&#39;cancelled&#39;): &quot;&quot;&quot;Close (cancel) spider and clear all its outstanding requests&quot;&quot;&quot; slot = self.slot if slot.closing: return slot.closing logger.info(&quot;Closing spider (%(reason)s)&quot;, {&#39;reason&#39;: reason}, extra={&#39;spider&#39;: spider}) dfd = slot.close() def log_failure(msg): def errback(failure): logger.error( msg, exc_info=failure_to_exc_info(failure), extra={&#39;spider&#39;: spider} ) return errback dfd.addBoth(lambda _: self.downloader.close()) dfd.addErrback(log_failure(&#39;Downloader close failure&#39;)) dfd.addBoth(lambda _: self.scraper.close_spider(spider)) dfd.addErrback(log_failure(&#39;Scraper close failure&#39;)) dfd.addBoth(lambda _: slot.scheduler.close(reason)) dfd.addErrback(log_failure(&#39;Scheduler close failure&#39;)) dfd.addBoth(lambda _: self.signals.send_catch_log_deferred( signal=signals.spider_closed, spider=spider, reason=reason)) dfd.addErrback(log_failure(&#39;Error while sending spider_close signal&#39;)) dfd.addBoth(lambda _: self.crawler.stats.close_spider(spider, reason=reason)) dfd.addErrback(log_failure(&#39;Stats close failure&#39;)) dfd.addBoth(lambda _: logger.info(&quot;Spider closed (%(reason)s)&quot;, {&#39;reason&#39;: reason}, extra={&#39;spider&#39;: spider})) dfd.addBoth(lambda _: setattr(self, &#39;slot&#39;, None)) dfd.addErrback(log_failure(&#39;Error while unassigning slot&#39;)) dfd.addBoth(lambda _: setattr(self, &#39;spider&#39;, None)) dfd.addErrback(log_failure(&#39;Error while unassigning spider&#39;)) dfd.addBoth(lambda _: self._spider_closed_callback(spider)) return dfd # _close_all_spiders :关闭所有的爬虫，遍历爬虫，执行关闭操作 def _close_all_spiders(self): dfds = [self.close_spider(s, reason=&#39;shutdown&#39;) for s in self.open_spiders] dlist = defer.DeferredList(dfds) return dlist # _finish_stopping_engine : 结束引擎，触发引擎关闭操作。 @defer.inlineCallbacks def _finish_stopping_engine(self): yield self.signals.send_catch_log_deferred(signal=signals.engine_stopped) self._closewait.callback(None) 实际源码中engine.py &quot;&quot;&quot; This is the Scrapy engine which controls the Scheduler, Downloader and Spiders. For more information see docs/topics/architecture.rst &quot;&quot;&quot; import logging from time import time from twisted.internet import defer, task from twisted.python.failure import Failure from scrapy import signals from scrapy.core.scraper import Scraper from scrapy.exceptions import DontCloseSpider from scrapy.http import Response, Request from scrapy.utils.misc import load_object from scrapy.utils.reactor import CallLaterOnce from scrapy.utils.log import logformatter_adapter, failure_to_exc_info logger = logging.getLogger(__name__) class Slot(object): def __init__(self, start_requests, close_if_idle, nextcall, scheduler): self.closing = False self.inprogress = set() # requests in progress self.start_requests = iter(start_requests) self.close_if_idle = close_if_idle self.nextcall = nextcall self.scheduler = scheduler self.heartbeat = task.LoopingCall(nextcall.schedule) def add_request(self, request): self.inprogress.add(request) def remove_request(self, request): self.inprogress.remove(request) self._maybe_fire_closing() def close(self): self.closing = defer.Deferred() self._maybe_fire_closing() return self.closing def _maybe_fire_closing(self): if self.closing and not self.inprogress: if self.nextcall: self.nextcall.cancel() if self.heartbeat.running: self.heartbeat.stop() self.closing.callback(None) class ExecutionEngine(object): def __init__(self, crawler, spider_closed_callback): self.crawler = crawler self.settings = crawler.settings self.signals = crawler.signals self.logformatter = crawler.logformatter self.slot = None self.spider = None self.running = False self.paused = False self.scheduler_cls = load_object(self.settings[&#39;SCHEDULER&#39;]) downloader_cls = load_object(self.settings[&#39;DOWNLOADER&#39;]) self.downloader = downloader_cls(crawler) self.scraper = Scraper(crawler) self._spider_closed_callback = spider_closed_callback @defer.inlineCallbacks def start(self): &quot;&quot;&quot;Start the execution engine&quot;&quot;&quot; assert not self.running, &quot;Engine already running&quot; self.start_time = time() yield self.signals.send_catch_log_deferred(signal=signals.engine_started) self.running = True self._closewait = defer.Deferred() yield self._closewait def stop(self): &quot;&quot;&quot;Stop the execution engine gracefully&quot;&quot;&quot; assert self.running, &quot;Engine not running&quot; self.running = False dfd = self._close_all_spiders() return dfd.addBoth(lambda _: self._finish_stopping_engine()) def close(self): &quot;&quot;&quot;Close the execution engine gracefully. If it has already been started, stop it. In all cases, close all spiders and the downloader. &quot;&quot;&quot; if self.running: # Will also close spiders and downloader return self.stop() elif self.open_spiders: # Will also close downloader return self._close_all_spiders() else: return defer.succeed(self.downloader.close()) def pause(self): &quot;&quot;&quot;Pause the execution engine&quot;&quot;&quot; self.paused = True def unpause(self): &quot;&quot;&quot;Resume the execution engine&quot;&quot;&quot; self.paused = False def _next_request(self, spider): slot = self.slot if not slot: return if self.paused: return while not self._needs_backout(spider): if not self._next_request_from_scheduler(spider): break if slot.start_requests and not self._needs_backout(spider): try: request = next(slot.start_requests) except StopIteration: slot.start_requests = None except Exception: slot.start_requests = None logger.error(&#39;Error while obtaining start requests&#39;, exc_info=True, extra={&#39;spider&#39;: spider}) else: self.crawl(request, spider) if self.spider_is_idle(spider) and slot.close_if_idle: self._spider_idle(spider) def _needs_backout(self, spider): slot = self.slot return not self.running \ or slot.closing \ or self.downloader.needs_backout() \ or self.scraper.slot.needs_backout() def _next_request_from_scheduler(self, spider): slot = self.slot request = slot.scheduler.next_request() if not request: return d = self._download(request, spider) d.addBoth(self._handle_downloader_output, request, spider) d.addErrback(lambda f: logger.info(&#39;Error while handling downloader output&#39;, exc_info=failure_to_exc_info(f), extra={&#39;spider&#39;: spider})) d.addBoth(lambda _: slot.remove_request(request)) d.addErrback(lambda f: logger.info(&#39;Error while removing request from slot&#39;, exc_info=failure_to_exc_info(f), extra={&#39;spider&#39;: spider})) d.addBoth(lambda _: slot.nextcall.schedule()) d.addErrback(lambda f: logger.info(&#39;Error while scheduling new request&#39;, exc_info=failure_to_exc_info(f), extra={&#39;spider&#39;: spider})) return d def _handle_downloader_output(self, response, request, spider): assert isinstance(response, (Request, Response, Failure)), response # downloader middleware can return requests (for example, redirects) if isinstance(response, Request): self.crawl(response, spider) return # response is a Response or Failure d = self.scraper.enqueue_scrape(response, request, spider) d.addErrback(lambda f: logger.error(&#39;Error while enqueuing downloader output&#39;, exc_info=failure_to_exc_info(f), extra={&#39;spider&#39;: spider})) return d def spider_is_idle(self, spider): if not self.scraper.slot.is_idle(): # scraper is not idle return False if self.downloader.active: # downloader has pending requests return False if self.slot.start_requests is not None: # not all start requests are handled return False if self.slot.scheduler.has_pending_requests(): # scheduler has pending requests return False return True @property def open_spiders(self): return [self.spider] if self.spider else [] def has_capacity(self): &quot;&quot;&quot;Does the engine have capacity to handle more spiders&quot;&quot;&quot; return not bool(self.slot) def crawl(self, request, spider): assert spider in self.open_spiders, \ &quot;Spider %r not opened when crawling: %s&quot; % (spider.name, request) self.schedule(request, spider) self.slot.nextcall.schedule() def schedule(self, request, spider): self.signals.send_catch_log(signal=signals.request_scheduled, request=request, spider=spider) if not self.slot.scheduler.enqueue_request(request): self.signals.send_catch_log(signal=signals.request_dropped, request=request, spider=spider) def download(self, request, spider): d = self._download(request, spider) d.addBoth(self._downloaded, self.slot, request, spider) return d def _downloaded(self, response, slot, request, spider): slot.remove_request(request) return self.download(response, spider) \ if isinstance(response, Request) else response def _download(self, request, spider): slot = self.slot slot.add_request(request) def _on_success(response): assert isinstance(response, (Response, Request)) if isinstance(response, Response): response.request = request # tie request to response received logkws = self.logformatter.crawled(request, response, spider) logger.log(*logformatter_adapter(logkws), extra={&#39;spider&#39;: spider}) self.signals.send_catch_log(signal=signals.response_received, \ response=response, request=request, spider=spider) return response def _on_complete(_): slot.nextcall.schedule() return _ dwld = self.downloader.fetch(request, spider) dwld.addCallbacks(_on_success) dwld.addBoth(_on_complete) return dwld @defer.inlineCallbacks def open_spider(self, spider, start_requests=(), close_if_idle=True): assert self.has_capacity(), &quot;No free spider slot when opening %r&quot; % \ spider.name logger.info(&quot;Spider opened&quot;, extra={&#39;spider&#39;: spider}) nextcall = CallLaterOnce(self._next_request, spider) scheduler = self.scheduler_cls.from_crawler(self.crawler) start_requests = yield self.scraper.spidermw.process_start_requests(start_requests, spider) slot = Slot(start_requests, close_if_idle, nextcall, scheduler) self.slot = slot self.spider = spider yield scheduler.open(spider) yield self.scraper.open_spider(spider) self.crawler.stats.open_spider(spider) yield self.signals.send_catch_log_deferred(signals.spider_opened, spider=spider) slot.nextcall.schedule() slot.heartbeat.start(5) def _spider_idle(self, spider): &quot;&quot;&quot;Called when a spider gets idle. This function is called when there are no remaining pages to download or schedule. It can be called multiple times. If some extension raises a DontCloseSpider exception (in the spider_idle signal handler) the spider is not closed until the next loop and this function is guaranteed to be called (at least) once again for this spider. &quot;&quot;&quot; res = self.signals.send_catch_log(signal=signals.spider_idle, \ spider=spider, dont_log=DontCloseSpider) if any(isinstance(x, Failure) and isinstance(x.value, DontCloseSpider) \ for _, x in res): return if self.spider_is_idle(spider): self.close_spider(spider, reason=&#39;finished&#39;) def close_spider(self, spider, reason=&#39;cancelled&#39;): &quot;&quot;&quot;Close (cancel) spider and clear all its outstanding requests&quot;&quot;&quot; slot = self.slot if slot.closing: return slot.closing logger.info(&quot;Closing spider (%(reason)s)&quot;, {&#39;reason&#39;: reason}, extra={&#39;spider&#39;: spider}) dfd = slot.close() def log_failure(msg): def errback(failure): logger.error( msg, exc_info=failure_to_exc_info(failure), extra={&#39;spider&#39;: spider} ) return errback dfd.addBoth(lambda _: self.downloader.close()) dfd.addErrback(log_failure(&#39;Downloader close failure&#39;)) dfd.addBoth(lambda _: self.scraper.close_spider(spider)) dfd.addErrback(log_failure(&#39;Scraper close failure&#39;)) dfd.addBoth(lambda _: slot.scheduler.close(reason)) dfd.addErrback(log_failure(&#39;Scheduler close failure&#39;)) dfd.addBoth(lambda _: self.signals.send_catch_log_deferred( signal=signals.spider_closed, spider=spider, reason=reason)) dfd.addErrback(log_failure(&#39;Error while sending spider_close signal&#39;)) dfd.addBoth(lambda _: self.crawler.stats.close_spider(spider, reason=reason)) dfd.addErrback(log_failure(&#39;Stats close failure&#39;)) dfd.addBoth(lambda _: logger.info(&quot;Spider closed (%(reason)s)&quot;, {&#39;reason&#39;: reason}, extra={&#39;spider&#39;: spider})) dfd.addBoth(lambda _: setattr(self, &#39;slot&#39;, None)) dfd.addErrback(log_failure(&#39;Error while unassigning slot&#39;)) dfd.addBoth(lambda _: setattr(self, &#39;spider&#39;, None)) dfd.addErrback(log_failure(&#39;Error while unassigning spider&#39;)) dfd.addBoth(lambda _: self._spider_closed_callback(spider)) return dfd def _close_all_spiders(self): dfds = [self.close_spider(s, reason=&#39;shutdown&#39;) for s in self.open_spiders] dlist = defer.DeferredList(dfds) return dlist @defer.inlineCallbacks def _finish_stopping_engine(self): yield self.signals.send_catch_log_deferred(signal=signals.engine_stopped) self._closewait.callback(None)]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>scrapy</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pyppeteer的环境搭建，常见参数及2个案例]]></title>
    <url>%2F2020%2F06%2Fpython%2Fspider%2Fpyppeteer%2F01_%E4%BB%8B%E7%BB%8D%E5%8F%8A%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[一. pyppeteer介绍Puppeteer是谷歌出品的一款基于Node.js开发的一款工具，主要是用来操纵Chrome浏览器的 API，通过Javascript代码来操纵Chrome浏览器，完成数据爬取、Web程序自动测试等任务。 Puppeteer 默认以 headless 模式运行，但是可以通过修改配置文件运行“有头”模式。 Pyppeteer的两大特点，chromium浏览器和asyncio框架： Chromium是一款独立的浏览器，是Google为发展自家的浏览器Google Chrome而开启的计划，相当于Chrome的实验版，Chromium的稳定性不如Chrome但是功能更加丰富，而且更新速度很快，通常每隔数小时就有新的开发版本发布。 asyncio是Python的一个异步协程库，自3.4版本引入的标准库，直接内置了对异步IO的支持。 github地址：https://github.com/puppeteer/puppeteer/blob/v2.1.1/docs/api.md 中文版教程：https://zhaoqize.github.io/puppeteer-api-zh_CN/ 二. 环境搭建 国内无法访问 可以使用国内镜像 pip install pyppeteer -i https://pypi.douban.com/simple chromium下载地址：https://npm.taobao.org/mirrors/chromium-browser-snapshots/，下载之后解压之后，通过executablePath属性指定运行浏览器了 三. 常见参数 属性 数据类型 描述 executablePath str chrome.exe运行的路径 ignorehttpserrrors bool 忽略https错误，默认false headless bool True 开始无头浏览器 False关闭无头 dumpio bool 设置True 解决浏览器多开卡死 args的参数设置：| 属性 | 数据类型 | 描述 || — | — | — || –disable-infobars | - | 关闭自动化提示框 || –window-size=1920,1080 | str | 设置浏览器大小吗，1920是宽，1080是宽 || –log-level=30 | str | 日志保存等级 || –start-maximized | - | 窗口最大化模式 || –proxy-server=http://localhost:1080 | str | 设置代理 || userDataDir=D:\userData\ | str | 用户文件保存地址 | 四. 使用案例4.1 案例1#!/usr/bin/python # -*- coding: UTF-8 -*- import asyncio from pyppeteer import launch async def main(): # 浏览器 启动参数 start_parm = { # 启动chrome的路径 &quot;executablePath&quot;: r&quot;E:\tmp\chrome-win\chrome.exe&quot;, # 关闭无头浏览器 默认是无头启动的 &quot;headless&quot;: False, } # 创建浏览器对象，可以传入 字典形式参数 browser = await launch(**start_parm) # 创建一个页面对象， 页面操作在该对象上执行 page = await browser.newPage() await page.goto(&#39;http://www.nows.fun/&#39;) # 页面跳转 page_text = await page.content() # 页面内容 print(page_text) await browser.close() # 关闭浏览器对象 asyncio.get_event_loop().run_until_complete(main()) # 创建异步池并执行main函数。 执行结果如下图： 4.2 案例2: 设置可视化参数，代码如下# !/usr/bin/python # -*- coding: UTF-8 -*- import asyncio import tkinter from pyppeteer import launcher # 注意 在导入launch之前先把默认参数改了 # 去除自动化 启动参数 launcher.AUTOMATION_ARGS.remove(&quot;--enable-automation&quot;) from pyppeteer import launch async def main(): # 浏览器 启动参数 start_parm = { # 启动chrome的路径 &quot;executablePath&quot;: r&quot;E:\tmp\chrome-win\chrome.exe&quot;, # 关闭无头浏览器 &quot;headless&quot;: False, &quot;args&quot;: [ &#39;--disable-infobars&#39;, # 关闭自动化提示框 &#39;--no-sandbox&#39;, # 关闭沙盒模式 &#39;--start-maximized&#39;, # 窗口最大化模式 ], } browser = await launch(**start_parm) page = await browser.newPage() # 查看当前 桌面视图大小 tk = tkinter.Tk() width = tk.winfo_screenwidth() height = tk.winfo_screenheight() tk.quit() print(f&#39;设置窗口为：width：{width} height：{height}&#39;) # 设置网页 视图大小 await page.setViewport(viewport={&#39;width&#39;: width, &#39;height&#39;: height}) await page.goto(&#39;http://www.nows.fun/&#39;) page_text = await page.content() print(page_text) await browser.close() asyncio.get_event_loop().run_until_complete(main())]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>pyppeteer</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pyppeteer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql报错：1366, Incorrect string value:for colum 的解决办法]]></title>
    <url>%2F2020%2F06%2Fdatabase%2Fmysql%2F20200609_mysql%E6%8A%A5%E9%94%991366%2F</url>
    <content type="text"><![CDATA[原表为： 执行sql语句： 向mysql中插入数据时，报错：1366, &quot;Incorrect string value: &#39;\\xE5\\x96\\x9C\\xE6\\xAC\\xA2...&#39; for colum 报错原因：ubuntu刚安装完mysql，默认字符集是latin1，把字符编码修改成utf8格式就行了。修复方法：在 【client】下追加： default-character-set=utf8 在 【mysqld】下追加： character-set-server=utf8 在 【mysql】 下追加： default-character-set=utf8 保存并退出注： 我的【mysqld】在 /etc/mysql/mysql.conf.d/mysqld.cnf我的【mysql】 在 /etc/mysql/conf.d/mysql.cnf我的【client】 在 /etc/mysql/debian.cnf 4. 然后重启MySQL：service mysql restart。可查看字符集：mysql -u root -p 输入密码 show variables like &#39;%character%&#39;; 可看到结果如下图：]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask,tornado,fastapi 的比较]]></title>
    <url>%2F2020%2F04%2Ffront%2Fflask%2Ctornado%2Cfastapi%E7%9A%84%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[大数据flask,tornado,fastapi三个都是web框架，前两者都十分流行，后者是一个新框架。 flask是一个轻应用框架，简单好用易扩展。 tornado 是一个非阻塞的异步框架，性能高，并发高。 fastapi是一个入门简单，性能高的框架，据说可比node 和go，仅支持 python3.6及以上 fastapi的启动： from ftapistapi import FastAPI app = FastAPI() @app.get(&quot;/&quot;) async def root(): return {&quot;message&quot;: &quot;Hello World&quot;} # 启动命令 # uvicorn app:app --reload --port 5159 --host 0.0.0.0 flask的启动： from flask import Flask app = Flask(__name__) @app.route(&#39;/&#39;) def hello_world(): return &#39;Hello, World!&#39; #启动命令 # flask run --host=0.0.0.0 --port=5159 tornado的启动： import tornado.ioloop import tornado.web class MainHandler(tornado.web.RequestHandler): def get(self): self.write(&quot;Hello, world&quot;) if __name__ == &quot;__main__&quot;: application = tornado.web.Application([ (r&quot;/&quot;, MainHandler), ]) application.listen(5159) tornado.ioloop.IOLoop.current().start() #启动命令 # python app.py]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>python3</tag>
        <tag>fastapi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask,tornado,fastapi 的比较]]></title>
    <url>%2F2020%2F04%2Fothers%2Fflask%2Ctornado%2Cfastapi%E7%9A%84%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[大数据flask,tornado,fastapi三个都是web框架，前两者都十分流行，后者是一个新框架。 flask是一个轻应用框架，简单好用易扩展。 tornado 是一个非阻塞的异步框架，性能高，并发高。 fastapi是一个入门简单，性能高的框架，据说可比node 和go，仅支持 python3.6及以上 fastapi的启动： from ftapistapi import FastAPI app = FastAPI() @app.get(&quot;/&quot;) async def root(): return {&quot;message&quot;: &quot;Hello World&quot;} # 启动命令 # uvicorn app:app --reload --port 5159 --host 0.0.0.0 flask的启动： from flask import Flask app = Flask(__name__) @app.route(&#39;/&#39;) def hello_world(): return &#39;Hello, World!&#39; #启动命令 # flask run --host=0.0.0.0 --port=5159 tornado的启动： import tornado.ioloop import tornado.web class MainHandler(tornado.web.RequestHandler): def get(self): self.write(&quot;Hello, world&quot;) if __name__ == &quot;__main__&quot;: application = tornado.web.Application([ (r&quot;/&quot;, MainHandler), ]) application.listen(5159) tornado.ioloop.IOLoop.current().start() #启动命令 # python app.py]]></content>
      <categories>
        <category>其他</category>
        <category>英语</category>
      </categories>
      <tags>
        <tag>python3</tag>
        <tag>fastapi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask,tornado,fastapi 的比较]]></title>
    <url>%2F2020%2F04%2Fpython%2Fweb%2Fflask%2Ctornado%2Cfastapi%E7%9A%84%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[大数据flask,tornado,fastapi三个都是web框架，前两者都十分流行，后者是一个新框架。 flask是一个轻应用框架，简单好用易扩展。 tornado 是一个非阻塞的异步框架，性能高，并发高。 fastapi是一个入门简单，性能高的框架，据说可比node 和go，仅支持 python3.6及以上 fastapi的启动： from ftapistapi import FastAPI app = FastAPI() @app.get(&quot;/&quot;) async def root(): return {&quot;message&quot;: &quot;Hello World&quot;} # 启动命令 # uvicorn app:app --reload --port 5159 --host 0.0.0.0 flask的启动： from flask import Flask app = Flask(__name__) @app.route(&#39;/&#39;) def hello_world(): return &#39;Hello, World!&#39; #启动命令 # flask run --host=0.0.0.0 --port=5159 tornado的启动： import tornado.ioloop import tornado.web class MainHandler(tornado.web.RequestHandler): def get(self): self.write(&quot;Hello, world&quot;) if __name__ == &quot;__main__&quot;: application = tornado.web.Application([ (r&quot;/&quot;, MainHandler), ]) application.listen(5159) tornado.ioloop.IOLoop.current().start() #启动命令 # python app.py]]></content>
      <categories>
        <category>python</category>
        <category>fastapi</category>
      </categories>
      <tags>
        <tag>python3</tag>
        <tag>fastapi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[向PostgreSQL中json中加入某个字段 或者更新某个字段的SQL语句]]></title>
    <url>%2F2019%2F12%2Fdatabase%2FPostgreSql%2F20191220_%E5%AF%B9pg%E4%B8%ADjson%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%A2%9E%E5%88%A0%E6%94%B9%2F</url>
    <content type="text"><![CDATA[需求：通过SQL的方式，对JSON里面的某个字段统一处理，更新成一个新值 向PostgreSQL中json中加入某个字段。例如：向users表中id为3的data列中加入 {“uptate_data”: “7”} 执行SQL: update users set data = &#39;{&quot;uptate_data&quot;: &quot;7&quot;}&#39;::jsonb where id = 3; 执行效果如下图： 向PostgreSQL中json中更新某个字段。例如：例如：向users表中id为3的data列中再加入 {“uptate_minute”: “10”} 执行SQL: update users set data = data::jsonb || &#39;{&quot;uptate_minute&quot;: &quot;10&quot;}&#39;::jsonb where id = 3; 执行效果如下图：]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch的介绍 以及使用python操作es详细步骤]]></title>
    <url>%2F2019%2F11%2Fdatabase%2Fes%2F20191101_es%E4%BB%8B%E7%BB%8D%E5%8F%8Apyhton%E6%93%8D%E4%BD%9Ces%2F</url>
    <content type="text"><![CDATA[一. 什么是 Elasticsearch想查数据就免不了搜索，搜索就离不开搜索引擎，百度、谷歌都是一个非常庞大复杂的搜索引擎，他们几乎索引了互联网上开放的所有网页和数据。然而对于我们自己的业务数据来说，肯定就没必要用这么复杂的技术了，如果我们想实现自己的搜索引擎，方便存储和检索，Elasticsearch 就是不二选择，它是一个全文搜索引擎，可以快速地储存、搜索和分析海量数据。 Elasticsearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java语言开发的，并作为Apache许可条款下的开放源码发布，是一种流行的企业级搜索引擎。Elasticsearch用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。官方客户端在Java、.NET（C#）、PHP、Python、Apache Groovy、Ruby和许多其他语言中都是可用的。根据DB-Engines的排名显示，Elasticsearch是最受欢迎的企业搜索引擎，其次是Apache Solr，也是基于Lucene。 二. 为什么要用 ElasticsearchElasticsearch 是一个开源的搜索引擎，建立在一个全文搜索引擎库 Apache Lucene™ 基础之上。 那 Lucene 又是什么？Lucene 可能是目前存在的，不论开源还是私有的，拥有最先进，高性能和全功能搜索引擎功能的库，但也仅仅只是一个库。要用上 Lucene，我们需要编写 Java 并引用 Lucene 包才可以，而且我们需要对信息检索有一定程度的理解才能明白 Lucene 是怎么工作的，反正用起来没那么简单。 那么为了解决这个问题，Elasticsearch 就诞生了。Elasticsearch 也是使用 Java 编写的，它的内部使用 Lucene 做索引与搜索，但是它的目标是使全文检索变得简单，相当于 Lucene 的一层封装，它提供了一套简单一致的 RESTful API 来帮助我们实现存储和检索。 所以 Elasticsearch 仅仅就是一个简易版的 Lucene 封装吗？那就大错特错了，Elasticsearch 不仅仅是 Lucene，并且也不仅仅只是一个全文搜索引擎。 它可以被下面这样准确的形容： 一个分布式的实时文档存储，每个字段可以被索引与搜索 一个分布式实时分析搜索引擎 能胜任上百个服务节点的扩展，并支持 PB 级别的结构化或者非结构化数据 总之，是一个相当牛逼的搜索引擎，维基百科、Stack Overflow、GitHub 都纷纷采用它来做搜索 三. Elasticsearch 相关概念在 Elasticsearch 中有几个基本的概念，如节点、索引、文档等等，下面来分别说明一下，理解了这些概念对熟悉 Elasticsearch 是非常有帮助的。 3.1 Node 和 ClusterElasticsearch 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elasticsearch 实例。 单个 Elasticsearch 实例称为一个节点（Node）。一组节点构成一个集群（Cluster）。 3.2 IndexElasticsearch 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。 所以，Elasticsearch 数据管理的顶层单位就叫做 Index（索引），其实就相当于 MySQL、MongoDB 等里面的数据库的概念。另外值得注意的是，每个 Index （即数据库）的名字必须是小写。 3.3 DocumentIndex 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。 Document 使用 JSON 格式表示，下面是一个例子。 同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。 3.4 TypeDocument 可以分组，比如 weather 这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document，类似 MySQL 中的数据表，MongoDB 中的 Collection。 不同的 Type 应该有相似的结构（Schema），举例来说，id 字段不能在这个组是字符串，在另一个组是数值。这是与关系型数据库的表的一个区别。性质完全不同的数据（比如 products 和 logs）应该存成两个 Index，而不是一个 Index 里面的两个 Type（虽然可以做到）。 根据规划，Elastic 6.x 版只允许每个 Index 包含一个 Type，7.x 版将会彻底移除 Type。 3.5 Fields即字段，每个 Document 都类似一个 JSON 结构，它包含了许多字段，每个字段都有其对应的值，多个字段组成了一个 Document，其实就可以类比 MySQL 数据表中的字段。 在 Elasticsearch 中，文档归属于一种类型（Type），而这些类型存在于索引（Index）中，我们可以画一些简单的对比图来类比传统关系型数据库： Relational DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; Columns Elasticsearch -&gt; Indices -&gt; Types -&gt; Documents -&gt; Fields 以上就是 Elasticsearch 里面的一些基本概念，通过和关系性数据库的对比更加有助于理解。 四. Python 对接 ElasticsearchElasticsearch 实际上提供了一系列 Restful API 来进行存取和查询操作，我们可以使用 curl 等命令来进行操作，但毕竟命令行模式没那么方便，所以这里我们就直接介绍利用 Python 来对接 Elasticsearch 的相关方法。 Python 中对接 Elasticsearch 使用的就是一个同名的库，安装方式非常简单： pip3 install elasticsearch 官方文档是：https://elasticsearch-py.readthedocs.io/，所有的用法都可以在里面查到，文章后面的内容也是基于官方文档来的。 4.1 创建 Index我们先来看下怎样创建一个索引（Index），这里我们创建一个名为 news 的索引： from elasticsearch import Elasticsearch es = Elasticsearch() result = es.indices.create(index=&#39;news&#39;, ignore=400) print(result) 如果创建成功，会返回如下结果： {&#39;acknowledged&#39;: True, &#39;shards_acknowledged&#39;: True, &#39;index&#39;: &#39;news&#39;} 返回结果是 JSON 格式，其中的 acknowledged 字段表示创建操作执行成功。 但这时如果我们再把代码执行一次的话，就会返回如下结果： {&#39;error&#39;: {&#39;root_cause&#39;: [{&#39;type&#39;: &#39;resource_already_exists_exception&#39;, &#39;reason&#39;: &#39;index [news/QxBPZzVwQhujlPqCLjOlVg] already exists&#39;, &#39;index_uuid&#39;: &#39;QxBPZzVwQhujlPqCLjOlVg&#39;, &#39;index&#39;: &#39;news&#39;}], &#39;type&#39;: &#39;resource_already_exists_exception&#39;, &#39;reason&#39;: &#39;index [news/QxBPZzVwQhujlPqCLjOlVg] already exists&#39;, &#39;index_uuid&#39;: &#39;QxBPZzVwQhujlPqCLjOlVg&#39;, &#39;index&#39;: &#39;news&#39;}, &#39;status&#39;: 400} 它提示创建失败，status 状态码是 400，错误原因是 Index 已经存在了。 注意这里我们的代码里面使用了 ignore 参数为 400，这说明如果返回结果是 400 的话，就忽略这个错误不会报错，程序不会执行抛出异常。 假如我们不加 ignore 这个参数的话： es = Elasticsearch() result = es.indices.create(index=&#39;news&#39;) print(result) 再次执行就会报错了： raise HTTP_EXCEPTIONS.get(status_code, TransportError)(status_code, error_message, additional_info) elasticsearch.exceptions.RequestError: TransportError(400, &#39;resource_already_exists_exception&#39;, &#39;index [news/QM6yz2W8QE-bflKhc5oThw] already exists&#39;) 这样程序的执行就会出现问题，所以说，我们需要善用 ignore 参数，把一些意外情况排除，这样可以保证程序的正常执行而不会中断。 4.2 删除 Index删除 Index 也是类似的，代码如下： from elasticsearch import Elasticsearch es = Elasticsearch() result = es.indices.delete(index=&#39;news&#39;, ignore=[400, 404]) print(result) 这里也是使用了 ignore 参数，来忽略 Index 不存在而删除失败导致程序中断的问题。 如果删除成功，会输出如下结果： {&#39;acknowledged&#39;: True} 如果 Index 已经被删除，再执行删除则会输出如下结果： {&#39;error&#39;: {&#39;root_cause&#39;: [{&#39;type&#39;: &#39;index_not_found_exception&#39;, &#39;reason&#39;: &#39;no such index&#39;, &#39;resource.type&#39;: &#39;index_or_alias&#39;, &#39;resource.id&#39;: &#39;news&#39;, &#39;index_uuid&#39;: &#39;_na_&#39;, &#39;index&#39;: &#39;news&#39;}], &#39;type&#39;: &#39;index_not_found_exception&#39;, &#39;reason&#39;: &#39;no such index&#39;, &#39;resource.type&#39;: &#39;index_or_alias&#39;, &#39;resource.id&#39;: &#39;news&#39;, &#39;index_uuid&#39;: &#39;_na_&#39;, &#39;index&#39;: &#39;news&#39;}, &#39;status&#39;: 404} 这个结果表明当前 Index 不存在，删除失败，返回的结果同样是 JSON，状态码是 400，但是由于我们添加了 ignore 参数，忽略了 400 状态码，因此程序正常执行输出 JSON 结果，而不是抛出异常。 4.3 插入数据Elasticsearch 就像 MongoDB 一样，在插入数据的时候可以直接插入结构化字典数据，插入数据可以调用 create() 方法，例如这里我们插入一条新闻数据： from elasticsearch import Elasticsearch es = Elasticsearch() es.indices.create(index=&#39;news&#39;, ignore=400) data = {&#39;title&#39;: &#39;美国留给伊拉克的是个烂摊子吗&#39;, &#39;url&#39;: &#39;http://view.news.qq.com/zt2011/usa_iraq/index.htm&#39;} result = es.create(index=&#39;news&#39;, doc_type=&#39;politics&#39;, id=1, body=data) print(result) 这里我们首先声明了一条新闻数据，包括标题和链接，然后通过调用 create() 方法插入了这条数据，在调用 create() 方法时，我们传入了四个参数，index 参数代表了索引名称，doc_type 代表了文档类型，body 则代表了文档具体内容，id 则是数据的唯一标识 ID。 运行结果如下： {&#39;_index&#39;: &#39;news&#39;, &#39;_type&#39;: &#39;politics&#39;, &#39;_id&#39;: &#39;1&#39;, &#39;_version&#39;: 1, &#39;result&#39;: &#39;created&#39;, &#39;_shards&#39;: {&#39;total&#39;: 2, &#39;successful&#39;: 1, &#39;failed&#39;: 0}, &#39;_seq_no&#39;: 0, &#39;_primary_term&#39;: 1} 结果中 result 字段为 created，代表该数据插入成功。 另外其实我们也可以使用 index() 方法来插入数据，但与 create() 不同的是，create() 方法需要我们指定 id 字段来唯一标识该条数据，而 index() 方法则不需要，如果不指定 id，会自动生成一个 id，调用 index() 方法的写法如下： es.index(index=&#39;news&#39;, doc_type=&#39;politics&#39;, body=data) create() 方法内部其实也是调用了 index() 方法，是对 index() 方法的封装。 4.4 更新数据更新数据也非常简单，我们同样需要指定数据的 id 和内容，调用 update() 方法即可，代码如下： from elasticsearch import Elasticsearch es = Elasticsearch() data = { &#39;title&#39;: &#39;美国留给伊拉克的是个烂摊子吗&#39;, &#39;url&#39;: &#39;http://view.news.qq.com/zt2011/usa_iraq/index.htm&#39;, &#39;date&#39;: &#39;2011-12-16&#39; } result = es.update(index=&#39;news&#39;, doc_type=&#39;politics&#39;, body=data, id=1) print(result) 这里我们为数据增加了一个日期字段，然后调用了 update() 方法，结果如下： {&#39;_index&#39;: &#39;news&#39;, &#39;_type&#39;: &#39;politics&#39;, &#39;_id&#39;: &#39;1&#39;, &#39;_version&#39;: 2, &#39;result&#39;: &#39;updated&#39;, &#39;_shards&#39;: {&#39;total&#39;: 2, &#39;successful&#39;: 1, &#39;failed&#39;: 0}, &#39;_seq_no&#39;: 1, &#39;_primary_term&#39;: 1} 可以看到返回结果中，result 字段为 updated，即表示更新成功，另外我们还注意到有一个字段 _version，这代表更新后的版本号数，2 代表这是第二个版本，因为之前已经插入过一次数据，所以第一次插入的数据是版本 1，可以参见上例的运行结果，这次更新之后版本号就变成了 2，以后每更新一次，版本号都会加 1。 如果报错：ActionRequestValidationException[Validation Failed: 1: script or doc is missing。解决方法：body中加’doc’节点，把其他包裹起来：body={‘doc’: data} 另外更新操作其实利用 index() 方法同样可以做到，写法如下： es.index(index=&#39;news&#39;, doc_type=&#39;politics&#39;, body=data, id=1) 可以看到，index() 方法可以代替我们完成两个操作，如果数据不存在，那就执行插入操作，如果已经存在，那就执行更新操作，非常方便。 4.5 删除数据如果想删除一条数据可以调用 delete() 方法，指定需要删除的数据 id 即可，写法如下： from elasticsearch import Elasticsearch es = Elasticsearch() result = es.delete(index=&#39;news&#39;, doc_type=&#39;politics&#39;, id=1) print(result) 运行结果如下： {&#39;_index&#39;: &#39;news&#39;, &#39;_type&#39;: &#39;politics&#39;, &#39;_id&#39;: &#39;1&#39;, &#39;_version&#39;: 3, &#39;result&#39;: &#39;deleted&#39;, &#39;_shards&#39;: {&#39;total&#39;: 2, &#39;successful&#39;: 1, &#39;failed&#39;: 0}, &#39;_seq_no&#39;: 2, &#39;_primary_term&#39;: 1} 可以看到运行结果中 result 字段为 deleted，代表删除成功，_version 变成了 3，又增加了 1。 4.6 查询数据上面的几个操作都是非常简单的操作，普通的数据库如 MongoDB 都是可以完成的，看起来并没有什么了不起的，Elasticsearch 更特殊的地方在于其异常强大的检索功能。 对于中文来说，我们需要安装一个分词插件，这里使用的是 elasticsearch-analysis-ik，GitHub 链接为：https://github.com/medcl/elasticsearch-analysis-ik，这里我们使用 Elasticsearch 的另一个命令行工具 elasticsearch-plugin 来安装，这里安装的版本是 6.2.4，请确保和 Elasticsearch 的版本对应起来，命令如下： elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.8.8/elasticsearch-analysis-ik-6.8.8.zip 这里的版本号请替换成你的 Elasticsearch 的版本号。 安装之后重新启动 Elasticsearch 就可以了，它会自动加载安装好的插件。 首先我们新建一个索引并指定需要分词的字段，代码如下： from elasticsearch import Elasticsearch es = Elasticsearch() mapping = { &#39;properties&#39;: { &#39;title&#39;: { &#39;type&#39;: &#39;text&#39;, &#39;analyzer&#39;: &#39;ik_max_word&#39;, &#39;search_analyzer&#39;: &#39;ik_max_word&#39; } } } es.indices.delete(index=&#39;news&#39;, ignore=[400, 404]) es.indices.create(index=&#39;news&#39;, ignore=400) result = es.indices.put_mapping(index=&#39;news&#39;, doc_type=&#39;politics&#39;, body=mapping) print(result) 这里我们先将之前的索引删除了，然后新建了一个索引，然后更新了它的 mapping 信息，mapping 信息中指定了分词的字段，指定了字段的类型 type 为 text，分词器 analyzer 和 搜索分词器 search_analyzer 为 ik_max_word，即使用我们刚才安装的中文分词插件。如果不指定的话则使用默认的英文分词器。 接下来我们插入几条新的数据： datas = [ { &#39;title&#39;: &#39;美国留给伊拉克的是个烂摊子吗&#39;, &#39;url&#39;: &#39;http://view.news.qq.com/zt2011/usa_iraq/index.htm&#39;, &#39;date&#39;: &#39;2011-12-16&#39; }, { &#39;title&#39;: &#39;公安部：各地校车将享最高路权&#39;, &#39;url&#39;: &#39;http://www.chinanews.com/gn/2011/12-16/3536077.shtml&#39;, &#39;date&#39;: &#39;2011-12-16&#39; }, { &#39;title&#39;: &#39;中韩渔警冲突调查：韩警平均每天扣1艘中国渔船&#39;, &#39;url&#39;: &#39;https://news.qq.com/a/20111216/001044.htm&#39;, &#39;date&#39;: &#39;2011-12-17&#39; }, { &#39;title&#39;: &#39;中国驻洛杉矶领事馆遭亚裔男子枪击 嫌犯已自首&#39;, &#39;url&#39;: &#39;http://news.ifeng.com/world/detail_2011_12/16/11372558_0.shtml&#39;, &#39;date&#39;: &#39;2011-12-18&#39; } ] for data in datas: es.index(index=&#39;news&#39;, doc_type=&#39;politics&#39;, body=data) 这里我们指定了四条数据，都带有 title、url、date 字段，然后通过 index() 方法将其插入 Elasticsearch 中，索引名称为 news，类型为 politics。 接下来我们根据关键词查询一下相关内容： result = es.search(index=&#39;news&#39;, doc_type=&#39;politics&#39;) print(result) 可以看到查询出了所有插入的四条数据： { &quot;took&quot;: 0, &quot;timed_out&quot;: false, &quot;_shards&quot;: { &quot;total&quot;: 5, &quot;successful&quot;: 5, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 }, &quot;hits&quot;: { &quot;total&quot;: 4, &quot;max_score&quot;: 1.0, &quot;hits&quot;: [ { &quot;_index&quot;: &quot;news&quot;, &quot;_type&quot;: &quot;politics&quot;, &quot;_id&quot;: &quot;c05G9mQBD9BuE5fdHOUT&quot;, &quot;_score&quot;: 1.0, &quot;_source&quot;: { &quot;title&quot;: &quot;美国留给伊拉克的是个烂摊子吗&quot;, &quot;url&quot;: &quot;http://view.news.qq.com/zt2011/usa_iraq/index.htm&quot;, &quot;date&quot;: &quot;2011-12-16&quot; } }, { &quot;_index&quot;: &quot;news&quot;, &quot;_type&quot;: &quot;politics&quot;, &quot;_id&quot;: &quot;dk5G9mQBD9BuE5fdHOUm&quot;, &quot;_score&quot;: 1.0, &quot;_source&quot;: { &quot;title&quot;: &quot;中国驻洛杉矶领事馆遭亚裔男子枪击，嫌犯已自首&quot;, &quot;url&quot;: &quot;http://news.ifeng.com/world/detail_2011_12/16/11372558_0.shtml&quot;, &quot;date&quot;: &quot;2011-12-18&quot; } }, { &quot;_index&quot;: &quot;news&quot;, &quot;_type&quot;: &quot;politics&quot;, &quot;_id&quot;: &quot;dU5G9mQBD9BuE5fdHOUj&quot;, &quot;_score&quot;: 1.0, &quot;_source&quot;: { &quot;title&quot;: &quot;中韩渔警冲突调查：韩警平均每天扣1艘中国渔船&quot;, &quot;url&quot;: &quot;https://news.qq.com/a/20111216/001044.htm&quot;, &quot;date&quot;: &quot;2011-12-17&quot; } }, { &quot;_index&quot;: &quot;news&quot;, &quot;_type&quot;: &quot;politics&quot;, &quot;_id&quot;: &quot;dE5G9mQBD9BuE5fdHOUf&quot;, &quot;_score&quot;: 1.0, &quot;_source&quot;: { &quot;title&quot;: &quot;公安部：各地校车将享最高路权&quot;, &quot;url&quot;: &quot;http://www.chinanews.com/gn/2011/12-16/3536077.shtml&quot;, &quot;date&quot;: &quot;2011-12-16&quot; } } ] } } 可以看到返回结果会出现在 hits 字段里面，然后其中有 total 字段标明了查询的结果条目数，还有 max_score 代表了最大匹配分数。 另外我们还可以进行全文检索，这才是体现 Elasticsearch 搜索引擎特性的地方： dsl = { &#39;query&#39;: { &#39;match&#39;: { &#39;title&#39;: &#39;中国 领事馆&#39; } } } es = Elasticsearch() result = es.search(index=&#39;news&#39;, doc_type=&#39;politics&#39;, body=dsl) print(json.dumps(result, indent=2, ensure_ascii=False)) 这里我们使用 Elasticsearch 支持的 DSL 语句来进行查询，使用 match 指定全文检索，检索的字段是 title，内容是“中国领事馆”，搜索结果如下： { &quot;took&quot;: 1, &quot;timed_out&quot;: false, &quot;_shards&quot;: { &quot;total&quot;: 5, &quot;successful&quot;: 5, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 }, &quot;hits&quot;: { &quot;total&quot;: 2, &quot;max_score&quot;: 2.546152, &quot;hits&quot;: [ { &quot;_index&quot;: &quot;news&quot;, &quot;_type&quot;: &quot;politics&quot;, &quot;_id&quot;: &quot;dk5G9mQBD9BuE5fdHOUm&quot;, &quot;_score&quot;: 2.546152, &quot;_source&quot;: { &quot;title&quot;: &quot;中国驻洛杉矶领事馆遭亚裔男子枪击，嫌犯已自首&quot;, &quot;url&quot;: &quot;http://news.ifeng.com/world/detail_2011_12/16/11372558_0.shtml&quot;, &quot;date&quot;: &quot;2011-12-18&quot; } }, { &quot;_index&quot;: &quot;news&quot;, &quot;_type&quot;: &quot;politics&quot;, &quot;_id&quot;: &quot;dU5G9mQBD9BuE5fdHOUj&quot;, &quot;_score&quot;: 0.2876821, &quot;_source&quot;: { &quot;title&quot;: &quot;中韩渔警冲突调查：韩警平均每天扣1艘中国渔船&quot;, &quot;url&quot;: &quot;https://news.qq.com/a/20111216/001044.htm&quot;, &quot;date&quot;: &quot;2011-12-17&quot; } } ] } } 这里我们看到匹配的结果有两条，第一条的分数为 2.54，第二条的分数为 0.28，这是因为第一条匹配的数据中含有“中国”和“领事馆”两个词，第二条匹配的数据中不包含“领事馆”，但是包含了“中国”这个词，所以也被检索出来了，但是分数比较低。 因此可以看出，检索时会对对应的字段全文检索，结果还会按照检索关键词的相关性进行排序，这就是一个基本的搜索引擎雏形。 另外 Elasticsearch 还支持非常多的查询方式，详情可以参考官方文档：https://www.elastic.co/guide/en/elasticsearch/reference/6.3/query-dsl.html 以上便是对 Elasticsearch 的基本介绍以及 Python 操作 Elasticsearch 的基本用法。 五. 资料推荐另外推荐几个不错的学习站点： Elasticsearch 权威指南：https://es.xiaoleilu.com/index.html全文搜索引擎 Elasticsearch 入门教程：http://www.ruanyifeng.com/blog/2017/08/elasticsearch.htmlElastic 中文社区：https://www.elasticsearch.cn/]]></content>
      <categories>
        <category>数据库</category>
        <category>ES</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对数据库中的数据 进行增删改查用到的SQL语句]]></title>
    <url>%2F2019%2F10%2Fdatabase%2FPostgreSql%2F20191008_%E6%9B%B4%E6%94%B9%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[向表中插入一列：例如：向 top_iqiyi_info 表中增加一列 up_trend。 alter table top_iqiyi_info add up_trend Integer 向表中删除一部分数据：比如：删除一个时间段内的数据 delete from tong_info where crawled_time between &#39;2019-10-14 10:00:00&#39; and &#39;2019-10-14 12:00:00&#39;]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>PostgreSQL</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL中增加，更新或删除 数据库中原数据的内容]]></title>
    <url>%2F2019%2F09%2Fdatabase%2Fmysql%2F20190927_mysql%E6%9B%B4%E6%94%B9%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[1. 向原数据增加内容原表为： 执行sql语句： # 在name字段下数据的前面加上 ‘我的’ 字段 update person_info set name = concat(&#39;我的&#39;, name) 增加之后的结果为： 2. 修改原数据的内容语法：replace(object,search,replace) ， 把object中出现search的全部替换为replace 执行的sql: # 在name字段下， 把 ‘我’ 替换成 ‘你们’ update person_info set name = replace(name, &#39;我&#39;, &#39;你们&#39;) 3. 删除原数据的内容执行的sql如下 # 在name字段下， 把 ‘我们的’ 替换成 ‘’ update person_info set name = replace(name, &#39;你们的&#39;, &#39;&#39;) 执行的结果如下图： 注：如果想增加，更新或删除数据的部分内容，可指定要操作的字段比如： update person_info set name = replace(name, &#39;china&#39;, &#39;chinamoney&#39;) where id in (1, 2, 3)]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计每5分钟，MySQL数据库中数据的插入量]]></title>
    <url>%2F2019%2F09%2Fdatabase%2Fmysql%2F20190921_%E6%AF%8F5%E5%88%86%E9%92%9Fmysql%E7%9A%84%E6%8F%92%E5%85%A5%E9%87%8F%2F</url>
    <content type="text"><![CDATA[统计每5分钟，MySQL数据库中数据的插入量，id，start_time，end_time都在表sk_job_execution中。 SELECT time, COUNT( * ) AS num FROM ( SELECT id, DATE_FORMAT( concat( date(start_time ), &#39; &#39;, HOUR ( start_time ), &#39;:&#39;, floor( MINUTE ( start_time ) / 5 ) * 5 ), &#39;%Y-%m-%d %H:%i&#39; ) AS time FROM sk_job_execution where start_time BETWEEN &#39;2019-09-20 00:00:00&#39; and &#39;2019-09-21 10:00:00&#39; ) a GROUP BY DATE_FORMAT( time, &#39;%Y-%m-%d %H:%i&#39; ) ORDER BY time; 执行结果如下图所示：]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查询PostgreSQL占多大内存]]></title>
    <url>%2F2019%2F09%2Fdatabase%2FPostgreSql%2F20190909_%E6%9F%A5%E7%9C%8Bpg%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[select pg_size_pretty(pg_relation_size(&#39;cuiyonghua.top_iqiyi_info&#39;)); select pg_size_pretty(pg_relation_size(&#39;cuiyonghua.top_mgtv_info&#39;)); select pg_size_pretty(pg_relation_size(&#39;cuiyonghua.top_tencent_info&#39;)); select pg_size_pretty(pg_relation_size(&#39;cuiyonghua.top_zhihu_info&#39;));]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL：十八. 内部结构]]></title>
    <url>%2F2019%2F08%2Fdatabase%2FPostgreSql%2F20190827_%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[PostgreSQL的内部概述1、查询经过的路径 建立连接 分析器阶段 重写系统 规划器/优化器 执行器阶段 2、如何建立连接 PostgreSQL是用一个简单的“每用户一进程”的client/server模型来实现的。在这种模式里，一个客户端进程只与一个服务器进程连接，由于不知道具体要建立多少个连接，所以不得不利用一个主进程在每次连接请求时都派生出一个新的服务器进程来，这个主进程叫做postgres，它监听着一个特定的TCP/IP端口等待进来的连接。主进程每当检测到一个连接请求时，postgres进程派生出一个新的服务器进程。服务器进程之间使用信号灯和共享内存进行通讯，以确保在并发的数据访问过程中的数据完整性。客户端进程可以是任何理解PostgreSQL协议的程序。应用程序一旦与PostgreSQL服务器建立起来连接，客户端进程就可以向后端（服务器）进程发送查询了。查询是通过纯文本传输的，也就是说在前端（客户端）不做任何分析处理。服务器分析查询，创建执行规划，执行该规划并且通过已经建立起来的连接把检索出来的数据行返回给客户端。 3、分析器阶段 分析器分析器必须检查查询字符串的语法。如果语法正确，则创建一个分析树并将其返回，否则，将返回一个错误。实现分析器和词法器使用了著名的Unix工具yacc和lex。 转换处理分析器阶段只使用与SQL语法结构相关的固定规则来创建分析树。由于分析器不会查找任何系统表，因此它不可能理解请求查询的详细含义。在分析器技术之后，转换处理分析器传过来的分析树，再做进一步的处理，即：解析哪些查询中引用了哪个表、哪个函数、哪个操作符，最后再生成表示这个信息的数据结构，该数据结构就是查询树。 4、PostgreSQL规则系统 第一个能用的规则系统采用行级别的处理，是在执行器的深层实现的。每次访问一条独立的行时都要调用规则系统，这个规则在1995年被删除了。第二个规则系统从技术角度来说叫查询重写。重写系统是一个存在于分析器阶段和规划器/优化器之间的一个模块，目前，这个技术仍然存在。 5、规划器/优化器 规划器/优化器概述规划器/优化器的任务是创建一个优化了的执行规划。如果可能，查询优化器将检查每个可能的执行规划，最终选择运行最快的执行计划。 生成可能的规划规划器/优化器通过为扫描查询里出现的每个关系生成规划，可能的规划是由每个关系上由哪些可用的索引决定的。对一个关系总是可以进行一次顺序查找，所以总是会创建只使用顺序查找的规划。假设一个关系上定义着一个索引（例如B-tree索引），并且一条查询包含约束 relation.attribute OPR constant。如果relation.attribute碰巧匹配B-tree索引的关键字，那么将会创建另一个使用B-tree索引扫描该关系的规划。如果还有别的索引，而且查询里面的约束又和那个索引的关键字匹配，则还会生成更多的规划。 6、执行器 执行器接受规划器/优化器传过来的查询规划然后递归地处理它，抽取所需要的行集合。它实际上是一个需求拉动地流水线机制。每次调用一个规划节点的时候，它都必须给出更多的一个行，或者汇报它已经完成行的传递。执行器机制用于计算四种基本SQL查询类型，分别是SELECT、INSERT、UPDATE和DELETE。 PostgreSQL的内部系统表1、数据表 大多数数据表都是在数据库创建的过程中从模版数据库中拷贝过来的，这些表与数据库是相关的。 pg_aggregatepg_aggregate表用于存储与聚集函数有关的信息。聚集函数是对一个数值集进行操作的函数，它返回从这些值中计算出的一个数值，一般情况下，数值集通常是指每个匹配查询条件的行中的一个字段。 pg_ampg_am存储有关索引访问方法的信息，系统支持的每种索引访问方法都有一行。 pg_amoppg_amop表存储有关和索引访问方法操作符类关联的信息。如果一个操作符是一个操作符类中的成员，那么在这个表中会占据一行。 2、系统视图 pg_available_extensionspg_available_extensions视图列出了可用于安装的扩展，该视图是只读的。 pg_cursorspg_cursors列出了当前可用的游标。 pg_lockspg_locks提供有关在数据库服务器中由打开的事务持有的锁的信息。pg_locks对每个活跃的可锁定对象、请求的锁模式、以及相关的事务保存一行。 PostgreSQL的内部前端/后端协议1、概述 PostgreSQL为了可以有效地为多个客户端提供服务，服务器为每个客户端派生一个新的“后端”进程。在检测到连接请求后，马上创建一个新的子进程。不过，这些是对协议透明的。对于协议而言，术语“后端”和“服务器”是可以互换的；“前端”和“客户机”也是可以互换的。 2、消息流 在PostgreSQL内部，所有通讯都是通过一个消息流进行的。消息的第一个字节标识消息类型，后面的四个字节声明消息剩下部分的长度，这个长度包括长度域自 身，但不包括消息类型字节。剩下的消息内容由消息类型决定。因连接状态的不同，存在几种不同的子协议：启动、查询、函数调用、COPY、结束。还有用于通知响应和命令取消的特殊信息，这些特殊信息可能在启动阶段过后的任何时间产生。 3、消息数据类型 Intn(i)一个网络字节顺序的n位整数。如果声明了i，它将会出现确切的值，否则这个数值就是一个变量。 Intn[k]一个k个n位整数元素的数组，每个都是以网络字节顺序存储的。数组长度k是由消息前面的字段来判断的。3.String(s)一个以零结尾的字符串。 Byten(c)精确的n字节。如果声明了c那么它是确切的数值。 4、错误和通知消息字段 S：表示严重性。C：表示代码。M：表示消息。D：表示细节。H：表示提示。P：表示位置。Q：表示内部查询。W：表示哪里。F：表示文件。L：表示行。R：表示过程。 PostgreSQL的编码约定1、格式 代码格式使用每个制表符4列的空白，也就是说制表符不被展开为空白。每个逻辑缩进层次都是更多的一个制表符，布局规则遵循BSD传统。src/tools目录包含了适用于Emacs的示范配置文件，文本浏览工具more和less可以用下面命令调用。more -x4less -x4 2、报告服务器里的错误 在服务器代码里生成的错误、警告以及日志信息都应该用ereport来创建。每条消息都有两个必须的要素：一个严重级别（范围从DEBUG到PANIC）和一个主要消息文本。除此之外还有可选的元素，最常见的就是一个遵循SQL标准的错误标识码。ereport本身只是一个壳函数，它的存在主要是为了便于让消息生成看起来像C代码里的函数调用。ereport直接接受的唯一参数是严重级别。主消息文本和任何附加消息元素都是通过在ereport里调用辅助函数生成的。 3、错误消息风格指南 主信息简短 格式 引号 使用引号 语法和标点 大写字符与小写字符比较 避免被动语气 现代时与过去时的比较 对象类型 方括弧 组装错误信息 错误的原因消息应该总是说明为什么发生错误。 函数名不要在错误信息里包含报告过程的名字。 尽量避免的字眼尽量避免的字眼包括不能、坏的、 非法、未知等。 正确地拼写用单词的全拼。避免对单词进行缩写。 本地化错误信息文本是需要翻译成其它语言的，因此，语句应该本地化。 基因查询优化器1、作为复杂优化问题的查询处理 在所有关系型操作符里，最难处理和优化的是连接。一个查询需要回答的可选规划的数目将随着该查询包含的连接的个数呈指数增长。目前PostgreSQL优化器的实现在候选策略空间里执行一个近似穷举搜索。这个算法最早是在IBM System R database数据库中引入的，它生成一个近乎最优的连接顺序，但是如果查询中的连接增长得很大，它可能会消耗大量的时间和内存空间。这样就使普通的PostgreSQL查询优化器不适合那种连接了大量表的查询。 2、基因算法 基因算法（GA）是一种启发式的优化法，它是通过不确定的随机搜索进行操作。优化问题的集合被认为是个体组成的种群，一个个体对它的环境的适应程度由它的适应性表示。一个个体在搜索空间里的参照物用染色体表示，该染色体实际上是一套字符串。一个基因是染色体的一个片段，基因是被优化的单个参数的编码。一个基因的典型的编码可以是二进制或整数。 3、PostgreSQL里的基因查询优化（GEQO） GEQO模块是试图解决类似漫游推销员问题(TSP)的查询优化问题。可能的查询规划被当作整数字符串进行编码。每个字符串代表查询里面一个关系到下一个关系的连接的顺序。 索引访问方法接口定义1、索引的系统表记录 每个索引访问方法都在系统表 pg_am 里面用一行来描述。一个 pg_am 行的主要内容是引用 pg_proc 里面的记录，用来标识索引访问方法提供的索引访问函数。要想有真正用处，一个索引访问方法还必须有一个或多个操作符类，定义在 pg_opclass, pg_amop, pg_amproc 里面。这些记录允许规划器判断哪些查询的条件可以适用于用这个索引访问方法创建的索引。 2、索引访问方法函数 索引访问方法必须提供的索引构造和维护函数有：IndexBuildResult ambuild (Relation heapRelation, Relation indexRelation, IndexInfo indexInfo); 3、索引扫描 在一个索引扫描里，索引访问方法负责拿到匹配扫描键字的所有行。访问方法不会卷入从索引的父表中实际抓取这些行的动作中，也不会判断他们是否通过了扫描的时间条件测试或者是其它条件。一个扫描键字是如同 index_key operator constant 的 WHERE 子句的内部表现形式，这里的索引键字是索引中的一个字段，而操作符是和该索引字段相关联的操作符类的一个成员。一个索引扫描拥有零个或者多个扫描键字。 4、索引唯一性检查 PostgreSQL 使用唯一索引来强制SQL唯一约束，唯一索引实际上是不允许多条记录有相同键值的的索引。支持这个特性的访问方法要设置pg_am.amcanunique为真。目前，只有b-tree支持它。因为MVCC，必须允许重复的条目物理上存在于索引之中：该条目可能指向某个逻辑行的后面的版本。实际想强制的行为 是，任何MVCC都不能包含两条相同的索引键字。 5、索引开销估计函数 系统给amcostestimate函数一个WHERE子句的列表，这个WHERE 子句列表是系统认为可以被索引使用的东西。它必须返回访问该索引的开销估计值以及WHERE 子句的选择性。对于简单的场合，开销估计器的所有工作几乎都可以通过调用优化器里面的标准过程完成；amcostestimate 函数的目的是允许索引访问方法提供和索引类型相关的知识，这样也许可以改进标准的开销估计。 GiST索引1、GiST简介 GiST的意思是通用的搜索树(Generalized Search Tree)。它是一种平衡树结构的访问方法，在系统中起一个基础的模版，然后可以使用它实现任意索引模式。B-trees和许多其它的索引模式都可以用GiST实现。GiST的一个优点是它允许一种自定义的数据类型和合适的访问方法一起开发，并且是由该数据类型范畴里的专家，而不是数据库专家开发。 2、GiST的可扩展性 通常，实现一种新的索引访问方法意味着大量的艰苦工作。必须理解数据库的内部工作机制，比如锁的机制和预写日志。GiST接口有一个高层的抽像，只要求访问方法的实现者实现被访问的数据类型的语意。GiST层本身会处理并发，日志和搜索树结构的任务。不要把这个扩展性和其它标准搜索树的扩展性混淆在一起，比如它们所能处理的数据等方面。简单说，GiST组合了扩展性和通用性，以及代码复用和一个干净的界面。 3、实现方法 consistent。这个方法给出一个在树的数据页上的谓词p和一个用户查询q，如果对于一个给定的数据项，p和q 都很明确地不能为真，那么这个方法将返回假。union 。这个方法合并树中的信息。给出一个条目的集合，这个函数生成一个新的谓词，这个谓词对所有这些条目都为真。compress。这个方法将数据项转换成一个适合于在一个索引页里面物理存储的格式。decompress。这个方法是compress方法的反方法。把一个数据项的索引表现形式转换成可以由数据库操作的格式。penalty 。这个方法返回一个表示将新条目插入树中特定分支需要的”开销”的数值。项将会按照树中最小 penalty 的路径插下去。picksplit。如果需要分裂一个页面的时候，这个函数决定页面中哪些条目保存呆旧页面里，而哪些移动到新页面里。same。如果两个条目相同，返回真，否则返回假。 数据库的物理存储1、数据库文件布局 数据库集群所需要的所有数据都存储在集群的数据目录里，通常用环境变量PGDATA来引用。不同服务器管理的多个集群，可以在同一台机器上共存。PGDATA目录包含几个子目录以及一些控制文件。除了这些必要的东西之外，集群的配置文件postgresql、conf、 pg_hba、conf、pg_ident、conf通常也都存储在这里。 2、TOAST 由于PostgreSQL的页面大小是固定的，通常是8Kb，并且不允许行跨越多个页面，因此不可能直接存储非常大的字段值。为了突破这个限制，大的字段值被压缩或被打碎成多个物理行。这些事情对用户都是透明的，只是在后端代码上有一些小的影响，这就是TOAST。只有一部分数据类型支持TOAST。要支持TOAST，数据类型必须有变长(varlena)表现形式。TOAST并不约束剩下的表现形式。所有支持TOAST的数据类型之C级别的函数都必须仔细处理TOAST的输入值。 3、数据库分页文件 序列和TOAST的格式与普通表一样。项指的是存储在一个页面里的独立数据值。在一个表里，一个项是一个行；在一个索引里，一个项是一条索引记录。每个表和索引都以固定尺寸(通常是 8K ，但也可以在编译时选择其它尺寸)的页面数组存储。在表里，所有页面逻辑都相同，所以一个特定的项(行)可以存储在任何页面里。在索引里，第一个页面通常保留为元页面，保存着控制信息，并且依索引访问方法的不同，在索引里可能有不同类型的页面。 BKI后端接口1、BKI文件格式 BKI输入是由一系列命令组成的。命令是由一些记号组成的，具体情况则由命令语法决定。记号通常是用空白分隔的，但是如果没有歧义的话可以不要。没有什么特殊的命令分隔符。通常会把一条新的命令放在新的一行上以保持清晰。记号可以是某些关键字，特殊字符（圆括弧，逗号等），数字，或者双引号字符串。注意，所有命令都是区分大小写的。 2、BKI命令 （1） create [bootstrap] [shared_relation] [without_oids] tablename tableoid (name1 = type1 [, name2 = type2, …])（2） open tablename（3） close [tablename]（4） insert [OID = oid_value] ( value1 value2 … )（5）declare [unique] index indexname indexoid on tablename using amname ( opclass1 name1 [, …] )（6）declare toast toasttableoid toastindexoid on tablename（7）build indices 3、系统初始化的BKI文件结构 ⑴ create bootstrap其中一个关键表。⑵ insert数据，这些数据至少描述这些关键表本身。⑶ close。⑷ 重复创建和填充其它关键表。⑸ create（不带 bootstrap）一个非关键表。⑹ open。⑺ insert 需要的数据。⑻ close。⑼ 重复创建其它非关键表。⑽ 定义索引。⑾ build indices。 4、例子 下面的命令集将创建名为 test_table 的表，该表有两个类型分别为int4和text的字段cola和colb，然后向该表插入两行。create test_table 420 (cola = int4, colb = text)open test_tableinsert OID=421 ( 1 “value1” )insert OID=422 ( 2 null )close test_table 常见问题及解答]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL：十七. 服务器配置与数据库监控]]></title>
    <url>%2F2019%2F08%2Fdatabase%2FPostgreSql%2F20190825_%E9%85%8D%E7%BD%AE%E4%B8%8E%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[服务器配置1、服务器配置的文件 在数据库集群中，有3个配置文件，分别是：postgresql.conf，pg_hba.conf和pg_ident.conf。其中postgresql.conf为服务器主要的配置文件，pg_hba.conf是客户端认证配置文件，pg_ident.conf用来配置哪些操作系统用户可以映射为数据库用户。 2、连接与认证 3、资源消耗 服务器的运行会消耗一定的资源，通过设置服务器的参数，可以提示服务器的性能。包括内存、自由空间映射、内核资源使用、基于开销的清理延迟和后端写进程。 自由空间映射用于跟踪数据库中未使用空间的位置。不在映射表里面的自由空间是不能重复使用的，通过合理地设置，可以提高磁盘的利用率。 在VACUUM和ANALYZE命令执行过程中，系统维护一个内部的记数器，跟踪所执行的各种I/O操作的开销。 在PostgreSQL中，有一个独立的服务器进程，叫做后端写进程，它唯一的功能就是发出写“脏”共享缓冲区的命令。这么做的目的是让持有用户查询的服务器进程应该很少或者几乎不等待写动作的发生，因为后端写进程会做这件事情。这样的安排同样也减少了检查点造成的性能下降。 4、预写式日志 预写式日志的设置主要包括对预写式日志的基本设置、检查点设置和归档设置等。 5、查询规划 在PostgreSQL中，查询优化器选择查询规划时，有时候并不是最优的方法。数据库管理员可以通过设置配置参数，强制优化器选择一个更好的查询规划。 6、错误报告和日志 数据库管理员也许想知道错误报告和日志记录在什么地方，什么时间开始记录的和记录了什么等等。 7、运行时统计在PostgreSQL中，如果启用了统计搜集，那么生成的数据可以通过pg_stat和pg_statio系统视图查看服务器的统计信息。 8、自动清理 数据库管理员可以通过设置自动清理的缺省行为，从而提高工作效率。 9、客户端连接缺省 数据库管理员可以设置客户端连接时的语句行为、区域和格式化等。 10、锁管理在数据库系统运行的过程中，会产生各种各样的锁。管理员可以通过设置锁管理的相关参数，从而提高服务器的高可用性。 11、版本和平台兼容性PostgreSQL有很多版本，管理员可以设置各个版本之间兼容性。另外，PostgreSQL可以在不同的平台上安装，管理员可以设置各个平台之间兼容性。 监控数据库的活动1、配置统计收集器 PostgreSQL的统计收集器是一个支持收集和汇报服务器活跃性信息的子系统。目前，这个收集器可以给出对表和索引的访问计数，包括磁盘块的数量和独立行的项。PostgreSQL 还可以判断当前其它服务器进程正在执行的命令是什么。这个特性独立于统计收集器子系统，可以单独地被启用或禁用。因为统计收集给查询处理增加了一些开销，所以可以启用或禁用统计收集。这是由配置参数控制的，通常在postgresql.conf 里设置。 2、查看收集到的统计信息PostgreSQL提供了预定义的视图用于显示统计收集的结果。在使用统计观察当前系统活跃性的时候，必须意识到这些信息并不是实时更新的。每个独立的服务器进程只是在准备进入空闲状态的时候才向收集器传送新的块和行访问计数；因此正在处理的查询或者事务并不影响显示出来的总数。另外一个需要着重指出的是，在请求服务器进程显示任何这些统计信息的时候，它首先抓取收集器进程发出的最新报 告，然后就拿这些数据作为所有统计视图和函数的快照，直到它当前的事务结束。因此统计信息在当前事务的持续期间内不会改变。另外，可以使用底层的统计函数制作自定义的视图。这些底层统计访问函数和标准视图里使用的是一样的。 监控磁盘的使用1、监控磁盘的使用量 使用磁盘空间函数 使用VACUUM信息VACUUM命令回收已删除行占据的存储空间。在PostgreSQL的操作中，那些已经被删除或者更新过的行，并没有从它们所属的表中物理删除，这些数据在完成VACUUM之前它们仍然存在。因此有必要周期地运行VACUUM，特别是在经常更新的表上。VACUUM命令可以选择分析一个特定的数据表，如果没有指定数据表，VACUUM处理当前数据库里每个表。具体语法格式如下。 VACUUM [ FULL ] [ FREEZE ] [ VERBOSE ] [ table ] 2、磁盘满导致的失效一个数据库管理员最重要的磁盘监控任务就是确保磁盘不会写满。磁盘写满可能不会导致数据的丢失，但它肯定会导致系统进一步使用的问题。如果WAL文件也在同一个磁盘上(缺省配置就是这样)，则会发生数据库服务器恐慌，并且停止运行。如果不能通过删除其它东西来释放磁盘空间，那么可以通过使用表空间把一些数据库文件移动到其它文件系统上去。PostgreSQL 里的表空间允许数据库管理员在文件系统里定义那些代表数据库对象的文件存放位置。一旦创建了表空间，那么就可以在创建数据库对象的时候引用它。通过使用表空间，管理员可以控制一个PostgreSQL安装的磁盘布局。]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL：十六. 高可用、负载均衡和数据复制]]></title>
    <url>%2F2019%2F08%2Fdatabase%2FPostgreSql%2F20190824_%E9%AB%98%E5%8F%AF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[常见的数据同步解决方案 共享磁盘故障转移 文件系统复制 事务日志 基于语句的复制 异步复制 同步复制 日志传送备用服务器1、日志传送概述 使用日志传送，有以下几点好处。 无需昂贵的软件或硬件即可实现冗余故障转移系统。 备用服务器可以用于其它用途。而不必长期闲置。例如，当辅助数据库因处理进入的日志文件而处于不可访问状态时，可以在备用服务器上运行另一个独立数据库。 一旦设置好，配置成本相对低廉并且易于维护。 有非常可靠的方法用于提供数据库的冗余副本。 实现和维护配置的成本相对低廉。 支持本地位置和远程灾难恢复方案。 预写式日志（WAL）是一种实现事务日志的标准方法。通过在备用服务器上的restore_command，可以使两个服务器协同工作。它只是等候主服务器的下一个可用WAL文件。restore_command在备份服务器的recovery.conf 文件中指定。普通的恢复过程需要来自WAL归档的文件，如果无法获取则报告错误。对于备份过程来说，下一个可用WAL 件通常不能马上获取，所以必须耐心等待直到它出现。通过书写代码可以实现等待并判断下一个WAL文件是否可用的目的。同时必须有触发失效切换的机制，它应当中断restore_command，跳出循环并向备份服务器返回一个”文件未找到”的错误。这将导致备份服务器结束恢复过程并取代已失效的主服务器。 2、设置备用服务器 第一步：安装主服务器和备份服务器并尽可能保持完全相同，包括完全相同的数据库副本和 PostgreSQL版本。第二步：设置从主服务器连续归档WAL到备份服务器上的某个目录。确保主服务器上的 archive_command和 archive_timeout设置恰当。第三步：为主服务器做一个基础备份，然后在备份服务器上还原这个备份。第四步：在备份服务器上依照 WAL 归档启动恢复过程，注意在 recovery.conf 中使用正确的 restore_command 设置。 数据流的复制1、流复制概述 流复制是异步的，所以在数据同步中，会有一个小的延迟。这个延迟远小于基于文件日志传送，通常1秒内足够与负载保持均衡。流复制有以下几个优点。 流复制对于数据库性能的影响更小。 流复制相对于其他复制相比，所需的硬件成本较小。 流复制更加灵活，支持异构数据库对象的同步。 要使用流复制，建立一个基于文件的日志传送备服务器。需要注意以下设置。 将一个基于文件的日志传送备服务器转为流复制备服务器，在recovery.conf文件中设置primary_conninfo 指向主服务器。在主服务器上设置listen_addresses和身份验证选项（设置文件pg_hba.conf），因此备用服务器可以连接到在主服务器的replication数据库。 在系统上支持保持活动的的套接字选项，设置tcp_keepalives_idle，tcp_keepalives_interval和tcp_keepalives_count帮助主机及时发现断开的连接。 设置备用服务器的最大并发连接数。 当启动了备服务器并且正确设置了primary_conninfo，该备服务器在回放所有可用的WAL文件后，将连接到主服务器。如果成功建立了该连接，将在备服务器中看到WAL接收进程，并且在主服务器相应的一个WAL发送进程。 2、身份验证 设置复制的访问权限是很重要的，只有受信任的用户可以读取WAL流，因为很容易从中提取权限信息。备用服务器必须验证作为主服务器的超级用户。所以需要在主服务器上创建一个有SUPERUSER和LOGIN权限的角色 数据的同步复制1、同步复制概述 同步复制可以保证所有的数据交易被转移到一个同步的备用服务器中。在同步复制时，每次提交事务时将等待，直到收到确认提交已被写入到磁盘中，然后在主服务器和备用服务器上记录事务日志。同步复制技术的应用，可以保证主服务器不在线或者崩溃的情况下，任何已提交事务的数据都不会丢失。对于同步复制来 说，事务在返回前需要被写到两个服务器的磁盘上，因此会在响应时间上带来很大的损失。为了缓解这种情况，PostgreSQL除了像其它数据库系统一样提供同步复制功能 外，还额外提供一个可以基于每一次事务提交而做出同步或异步复制的控制功能。这将使应用开发者通过把一些不可丢失的关键数据（比如财务交易）和那些响应时间上要求高的不太关键的数据区分开，来优化系统的性能。 2、同步复制应用案例 步骤1：在主和从服务器上创建replicaton角色为repl：shell&gt;psqlode=#CREATE ROLE repl REPLICATION LOGIN PASSWORD ‘123456’步骤2：在主和从服务器上创建语言plpgsql：node=# use node;node=# create language plpgsql;步骤3：在备用服务器上修改pg_hba.conf配置：host replication replication_role 192.168.1.15/32 md5步骤4：在主服务器上备份数据库：pg_dump node &gt; node_20121120.dmp步骤5：在备用服务器恢复数据库node ：postgres=#create database node;postgres=#\qshell&gt;psql node &lt; node_20121120.dmp ;步骤6：在备用服务器的数据库/export/script目录下创建一个脚本replication.步骤7：启动脚本：./replication start步骤8：在主服务器的数据库上空表public.hxf中添加一条记录：insert into hxf(uid,uname) select 1,’tianyi’;步骤9：在主服务器的数据库查询：node=# select from hxf; uid | uname—–+————- 1 | tianyi(1 row)步骤10：在备用服务器的数据库中查询：node=# select from hxf; uid | uname—–+————- 1 | tianyi(1 row)]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL：十五. 性能优化]]></title>
    <url>%2F2019%2F08%2Fdatabase%2FPostgreSql%2F20190823_%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[优化简介： PostgreSQL优化一方面是找出系统的瓶颈，提高PostgreSQL数据库整体的性能； 另一方面，需要合理的结构设计和参数调整，以提高用户操作响应的速度； 同时还要尽可能的节省系统资源，以便系统可以提供更大负荷的服务。 PostgreSQL数据库优化是多方面的，原则是减少系统的瓶颈，减少资源的占用，增加系统的反应速度。例如： 通过优化文件系统，提高磁盘IO的读写速度； 通过优化操作系统调度策略，提高PostgreSQL的在高负荷情况下负载能力； 优化表结构、索引、查询语句等使查询响应更快。 优化查询1、分析查询语句EXPLAIN 【例15.1】使用EXPLAIN语句来分析一个查询语句，执行如下语句： EXPLAIN ANALYZE SELECT * FROM fruits; 2、索引对查询速度的影响 【例15.2】下面是查询语句中不使用索引和使用索引的对比。首先，分析未使用索引时的查询情况，EXPLAIN语句执行如下： EXPLAIN SELECT * FROM fruits WHERE f_name=&#39;apple&#39;; 然后，在fruits表的f_name字段上加上索引。执行添加索引的语句及结果如下： CREATE INDEX index_name ON fruits(f_name); 现在，再分析上面的查询语句。执行的EXPLAIN语句及结果如下： EXPLAIN ANALYZE SELECT * FROM fruits WHERE f_name=&#39;apple&#39;; 3、优化子查询 子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作。子查询虽然可以使查询语句很灵活，但执行效率不高。执行子查询时，PostgreSQL需要为内层查询语句的查询结果建立一个临时表。然后外层查询语句从临时表中查询记 录。查询完毕后，再撤销这些临时表。因此，子查询的速度会受到一定的影响。如果查询的数据量比较大，这种影响就会随之增大。 在PostgreSQL中可以使用连接（JOIN）查询来替代子查询。连接查询不需要建立临时表，其速度比子查询要快，如果查询中使用到索引的话，性能会更好。连接之所以更有效率，是因为PostgreSQL不需要在内存中创建临时表来完成查询工作。 优化数据库结构1、将字段很多的表分解成多个表 2、增加中间表 3、增加冗余字段 设计数据库表时尽量遵循范式理论的规约，尽可能少的冗余字 段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。 4、优化插入记录的速度 删除索引 使用批量插入 删除外键约束 禁止自动提交 使用COPY批量导入 5、分析表的统计信息PostgreSQL中提供了ANALYZE语句收集表内容的统计信息，然后把结果保存在系统表pg_statistic 里。【例15.3】使用ANALYZ来分析fruits表，执行的语句： ANALYZE VERBOSE fruits; 优化PostgreSQL服务器1、优化服务器硬件 配置较大的内存。足够大的内存，是提高PostgreSQL数据库性能的方法之一。内存的速度比磁盘I/0快得多，可以通过增加系统的缓冲区容量，使数据在内存中停留的时间更 长，以减少磁盘I/0。 配置高速磁盘系统，以减少读盘的等待时间，提高响应速度。 合理分布磁盘I/O，把磁盘I/O分散在多个设备上，以减少资源竞争，提高并行操作能力。 配置多处理器，PostgreSQL是多线程的数据库，多处理器可同时执行多个线程。 2、优化PostgreSQL的参数 maintenance_work_mem：在装载大量的数据的时候，临时增大maintenance_work_mem 配置变量可以改进性能。 checkpoint_segments：PostgreSQL里面装载大量的数据可以导致检查点操作比平常更加频繁发生。 effective_cache_size：此参数代表PostgreSQL能够使用的最大缓存。 max_connections： max_connections的目的是防止max_connections * work_mem超出了实际内存大小。 shared_buffers：postgresql通过shared_buffers和内核和磁盘打交道，因此应该尽量大，让更多的数据缓存在shared_buffers 中。 work_mem：postgresql在执行排序操作时，会根据work_mem的大小决定是否将一个大的结果集拆分为几个小的和work_mem查不多大小的临时文件。]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL：十四. 数据备份与还原]]></title>
    <url>%2F2019%2F08%2Fdatabase%2FPostgreSql%2F20190822_%E5%A4%87%E4%BB%BD%E8%BF%98%E5%8E%9F%2F</url>
    <content type="text"><![CDATA[数据备份1、使用pgAdmin 4 备份数据库2、使用pg_dump工具备份数据库 【例14.1】备份test数据库中的tb_emp表和tb_emp2表，输入语句如下： pg_dump -U postgres -t tb_emp -t tb_emp2 -f C:\abc\test_backup2 test 3、使用pg_dumpall工具备份整个服务器的数据 【例14.2】使用pg_dumpall备份所有的数据库，其操作和pg_dump类似，这里不再重述，输入语句如下： pg_dumpall -U postgres -f C:\abc\dball_backup 数据还原1、使用pgAdmin 4 还原数据库 2、使用psql还原数据库 psql是一个以终端为基础的PostgreSQL前端。它允许用户交互地键入查询，把它们发送给PostgreSQL服务器，然后看看查询的结果。另外，输入可以来自一个文件。 对于已经备份的包含CREATE、INSERT语句的文本文 件，可以使用psql导入到数据库中。语法格式为： psql -d test -U postgres -f C:\abc\test_backup 3、使用pg_restore快速还原数据库 pg_restore可以还原由pg_dump创建的备份文件。它将发出重新生成包括数据在内的所有用户定义类型，函数，表，索引和操作符的所有必要的命令。语法格式为： pg_restore -d test -U postgres -C C:\abc\test_backup 数据库迁移1、相同版本的PostgreSQL数据库之间的迁移：可以直接利用pgAdmin操作； 2、不同版本的PostgreSQL数据库之间的迁移 【例14.3】将www.abc.com主机上的PostgreSQL数据库全部迁移到www.bcd.com主机上。在www.abc.com主机上执行的命令如下： pg_dump -U postgres –h www.bac.com -f C:\abc\test1_backup 然后在www.abc.com主机上使用psql还原数据库文件即可。 3、不同数据库之间的迁移 迁移之前，需要了解不同数据的架构，比较他们之间的差异； 数据库迁移可以使用一些工具，如在windows系统下，可以使用Ora2pg实现Oracle数据库和PostgreSQL数据库之间的迁移。]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL：十三. PostgreSQL的用户管理]]></title>
    <url>%2F2019%2F08%2Fdatabase%2FPostgreSql%2F20190821_%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[组角色管理【例13.1】创建一个名称为post2的角色，SQL代码如下： CREATE ROLE post2; 【例13.2】查看系统中的角色，SQL代码如下： SELECT rolname FROM pg_roles; 【例13.3】修改角色post1的名称为post3。SQL语句如下： ALTER ROLE post1 RENAME TO post3; 【例13.4】删除角色post3。SQL语句如下： DROP ROLE post3; 角色的各种权限1、登录 【例13.5】创建角色post4，此角色具有登录权限。SQL语句如下： CREATE ROLE post4 LOGIN; 2超级用户 【例13.6】创建角色post5，此角色具有超级用户权限。SQL语句如下： CREATE ROLE post5 SUPERUSER; 3、创建数据库 【例13.7】创建角色post6，此角色具有创建数据库权限。SQL语句如下： CREATE ROLE post6 CREATEDB; 4、 创建角色角色要想创建角色，必须明确给出该权限（除了超级用户以外）。一旦角色具有CREATEROLE权限，即可更改和删除其他角色，还可以给其它角色赋予或者撤销成员关系。当然，如果想对超级用户进行操作，仅有此权限还不够，必须拥有SUPERUSER权限。创建具有创建角色权限的角色，SQL语法如下： CREATE ROLE name CREATEROLE; 【例13.8】创建角色post7，此角色具有创建数据库权限。SQL语句如下： CREATE ROLE post7 CREATEROLE; 5、口令在客户认证方法要求与数据库建立连接时，需要口令权限。常见的认证方法包括password、md5和crypt。创建具有口令权限的角色，SQL语法如下：CREATE ROLE name 口令认证方法 具体口令【例13.9】创建角色post8，此角色具有口令权限。SQL语句如下： CREATE ROLE post8 PASSWORD &#39;123456&#39;; 账户管理1、创建用户 【例13.10】创建用户名称为postgre02，并具有创建数据库和创建角色的权限，同时登陆密码为“123456789”。SQL语句如下： CREATE USER postgre02 PASSWORD &#39;123456789&#39; CREATEDB CREATEROLE ; 2、删除用户 【例13.11】使用DROP USER删除账户“postgre02”，SQL语句如下： DROP USER postgre02; 3、修改用户密码 【例13.12】将账户“postgre01”的密码修改为“123123”，SQL语句如下： ALTER USER postgre01 PASSWORD &#39;123123&#39;; 组角色和用户角色管理1、对组角色授权 【例13.13】给“post1”角色添加创建数据表和创建角色的权限，SQL语句如下： ALTER ROLE post1 CREATEDB CREATEROLE; 2、对用户授权 【例13.14】给“postgre01”用户添加创建数据表和创建角色的权限，SQL语句如下： ALTER USER postgre01 CREATEDB CREATEROLE; 3、收回组角色权限 【例13.15】将“post1”角色的创建数据表和创建角色权限收回，SQL语句如下： ALTER ROLE post1 NOCREATEDB NOCREATEROLE; 4、收回用户权限 【例13.16】将“postgre01”用户的创建数据表和创建角色权限收回，SQL语句如下： ALTER USER postgre01 NOCREATEDB NOCREATEROLE; 数据库权限管理1、修改数据库的拥有者 【例13.17】将“mytest”数据库的所有者修改为post1。SQL语句如下： ALTER DATABASE mytest OWNER TO post2; 2、增加用户的数据表权限 【例13.18】其中ppo1是一个现有的数据表，postgres是一个现有的用户，允许postgres更新ppo1数据表，用下面的命令更新表的权限： GRANT UPDATE ON ppo1 TO postgres; 如果将上面的语句修改为： GRANT UPDATE ON ppo1 TO PUBLIC; 则表示将数据表ppo1的更新权限赋予系统中的所有角色。如果将上面的语句修改为： GRANT ALL ON ppo1 TO postgres; 则表示把适用于该对象的所有权限都赋予用户postgres。]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL：十二. 事务处理]]></title>
    <url>%2F2019%2F08%2Fdatabase%2FPostgreSql%2F20190819_%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[PostgreSQL提供了多种数据完整性的保证机制，如约束、触发器、约束和锁管理等。 事务管理简介事务是PostgreSQL中的基本工作单元，是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个不可分割的工作单位。 事务的属性： 原子性（Atomic）:事务必须是原子工作单元；对其数据修改，要么全执行，要么全不执行。 一致性（Consistent）:事务在完成时，必须使所有的数据都保持一致状态。 隔离性（Isolated）:由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。 持久性（Durable）:事务完成之后，它对系统的影响是持久性的。 【例12.1】向person表插入3条学生记录，此时发现是不应该插入的，进行回滚操作。 BEGIN; INSERT INTO person VALUES(1003,&#39;路飞&#39;,80,&#39;10456354&#39;); INSERT INTO person VALUES(1004,&#39;张露&#39;,85,&#39;56423424&#39;); INSERT INTO person VALUES(1005,&#39;魏波&#39;,70, &#39;41242774&#39;); ROLLBACK TRANSACTION; COMMIT; 可以看到执行事务前后表中内容没有变化，这是因为事务撤销了对表的插入操作。 PostgreSQL的并发机制PostgreSQL支持多用户共享同一数据库，但是当多个用户对同一个数据库进行修改时会产生并发问题。从而产生下面的问题 脏读： 幻读； 不可重复性读取。 在PostgreSQL中，定义了4个事务隔离级别： 隔离级别 脏读 幻读 不可重复性读取 读未提交 可能 可能 可能 读已提交 不可能 可能 可能 可重复读 不可能 可能 不可能 可串行读 不可能 不可能 不可能 锁机制1、锁的类型：PostgreSQL中提供了3种锁模式，分别为SpinLock、LWLock、RegularLock。 SpinLock(自旋锁)：使用互斥信号，与操作系统和硬件环境比较密切，事务结束时不能自动释放。 LWLock（轻量级锁）：主要提供对共享存储器的数据机构的互斥访问，特点主要是有等待队列的无死锁检测。另外，事务结束时，可以自动释放LWLock锁。LWLock锁分为排他模式和共享模式。 排他模式：用于数据修改操作，如插入，更新和删除； 共享模式：用于读取数据操作，如select操作。 RegulatLock(常规锁)：为一般数据库事务管理所指的锁，主要特点为有等待队列、有死锁检测和能自动释放锁。 2、死锁： 死锁的原因： 请求与保持条件； 非剥夺条件； 循环等待条件； 互斥条件。 可能会造成死锁的资源 锁。 工作线程。 内存。 减少死锁的策略。 【例12.2】有一个现成的表person，判断此表，如果有外键，则在插入数据时使用SHARE（共享锁），事务如下： BEGIN; LOCK TABLE person IN SHARE MODE; SELECT id FROM person WHERE name = &#39;Star Wars: Episode I - The Phantom Menace&#39;; -- 如果记录没有返回则ROLLBACK INSERT INTO person_user_comments VALUES (_id_, &#39;GREAT! I was waiting for it for so long!&#39;); COMMIT; 【例12.3】如果一个表含有主键，则在删除时，进行SHARE ROW EXCLUSIVE（共享行排他锁）操作。事务如下： BEGIN; LOCK TABLE person IN SHARE ROW EXCLUSIVE MODE; DELETE FROM person_user_comments WHERE id IN (SELECT id FROM films WHERE rating &lt; 5); DELETE FROM person WHERE rating &lt; 5; COMMIT]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL：十一. 触发器]]></title>
    <url>%2F2019%2F08%2Fdatabase%2FPostgreSql%2F20190818_%E8%A7%A6%E5%8F%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[什么是触发器和触发器函数触发器：一个触发器是一种声明，告诉数据库应该在执行特定的操作时执行特定的函数。 触发器函数：是指一个没有参数并且返回trigger类型的函数。 创建触发器【例11.1】创建一个触发器，使得每次该表有新数据insert时，其中的一个时间字段uptime自动变更为当前时间。首先创建一个用于测试的数据表，SQL语句如下： CREATE TABLE timedb (uid INTEGER,gid INTEGER,uptime timestamp with time zone); 创建一个自定义触发器函数，此函数的主要是为了更新当前时间。创建的SQL语句如下： CREATE FUNCTION func_timedb() RETURNS trigger AS $func_timedb$ BEGIN If (TG_OP = &#39;UPDATE&#39;) THEN If NEW.uptime = OLD.uptime Then return null; END IF; END IF; update timedb set uptime = NOW() where uid = NEW.uid and gid = NEW.gid; return null; END; $func_timedb$ LANGUAGE plpgsql; 创建触发器，SQL语句如下： CREATE TRIGGER timedb _updateTime AFTER INSERT ON timedb FOR EACH ROW EXECUTE PROCEDURE func_timedb (); 下面开始检验触发器是否创建成功，插入数据，SQL语句如下： INSERT INTO timedb VALUES(1,3); -- 查询表中的数据，SQL语句如下： SELECT * FROM timedb； 查看和修改触发器可在pgAdmin中操作 触发器的使用【例11.2】创建一个account表，然后创建一个触发器，用于检测表account的列name的插入数据是否为空。如果为空，将弹出错误提示。首先创建用于测试的数据库，包含两个字段id和name，SQL语句如下： CREATE TABLE account( id int, name char(20) ) ; 创建触发器函数，主要为了检测插入的name字段的数据是否为空，SQL语句如下： CREATE FUNCTION account_stam() RETURNS trigger AS $account_stam$ BEGIN IF NEW.name IS NULL THEN RAISE EXCEPTION &#39;name 字段不能为空值&#39;; END IF; END; $account_stam$ LANGUAGE plpgsql; 创建一个BEFORE触发器，SQL语句如下： CREATE TRIGGER account_stamp BEFORE INSERT ON account FOR EACH ROW EXECUTE PROCEDURE account_stam(); 触发器创建后，检测是否成功。插入数据，name字段为空数据，SQL语句如下。 INSERT INTO account VALUES(10); 删除触发器【例11.3】删除一个触发器，代码如下： DROP TRIGGER timedb_updateTime ON timedb; 疑问1：使用触发器时应该注意什么问题？]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL 十. 视图]]></title>
    <url>%2F2019%2F08%2Fdatabase%2FPostgreSql%2F20190817_%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[视图概述1、视图是一个虚拟表，是从数据库中一个或多个表中导出来的表。 2、视图的作用： 简单化，经常使用的查询可以被定义为视图，用户不必为以后的操作每次指定全部的条件； 安全性，通过视图，用户只能查询和修改他们能见到的数据； 逻辑数据独立性，视图可帮助用户屏蔽真实表结构变化带来的影响。 创建视图 【例10.1】在数据t上创建一个名为view_t的视图，代码如下：首先创建基本表并插入数据，语句如下： CREATE TABLE t (quantity INT, price INT); INSERT INTO t VALUES(3, 50); 创建视图语句为： CREATE VIEW view_t AS SELECT quantity, price, quantity *price FROM t; 查看视图语句如下： SELECT * FROM view_t; 默认情况下创建的视图和基本表的字段是一样，也可以通过指定视图字段的名称来创建视图。【例10.2】在t表格上创建一个名为view_t2的视图，代码如下： CREATE VIEW view_t2(qty, price, total ) AS SELECT quantity, price, quantity *price FROM t; -- 查看view_t2视图中的数据代码如下： SELECT * FROM view_t2; 【例10.3】在表student和表stu_info上创建视图stu_glass，代码如下：首先向两个表中插入数据，输入语句如下： INSERT INTO student VALUES(1,&#39;wanglin1&#39;),(2,&#39;gaoli&#39;),(3,&#39;zhanghai&#39;); INSERT INTO stu_info VALUES(1, &#39;wuban&#39;,&#39;henan&#39;),(2,&#39;liuban&#39;,&#39;hebei&#39;),(3,&#39;qiban&#39;,&#39;shandong&#39;); 创建视图stu_glass，SQL语句如下： CREATE VIEW stu_glass (id,name, glass) AS SELECT student.s_id,student.name ,stu_info.glass FROM student ,stu_info WHERE student.s_id=stu_info.s_id; -- 查看stu_glass视图中的数据代码如下： SELECT * FROM stu_glass; 查看视图【例10.4】在views表中查看视图的详细定义，代码如下： SELECT * FROM information_schema.views; 删除视图【例10.5】删除stu_glass视图，代码如下： DROP VIEW IF EXISTS stu_glass;]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL 九. 索引]]></title>
    <url>%2F2019%2F08%2Fdatabase%2FPostgreSql%2F20190816_%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[索引简介1、索引概念：索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可以提高数据库中特定数据的查询速度。 2、索引的分类： B-tree索引：比较常用，适合处理能够按顺序存储的数据,可以使用create index创建； Hash索引：只能处理简单的等于比较； GiST索引：不是单独的一种索引类型，而是一种架构，可以在这种架构上实现很多不同的索引策略； GIN索引：是反转索引，可以处理包含多个键的值（比如数组） 3、索引的设计原则： 索引并非越多越好； 避免对经常更新的表进行过多的索引； 数据量小的表最好不要使用索引； 当唯一性是某种数据本身的特征时，指定唯一索引。 创建索引1、创建普通索引 【例9.1】在book表中的bookname字段上建立名为bknameidx的普通索引，SQL语句如下： CREATE INDEX bknameidx ON book(bookname); 语句执行完毕之后，将在book表中创建名称为bknameidx的普通索引。 2、创建唯一索引 【例9.2】在book表的bookId字段上建立名称为uniqididx 的唯一索引，SQL语句如下： CREATE UNIQUE INDEX uniqididx ON book ( bookId ); 3、创建单列索引 【例9.3】在book表的comment字段上建立单列索引，SQL语句如下： CREATE INDEX Bkcmtidx ON book(comment); 语句执行完毕之后，将在book表的comment字段上建立一个名为bkcmtidx的单列索引。 4、创建组合索引 【例9.4】在book表的authors和info字段上建立组合索引，SQL语句如下： CREATE INDEX bkauandinfoidx ON book ( authors,info); 重命名索引【例9.5】将上面修改的索引名称重新修改过来，SQL语句如下： ALTER INDEX public.bkauandinfoidxx RENAME TO bkauandinfoidx; 删除索引【例9.6】删除book表中名称为bkauandinfoidx的组合索引，SQL语句如下： DROP INDEX bkauandinfoidx;]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL 八. 查询语句]]></title>
    <url>%2F2019%2F08%2Fdatabase%2FPostgreSql%2F20190815_%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[查询语句首先定义数据表， CREATE TABLE fruits ( f_id char(10) NOT NULL, s_id INT NOT NULL, f_name char(255) NOT NULL, f_price decimal(8,2) NOT NULL, PRIMARY KEY(f_id) ); 为了演示如何使用SELECT语句，需要插入数据，现插入如下数据： INSERT INTO fruits (f_id, s_id, f_name, f_price) VALUES(&#39;a1&#39;, 101,&#39;apple&#39;,5.2), (&#39;b1&#39;,101,&#39;blackberry&#39;, 10.2), (&#39;bs1&#39;,102,&#39;orange&#39;, 11.2), (&#39;bs2&#39;,105,&#39;melon&#39;,8.2), (&#39;t1&#39;,102,&#39;banana&#39;, 10.3), (&#39;t2&#39;,102,&#39;grape&#39;, 5.3), (&#39;o2&#39;,103,&#39;coconut&#39;, 9.2), (&#39;c0&#39;,101,&#39;cherry&#39;, 3.2), (&#39;a2&#39;,103, &#39;apricot&#39;,2.2), (&#39;l2&#39;,104,&#39;lemon&#39;, 6.4), (&#39;b2&#39;,104,&#39;berry&#39;, 8.6), (&#39;m1&#39;,106,&#39;mango&#39;, 15.6), (&#39;m2&#39;,105,&#39;xbabay&#39;, 2.6), (&#39;t4&#39;,107,&#39;xbababa&#39;, 3.6), (&#39;m3&#39;,105,&#39;xxtt&#39;, 11.6), (&#39;b5&#39;,107,&#39;xxxx&#39;, 3.6); 单表查询1、查询所有字段 【例8.1】从fruits表中检索所有字段的数据，SQL语句如下： SELECT * FROM fruits; 2、查询指定字段 【例8.2】查询当前表中f_name列所有水果名称，SQL语句如下： SELECT f_name FROM fruits; 【例8.3】例如，从fruits表中获取f_name和f_price两列，SQL语句如下： SELECT f_name, f_price FROM fruits; 3、查询指定记录 【例8.4】查询价格为10.2元的水果的名称，SQL语句如下： SELECT f_name, f_price FROM fruits WHERE f_price = 10.2; 【例8.5】查找名称为“apple”的水果的价格，SQL语句如下： SELECT f_name, f_price FROM fruits WHERE f_name = &#39;apple&#39;; 【例8.6】查询价格小于10的水果的名称，SQL语句如下： SELECT f_name, f_price FROM fruits WHERE f_price &lt; 10; 4、带IN关键字的查询 【例8.7】查询s_id为101和102的记录，SQL语句如下： SELECT s_id,f_name, f_price FROM fruits WHERE s_id IN (101,102) ORDER BY f_name; 【例8.8】查询所有s_id不等于101也不等于102的记录，SQL语句如下： SELECT s_id,f_name, f_price FROM fruits WHERE s_id NOT IN (101,102) ORDER BY f_name; 5、带between and 的范围查询 【例8.9】查询价格在2.00元到10.5元之间水果名称和价格，SQL语句如下： SELECT f_name, f_price FROM fruits WHERE f_price BETWEEN 2.00 AND 10.20; 【例8.10】查询价格在2.00元到10.5元之外的水果名称和价格，SQL语句如下： SELECT f_name, f_price FROM fruits WHERE f_price NOT BETWEEN 2.00 AND 10.20; 6、带like的字符匹配查询 【例8.11】查找所有以‘b’字母开头的水果，SQL语句如下： SELECT f_id, f_name FROM fruits WHERE f_name LIKE &#39;b%&#39;; 【例8.12】在fruits表中，查询f_name中包含字母‘g’的记录，SQL语句如下： SELECT f_id, f_name FROM fruits WHERE f_name LIKE &#39;%g%&#39;; 7、查询空值 【例8.13】查询customers表中c_email为空的记录的c_id、c_name和c_email字段值，SQL语句如下： SELECT c_id, c_name,c_email FROM customers WHERE c_email IS NULL; 【例8.14】查询customers表中c_email不为空的记录的c_id、c_name和c_email字段值，SQL语句如下： SELECT c_id, c_name,c_email FROM customers WHERE c_email IS NOT NULL; 8、带and的多条件查询 【例8.15】在fruits表中查询s_id = 101，并且f_price大于5的记录价格和名称，SQL语句如下： SELECT s_id, f_price, f_name FROM fruits WHERE s_id = &#39;101&#39; AND f_price &gt;=5; 【例8.16】在fruits表中查询s_id = 101或者102，并且f_price大于5，并且f_name=‘apple’的记录的价格和名称，SQL语句如下： SELECT f_id, f_price, f_name FROM fruits WHERE s_id IN(&#39;101&#39;, &#39;102&#39;) AND f_price &gt;= 5 AND f_name = &#39;apple&#39;; 9、带or的多条件查询 【例8.17】查询s_id=101或者s_id=102的水果供应商的f_price和f_name，SQL语句如下： SELECT s_id,f_name, f_price FROM fruits WHERE s_id = 101 OR s_id = 102; 【例8.18】查询s_id=101或者s_id=102的水果供应商的f_price和f_name，SQL语句如下： SELECT s_id,f_name, f_price FROM fruits WHERE s_id IN(101,102); 10、查询结果不重复 【例8.19】查询fruits表中s_id字段的值，并返回s_id字段值不得重复，SQL语句如下： SELECT DISTINCT s_id FROM fruits; 11、对查询结果排序 【例8.20】查询fruits表的f_name字段值，并对其进行排序，SQL语句如下： SELECT f_name FROM fruits ORDER BY f_name; 【例8.21】查询fruits表中的f_name和f_price字段，先按f_name排序，再按f_price排序，SQL语句如下： SELECT f_name, f_price FROM fruits ORDER BY f_name, f_price; 【例8.22】查询fruits表中的f_name和f_price字段，对结果按f_price降序方式排序，SQL语句如下：(ASC升序排序是默认的排序方式，加不加都可以) SELECT f_name, f_price FROM fruits ORDER BY f_price DESC; 【例8.23】查询fruits表，先按f_price降序排序，再按f_name字段升序排序，SQL语句如下： SELECT f_price, f_name FROM fruits ORDER BY f_price DESC, f_name; 12、分组查询 【例8.24】根据s_id对fruits表中的数据进行分组，SQL语句如下： SELECT s_id, COUNT(*) AS Total FROM fruits GROUP BY s_id; 【例8.25】根据s_id对fruits表中的数据进行分组，并显示水果种类大于1的分组信息，SQL语句如下： SELECT s_id,COUNT(f_name) FROM fruits GROUP BY s_id HAVING COUNT(f_name)&gt;1; 【例8.26】根据s_id对fruits表中的数据进行分组，显示水果种类大于1的分组信息，并按照水果的种类排序，SQL语句如下： SELECT s_id,COUNT(f_name) FROM fruits GROUP BY s_id HAVING COUNT(f_name)&gt;1 ORDER BY COUNT(f_name); 【例8.27】显示fruits表查询结果的前4行。 SELECT * From fruits LIMIT 4; 【例8.28】在fruits表中，使用LIMIT子句，返回从第5个记录开始的，行数长度为3的记录，SQL语句如下： SELECT * From fruits LIMIT 3 OFFSET 4; 使用集合函数查询1、COUNT()函数 COUNT()函数统计数据表中包含的记录行的总数，或者根据查询结果返回的列中包含的数据行数。其使用方法有两种：⑴ COUNT(*) 计算表中总的行数，不管某列有数值或者为空值。⑵ COUNT(字段名)计算指定列下总的行数，计算时将忽略字段值为空值的行。【例8.29】查询customers表中总的行数，SQL语句如下： SELECT COUNT(*) AS cust_num FROM customers; 【例8.30】查询customers表中有电子邮箱的顾客的总数，SQL语句如下： SELECT COUNT(c_email) AS email_num FROM customers; 【例8.31】在fruits表中，使用COUNT()函数统计不同的s_id的水果种类，然后计算每个分组中的总记录数。 SELECT s_id,COUNT(f_name) FROM fruits GROUP BY s_id; 【例8.32】在fruits表中查询s_id=101的水果价格总和。SQL语句如下： SELECT SUM(f_price) AS price_total FROM fruits WHERE s_id=101; 2、SUM()函数 【例8.33】在fruits表中查询不同s_id的水果价格总和。SQL语句如下： SELECT s_id,SUM(f_price) AS price_total FROM fruits GROUP BY s_id; 3、AVG()函数 【例8.34】在fruits表中，查询s_id=103的供应商的水果价格的平均值，SQL语句如下： SELECT AVG(f_price) AS avg_price FROM fruits WHERE s_id = 103; 【例8.35】在fruits表中，查询每一个供应商的水果价格的平均值，SQL语句如下： SELECT s_id,AVG(f_price) AS avg_price FROM fruits GROUP BY s_id; 4、MAX()函数 【例8.36】在fruits表中查找市场上价格最高的水果，SQL语句如下： SELECT MAX(f_price) AS max_price FROM fruits; 【例8.37】在fruits表中查找不同供应商提供的价格最高的水果，SQL语句如下： SELECT s_id, MAX(f_price) AS max_price FROM fruits GROUP BY s_id; 【例8.38】在fruits表中查找f_name的最大值，SQL语句如下： SELECT MAX(f_name) FROM fruits; 5、MIN()函数 【例8.39】在fruits表中查找市场上水果的最低价格，SQL语句如下： SELECT MIN(f_price) AS min_price FROM fruits; 【例8.40】在fruits表中查找不同供应商提供的价格最低的水果，SQL语句如下： SELECT s_id, MIN(f_price) AS min_price FROM fruits GROUP BY s_id; 连接查询1、内连接查询（inner join） 【例8.41】在fruits表和suppliers表之间使用内连接查询。查询之前，在数据库中创建数据表suppliers，SQL语句如下： CREATE TABLE suppliers ( s_id INT PRIMARY KEY, s_name varchar(50) NOT NULL, s_city varchar(50) NOT NULL); 为了演示需要插入数据，可执行以下语句： INSERT INTO suppliers (s_id, s_name, s_city) VALUES(101,&#39;FastFruit Inc&#39;, &#39;Tianjin&#39;), (102,&#39;LT Supplies&#39;, &#39;shanghai&#39;), (103,&#39;ACME&#39;, &#39;beijing&#39;), (104,&#39;FNK Inc&#39;, &#39;zhengzhou&#39;), (105,&#39;Good Set&#39;, &#39;xinjiang&#39;), (106,&#39;Just Eat Ours&#39;, &#39;yunnan&#39;), (107,&#39;JOTO meoukou&#39;, &#39;guangdong&#39;); fruits表和suppliers表中都有相同数据类型的字段s_id，两个表通过s_id字段建立联系。接下来从fruits表中查询f_name、f_price字段，从suppliers表中查询s_id、s_name，SQL语句如下： SELECT suppliers.s_id, s_name,f_name, f_price FROM fruits ,suppliers WHERE fruits.s_id = suppliers.s_id; 【例8.42】在fruits表和suppliers表之间使用INNER JOIN语法进行内连接查询，SQL语句如下： SELECT suppliers.s_id, s_name,f_name, f_price FROM fruits INNER JOIN suppliers ON fruits.s_id = suppliers.s_id; 【例8.43】查询f_id=’a1’的水果供应商提供的其他水果种类，SQL语句如下： SELECT f1.f_id, f1.f_name FROM fruits AS f1, fruits AS f2 WHERE f1.s_id = f2.s_id AND f2.f_id = &#39;a1&#39;; 2、外连接查询 left join(左连接)：返回包括左表的所有记录和右表中连接字段相等的记录；right join(左连接)：返回包括右表的所有记录和左表中连接字段相等的记录； 在做外连接查询的案例之前，在数据库中创建数据表orders，SQL语句如下： CREATE TABLE orders ( o_num INT NULL, o_date DATE NOT NULL, c_id varchar(50) NOT NULL); 为了演示需要插入数据，可执行以下语句： INSERT INTO orders (o_num, o_date, c_id) VALUES (30001,&#39;2008-09-01 00:00:00&#39;, &#39;10001&#39;), (30002,&#39;2008-09-12 00:00:00&#39;, &#39;10003&#39;), (30003,&#39;2008-09-30 00:00:00&#39;, &#39;10004&#39;), (NULL,&#39;2008-10-03 00:00:00&#39;, &#39;10002&#39;), (30004,&#39;2008-10-03 00:00:00&#39;, &#39;NULL&#39;), (30005,&#39;2008-10-08 00:00:00&#39;, &#39;10001&#39;); 【例8.44】在customers表和orders表中，查询所有客户，包括没有订单的客户，SQL语句如下： SELECT customers.c_id, orders.o_num FROM customers LEFT OUTER JOIN orders ON customers.c_id = orders.c_id; 【例8.45】在customers表和orders表中，查询所有订单，包括没有客户的订单，SQL语句如下： SELECT customers.c_id, orders.o_num FROM customers RIGHT OUTER JOIN orders ON customers.c_id = orders.c_id; 3、复合条件连接查询 【例8.46】在customers表和orders表中，使用INNER JOIN语法查询customers表中ID为10001的客户的订单信息，SQL语句如下： SELECT customers.c_id, orders.o_num FROM customers INNER JOIN orders ON customers.c_id = orders.c_id AND customers.c_id =&#39;10001&#39;; 【例8.47】在fruits表和suppliers表之间使用INNER JOIN语法进行内连接查询，并对查询结果排序，SQL语句如下： SELECT suppliers.s_id, s_name,f_name, f_price FROM fruits INNER JOIN suppliers ON fruits.s_id = suppliers.s_id ORDER BY fruits.s_id; 子查询1、带any、some关键字的子查询 下面定义两个表tb1和tb2 CREATE table tbl1 ( num1 INT NOT NULL); CREATE table tbl2 ( num2 INT NOT NULL); 分别向两个表中插入数据， INSERT INTO tbl1 values(1), (5), (13), (27); INSERT INTO tbl2 values(6), (14), (11), (20); ANY关键字接在一个比较操作符的后面，表示与子查询返回的任何值比较为TRUE，则返回TRUE。【例8.48】返回tbl2表的所有num2列，然后将tbl1中的num1的值与之进行比较，只要大于num2的任何值为符合查询条件的结果。 SELECT num1 FROM tbl1 WHERE num1 &gt; ANY (SELECT num2 FROM tbl2); 2、带ALL关键字的子查询 【例8.49】返回tbl1表的中比tbl2表num2 列所有值都大的值，SQL语句如下： SELECT num1 FROM tbl1 WHERE num1 &gt; ALL (SELECT num2 FROM tbl2); 3、带exists关键字的子查询 【例8.50】查询表suppliers表中是否存在s_id=107的供应商，如果存在则查询fruits表中的记录，SQL语句如下： SELECT * FROM fruits WHERE EXISTS (SELECT s_name FROM suppliers WHERE s_id = 107); 【例8.51】查询表suppliers表中是否存在s_id=107的供应商，如果存在则查询fruits表中的f_price大于10.20的记录，SQL语句如下： SELECT * FROM fruits WHERE f_price&gt;10.20 AND EXISTS (SELECT s_name FROM suppliers WHERE s_id = 107); 【例8.52】查询表suppliers表中是否存在s_id=107的供应商，如果不存在则查询fruits表中的记录，SQL语句如下： SELECT * FROM fruits WHERE NOT EXISTS (SELECT s_name FROM suppliers WHERE s_id = 107); 4、带in关键字的子查询 【例8.53】在customers表中查询c_name=“RedHook”的客户ID(c_id)，并根据c_id查询订单号o_num，SQL语句如下： SELECT o_num FROM orders WHERE c_id IN (SELECT c_id FROM customers WHERE c_name=&#39;RedHook&#39;); 【例8.54】与前一个例子语句类似，但是在SELECT语句中使用NOT IN操作符，SQL语句如下： SELECT o_num FROM orders WHERE c_id NOT IN (SELECT c_id FROM customers WHERE c_name=&#39;RedHook&#39;); 5、带比较运算符的子查询（&gt;,&lt;,&lt;=,=,&gt;=,!=） 【例8.55】在suppliers表中查询s_city等于“Tianjin”的供应商s_id，然后在fruits表中查询所有该供应商提供的水果的种类，SQL语句如下： SELECT s_id, f_name FROM fruits WHERE s_id = (SELECT s1.s_id FROM suppliers AS s1 WHERE s1.s_city = &#39;Tianjin&#39;); 该嵌套查询首先在suppliers表中查找s_city等于Tianjin的供应商的s_id，单独执行子查询查看s_id的值，执行下面的操作过程： SELECT s1.s_id FROM suppliers AS s1 WHERE s1.s_city = &#39;Tianjin&#39;; 然后在外层查询时，在fruits表中查找s_id等于101的供应商提供的水果的种类，SQL语句如下： SELECT s_id, f_name FROM fruits WHERE s_id = (SELECT s1.s_id FROM suppliers AS s1 WHERE s1.s_city = &#39;Tianjin&#39;); 【例8.56】在suppliers表中查询s_city等于“Tianjin”的供应商s_id，然后在fruits表中查询所有非该供应商提供的水果的种类，SQL语句如下： SELECT s_id, f_name FROM fruits WHERE s_id &lt;&gt; (SELECT s1.s_id FROM suppliers AS s1 WHERE s1.s_city = &#39;Tianjin&#39;); 合并查询结果利用UNION关键字，可以给出多条select语句，并将它们的结果组合成单个结果集。 【例8.57】查询所有价格小于9的水果的信息，查询s_id等于101和103所有的水果的信息，使用UNION连接查询结果，SQL语句如下： SELECT s_id, f_name, f_price FROM fruits WHERE f_price &lt; 9.0 UNION SELECT s_id, f_name, f_price FROM fruits WHERE s_id IN(101,103); 如前所述，UNION将多个SELECT语句的结果组合成一个结果集合。可以分开查看每个SELECT语句的结果。第1个SELECT语句如下： SELECT s_id, f_name, f_price FROM fruits WHERE f_price &lt; 9.0; 第2个SELECT语句如下： SELECT s_id, f_name, f_price FROM fruits WHERE s_id IN(101,103); 【例8.58】查询所有价格小于9的水果的信息，查询s_id等于101和103所有的水果的信息，使用UNION ALL连接查询结果，SQL语句如下： SELECT s_id, f_name, f_price FROM fruits WHERE f_price &lt; 9.0 UNION ALL SELECT s_id, f_name, f_price FROM fruits WHERE s_id IN(101,103); 为表和字段取别名1、为表取别名 【例8.59】为orders表取别名o，查询订30001订单的下单日期，SQL语句如下： SELECT * FROM orders AS o WHERE o.o_num=30001; 【例8.60】为customers和orders表分别取别名，并进行连接查询，SQL语句如下： SELECT c.c_id, o.o_num FROM customers AS c LEFT OUTER JOIN orders AS o ON c.c_id = o.c_id; 在前面介绍内连接查询时指出自连接是一种特殊的内连接，在连接查询中的两个表都是同一个表，其查询语句如下： SELECT f1.f_id, f1.f_name FROM fruits AS f1, fruits AS f2 WHERE f1.s_id = f2.s_id AND f2.f_id = &#39;a1&#39;; 2、为字段取别名 【例8.61】查询fruits表，为f_name取别名fruit_name，f_price取别名fruit_price，为fruits表取别名f1，查询表中f_price &lt; 8的水果的名称，SQL语句如下： SELECT f1.f_name AS fruit_name, f1.f_price AS fruit_price FROM fruits AS f1 WHERE f1.f_price &lt; 8; 【例8.62】查询suppliers表中字段s_name和s_city，使用CONCAT函数连接这个两个字段值，并取列别名为suppliers_title。如果没有对连接后的值取别名，其显示列名称将会不够直观，SQL语句如下： SELECT CONCAT(RTRIM(s_name) , &#39; (&#39;, RTRIM(s_city), &#39;)&#39;) FROM suppliers ORDER BY s_name; 由结果可以看到，显示结果的列名称为SELECT子句后面的计算字段，实际上计算之后的列是没有名字的，这样的结果让人很不容易理解，如果为字段取一个别名，将会使结果清晰，SQL语句如下， SELECT CONCAT(RTRIM(s_name) , &#39; (&#39;, RTRIM(s_city), &#39;)&#39;) AS suppliers_title FROM suppliers ORDER BY s_name; 使用正则表达式查询PostgreSQL中正则表达式的操作符使用方法如下： ~ 匹配正则表达式，区分大小写； ~* 匹配正则表达式，不区分大小写； !~ 不匹配正则表达式，区分大小写； ！~* 不匹配正则表达式，不区分大小写。 1、查询以特定字符或字符串开头的记录 【例8.63】在fruits表中，查询f_name字段以字母‘b’开头的记录，SQL语句如下： SELECT * FROM fruits WHERE f_name ~ &#39;^b&#39;; 【例8.64】在fruits表中，查询f_name字段以“be”开头的记录，SQL语句如下： SELECT * FROM fruits WHERE f_name ~ &#39;^be&#39;; 2、查询以特定字符或字符串结尾的记录 【例8.65】在fruits表中，查询f_name字段以字母‘t’结尾的记录，SQL语句如下： SELECT * FROM fruits WHERE f_name ~ &#39;t&#39;; fruits表中有3条记录的f_name字段值是以字母‘t’结尾，返回结果有3条记录。【例8.66】在fruits表中，查询f_name字段以字符串“rry”结尾的记录，SQL语句如下： SELECT * FROM fruits WHERE f_name ~ &#39;rry&#39;; 3、用符号“.”来替代字符串中任意一个字符 【例8.67】在fruits表中，查询f_name字段值包含字母‘a’与‘g’且两个字母之间只有一个字母的记录，SQL语句如下： SELECT * FROM fruits WHERE f_name ~ &#39;a.g&#39;; 星号‘*’匹配前面的字符任意多次，包括0次。加号‘+’匹配前面的字符至少一次。 4、使用“*”或者“+”来匹配多个字符 【例8.68】在fruits表中，查询f_name字段值以字母‘b’开头，且‘b’后面出现字母‘a’的记录，SQL语句如下： SELECT * FROM fruits WHERE f_name ~ &#39;^ba*&#39;; 【例8.69】在fruits表中，查询f_name字段值以字母‘b’开头，且‘b’后面出现字母‘a’至少一次的记录，SQL语句如下： SELECT * FROM fruits WHERE f_name ~ &#39;^ba+&#39;; 5、匹配指定字符串 【例8.70】在fruits表中，查询f_name字段值包含字符串“on”的记录，SQL语句如下： SELECT * FROM fruits WHERE f_name ~ &#39;on&#39;; 【例8.71】在fruits表中，查询f_name字段值包含字符串“on”或者“ap”的记录，SQL语句如下： SELECT * FROM fruits WHERE f_name ~ &#39;on|ap&#39;; 【例8.72】在fruits表中，使用LIKE运算符查询f_name字段值为“on”的记录，SQL语句如下： SELECT * FROM fruits WHERE f_name LIKE &#39;on&#39;; 6、匹配指定字符串的任意一个 【例8.73】在fruits表中，查找f_name字段中包含字母‘o’或者‘t’的记录，SQL语句如下： SELECT * FROM fruits WHERE f_name ~ &#39;[ot]&#39;; 7、匹配指定字符以外的字符 【例8.74】在fruits表中，查询f_id字段不包含字母a到e或数字1到2的字符的记录，SQL语句如下： SELECT * FROM fruits WHERE f_id !~ &#39;[a-e1-2]&#39;; 8、使用{M}或者{M,N}来指定字符串连续出现的次数 【例8.75】在fruits表中，查询f_name字段值出现字母‘x’至少2次的记录，SQL语句如下： SELECT * FROM fruits WHERE f_name ~ &#39;x{2,}&#39;; 【例8.76】在fruits表中，查询f_name字段值出现字符串“ba”最少1次，最多3次的记录，SQL语句如下： SELECT * FROM fruits WHERE f_name ~ &#39;ba{1,3}&#39;; 常见问题及解答]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL：七. 插入，更新与删除数据]]></title>
    <url>%2F2019%2F08%2Fdatabase%2FPostgreSql%2F20190813_%E6%8F%92%E5%85%A5%E6%9B%B4%E6%96%B0%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[插入数据1、为表的所有字段插入数据 执行插入操作之前，使用SELECT语句查看表中的数据： CREATE TABLE person( id INT NOT NULL, name CHAR(40) NOT NULL DEFAULT &#39;&#39;, age INT NOT NULL DEFAULT 0, info CHAR(50) NULL, PRIMARY KEY (id) ); SELECT * FROM person; 【例7.1】在person表中，插入一条新记录，id值为1，name值为Green，age值为21，info值为lawyer，SQL语句如下： INSERT INTO person (id ,name, age , info) VALUES (1,&#39;Green&#39;, 21, &#39;Lawyer&#39;); SELECT * FROM person; 语句执行完毕，查看执行结果： 【例7.2】在person表中，插入一条新记录，id值为2，name值为Suse，age值为22，info值为dancer，SQL语句如下： INSERT INTO person (age ,name, id , info) VALUES (22, &#39;Suse&#39;, 2, &#39;dancer&#39;); SELECT * FROM person; 【例7.3】在person表中，插入一条新记录，SQL语句如下： INSERT INTO person VALUES (3,&#39;Mary&#39;, 24, &#39;Musician&#39;); SELECT * FROM person; 2、为表的指定字段插入数据 【例7.4】在person表中，插入一条新记录，id值为4，name值为laura，age值为25，SQL语句如下： INSERT INTO person (id,name, age ) VALUES (4,&#39;Laura&#39;, 25); SELECT * FROM person; 3、同时插入多条记录 【例7.5】在person表中，在id、name、age和info字段指定插入值，同时插入3条新记录，SQL语句如下： INSERT INTO person(id,name, age, info) VALUES (5,&#39;Evans&#39;,27, &#39;secretary&#39;), (6,&#39;Dale&#39;,22, &#39;cook&#39;), (7,&#39;Edison&#39;,28, &#39;singer&#39;); SELECT * FROM person; 【例7.6】在person表中，不指定插入列表，同时插入2条新记录，SQL语句如下： INSERT INTO person VALUES (8,&#39;Harry&#39;,21, &#39;magician&#39;), (9,&#39;Harriet&#39;,19, &#39;pianist&#39;); SELECT * FROM person; 【例7.7】从person_old表中查询所有的记录，并将其插入到person表中。首先，创建一个名为person_old的数据表，其表结构与person结构相同，SQL语句如下： CREATE TABLE person_old ( id INT NOT NULL, name CHAR(40) NOT NULL DEFAULT &#39;&#39;, age INT NOT NULL DEFAULT 0, info CHAR(50) NULL, PRIMARY KEY (id) ); 向person_old表中添加两条记录： INSERT INTO person_old VALUES (10,&#39;Harry&#39;,20, &#39;student&#39;), (11,&#39;Beckham&#39;,31, &#39;police&#39;); 查询插入的记录： SELECT * FROM person_old; INSERT INTO person(id, name, age, info) SELECT id, name, age, info FROM person_old; -- 语句执行完毕，查看执行结果： SELECT * FROM person; 更新数据【例7.8】在person表中，更新id值为10的记录，将age字段值改为15，将name字段值改为LiMing。更新操作执行前可以使用SELECT语句查看当前的数据： SELECT * FROM person WHERE id=10; 由结果可以看到更新之前，id等于10的记录的name字段值为harry，age字段值为20，下面使用UPDATE语句更新数据，语句执行结果如下： UPDATE person SET age = 15, name=&#39;LiMing&#39; WHERE id = 10; -- 语句执行完毕，查看执行结果： SELECT * FROM person WHERE id=10; 【例7.9】在person表中，更新age值为19到22的记录，将info字段值都改为student。更新操作执行前可以使用SELECT语句查看当前的数据： SELECT * FROM person WHERE age BETWEEN 19 AND 22; 可以看到，这些age字段值在19到22之间的记录的info字段值各不相同。下面使用UPDATE语句更新数据，语句执行结果如下： UPDATE person SET info=&#39;student&#39; WHERE age BETWEEN 19 AND 22; -- 语句执行完毕，查看执行结果： SELECT * FROM person WHERE age BETWEEN 19 AND 22; 删除数据【例7.10】在person表中，删除id等于10的记录，SQL语句如下：执行删除操作前使用SELECT语句查看当前id=10的记录： DELETE FROM person WHERE id = 10; -- 语句执行完毕，查看执行结果： SELECT * FROM person; 【例7.11】在person表中，使用DELETE语句同时删除多条记录，在前面UPDATE语句中将age字段值在19到22之间的记录的info字段值修改为student，在这里删除这些记录。 DELETE FROM person WHERE age BETWEEN 19 AND 22; 【例7.12】删除person表中所有记录。 DELETE FROM person; -- 语句执行完毕，查看执行结果： SELECT * FROM person;]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL：六. PostgreSQL函数]]></title>
    <url>%2F2019%2F08%2Fdatabase%2FPostgreSql%2F20190811_%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[数学函数1、绝对值函数ABS(x)和返回圆周率函数PI() 【例6.1】求2，-3.3和-33的绝对值，输入语句如下： SELECT ABS(2), ABS(-3.3), ABS(-33); 【例6.2】返回圆周率值，输入语句如下： SELECT pi(); 2、平方根函数SQRT(x)和求余函数MOD(x,y) 【例6.3】求9，40和-49的二次平方根，输入语句如下： SELECT SQRT(9), SQRT(40); 【例6.4】对MOD(31,8)，MOD(234, 10)，MOD(45.5,6)进行求余运算，输入语句如下： SELECT MOD(31,8),MOD(234, 10),MOD(45.5,6); 3、获取整数的函数CEIL(x)、CEILING(x)、FLOOR(x) 【例6.5】使用CEIL和CEILING函数返回最小整数，输入语句如下： SELECT CEIL(-3.35),CEILING(3.35); FLOOR(x)返回不大于x的最大整数值，返回值转化为一个BIGINT。【例6.6】使用FLOOR函数返回最大整数，输入语句如下： SELECT FLOOR(-3.35), FLOOR(3.35); 4、四舍五入函数ROUND(x)和ROUND(x,y) 【例6.7】使用ROUND(x)函数对操作数进行四舍五入操作，输入语句如下： SELECT ROUND(-1.14),ROUND(-1.67), ROUND(1.14),ROUND(1.66); 【例6.8】使用ROUND(x,y)函数对操作数进行四舍五入操作，结果保留小数点后面指定y位，输入语句如下： SELECT ROUND(1.38, 1), ROUND(1.38, 0), ROUND(232.38, -1), ROUND (232.38,-2); 5、符号函数SIGN(x) 【例6.9】使用SIGN函数返回参数的符号，输入语句如下： SELECT SIGN(-21),SIGN(0), SIGN(21); 6、幂运算函数POW(x,y)、POWER(x,y)和EXP(x) 【例6.10】使用POW和POWER函数进行乘方运算，输入语句如下： SELECT POW(2,2), POWER(2,2),POW(2,-2), POWER(2,-2); 【例6.11】使用EXP函数计算e的乘方，输入语句如下： SELECT EXP(3),EXP(-3),EXP(0); 7、对数运算函数LOG(x) 【例6.12】使用LOG(x)函数计算自然对数，输入语句如下： SELECT LOG(3); 8、角度与弧度相互转换的函数RADIANS(x)和DEGREES(x) 【例6.13】使用RADIANS将角度转换为弧度，输入语句如下： SELECT RADIANS(90),RADIANS(180); 【例6.14】使用DEGREES将弧度转换为角度，输入语句如下： SELECT DEGREES(PI()), DEGREES(PI() / 2); 9、正弦函数SIN(x)和反正弦函数ASIN(x) 【例6.15】使用SIN函数计算正弦值，输入语句如下： SELECT SIN(1), ROUND(SIN(PI())); 【例6.16】使用ASIN函数计算反正弦值，输入语句如下： SELECT ASIN(0.8414709848078965); 10、余弦函数COS(x)反余弦函数ACOS(x) 【例6.17】使用COS函数计算余弦值，输入语句如下： SELECT COS(0),COS(PI()),COS(1); 【例6.18】使用ACOS计算反余弦值，输入语句如下： SELECT ACOS(1),ACOS(0), ROUND(ACOS(0.5403023058681398)); 11、正切函数、反正切函数和余切函数 【例6.19】使用TAN函数计算正切值，输入语句如下： SELECT TAN(0.3), ROUND(TAN(PI()/4)); 【例6.20】使用ATAN函数计算反正切值，输入语句如下： SELECT ATAN(0.30933624960962325), ATAN(1); 【例6.21】使用COT()函数计算正切值，输入语句如下， SELECT COT(0.3), 1/TAN(0.3),COT(PI() / 4); 字符串函数1、计算字符数的函数char_length(str)和字符串长度(length)的函数 【例6.21】使用CHAR_LENGTH函数计算字符串字符个数，输入语句如下： SELECT CHAR_LENGTH(&#39;date&#39;), CHAR_LENGTH(&#39;egg&#39;); 【例6.23】使用LENGTH函数计算字符串长度，输入语句如下： SELECT LENGTH(&#39;date&#39;), LENGTH(&#39;egg&#39;); 2、合并字符串CONCAT(s1,s2,…),CONCAT_WS(x,s1,s2,…) 【例6.24】使用CONCAT函数连接字符串，输入语句如下： SELECT CONCAT(&#39;PostgreSQL&#39;, &#39;9.15&#39;),CONCAT(&#39;Postgre&#39;,NULL, &#39;SQL&#39;); 【例6.25】使用CONCAT_WS函数连接带分隔符的字符串，输入语句如下： SELECT CONCAT_WS(&#39;-&#39;, &#39;1st&#39;,&#39;2nd&#39;, &#39;3rd&#39;), CONCAT_WS(&#39;*&#39;, &#39;1st&#39;, NULL, &#39;3rd&#39;); 3、获取指定长度的字符串的函数LEFT(s,n)和RIGHT(s,n) 【例6.26】使用LEFT函数返回字符串中左边的字符，输入语句如下： SELECT LEFT(&#39;football&#39;, 5); 【例6.27】使用RIGHT函数返回字符串中右边的字符，输入语句如下： SELECT RIGHT(&#39;football&#39;, 4); 4、填充字符串LPAD(s1,len,s2)和RPAD(s1,len,s2) 【例6.28】使用LPAD函数对字符串进行填充操作，输入语句如下： SELECT LPAD(&#39;hello&#39;,4,&#39;??&#39;), LPAD(&#39;hello&#39;,10,&#39;??&#39;); 【例6.29】使用LPAD函数对字符串进行填充操作，输入语句如下： SELECT RPAD(&#39;hello&#39;,4,&#39;?&#39;), RPAD(&#39;hello&#39;,10,&#39;?&#39;); 5、删除空格的函数LTRIM(s)、RTRIM(s)和TRIM(s) 【例6.30】使用LTRIM函数删除字符串左边的空格，输入语句如下： SELECT &#39;( book )&#39;,CONCAT(&#39;(&#39;,LTRIM(&#39; book &#39;),&#39;)&#39;); 【例6.31】使用LTRIM函数删除字符串右边的空格，输入语句如下： SELECT &#39;( book )&#39;,CONCAT(&#39;(&#39;, RTRIM (&#39; book &#39;),&#39;)&#39;); 【例6.32】使用TRIM函数删除指定字符串两端的空格，输入语句如下： SELECT &#39;( book )&#39;,CONCAT(&#39;(&#39;, TRIM(&#39; book &#39;),&#39;)&#39;); 6、删除指定字符串的函数TRIM(s2 from s) 【例6.33】使用TRIM(s1 FROM s)函数删除字符串中两端指定的字符，输入语句如下： SELECT TRIM(&#39;xy&#39; FROM &#39;xyboxyokxyxy&#39;) ; 7、重复生成字符串的函数REPEAT(s,n) 【例6.34】使用REPEAT函数重复生成相同的字符串，输入语句如下： SELECT REPEAT(&#39;PostgreSQL&#39;, 3); 8、替换函数REPLATE(s,s1,s2) 【例6.35】使用REPLACE函数进行字符串替代操作，输入语句如下： SELECT REPLACE(&#39;xxx.PostgreSQL.com&#39;, &#39;x&#39;, &#39;w&#39;); 9、获取指定子串的函数SUBSTRING(s,n,len) 【例6.36】使用SUBSTRING函数获取指定位置处的子字符串，输入语句如下： SELECT SUBSTRING(&#39;breakfast&#39;,5) AS col1, SUBSTRING(&#39;breakfast&#39;,5,3) AS col2, SUBSTRING(&#39;lunch&#39;, -3) AS col3, 10、匹配子串开始位置的函数POSITION(str1 in str) 【例6.37】使用POSITION函数查找字符串中指定子字符串的开始位置，输入语句如下： SELECT POSITION(&#39;ball&#39; IN &#39;football&#39;); 11、字符串逆序的函数REVERSE(s) 【例6.38】使用REVERSE函数反转字符串，输入语句如下： SELECT REVERSE(&#39;abc&#39;); 日期和时间函数1、获取当前日期的函数和当前时间的函数 【例6.39】使用日期函数获取系统当期日期，输入语句如下： SELECT CURRENT_DATE; 【例6.40】使用时间函数获取系统当期日期(返回时带时区)，输入语句如下： SELECT CURRENT_TIME; 【例6.41】使用时间函数获取系统当期日期(返回时不带时区)，输入语句如下： SELECT LOCALTIME; 2、返回当前日期和时间的函数 【例6.42】使用日期时间函数获取当前系统日期和时间，输入语句如下： SELECT CURRENT_TIMESTAMP,LOCALTIMESTAMP,NOW(); 3、获取指定值的日期 【例6.43】使用EXTRACT函数从月份中提取日期，输入语句如下： SELECT EXTRACT(DAY FROM TIMESTAMP &#39;2012-09-10 10:18:40&#39;); 【例6.44】使用EXTRACT函数从月份中提取月份，输入语句如下： SELECT EXTRACT(MONTH FROM TIMESTAMP &#39;2012-09-10 10:18:40&#39;); 【例6.45】使用EXTRACT函数从月份中提取年份，输入语句如下： SELECT EXTRACT(YEAR FROM TIMESTAMP &#39;2012-09-10 10:18:40&#39;); 【例6.46】使用EXTRACT函数查询指定日期是一年中的第几天，输入语句如下： SELECT EXTRACT(DOY FROM TIMESTAMP &#39;2012-09-10 10:18:40&#39;); 【例6.47】使用EXTRACT函数查询指定日期是一周中的星期几，输入语句如下： SELECT EXTRACT(DOW FROM TIMESTAMP &#39;2012-09-10 10:18:40&#39;); 【例6.48】使用EXTRACT函数查询指定日期是该年的第几季度(1-4)，输入语句如下： SELECT EXTRACT(QUARTER FROM TIMESTAMP &#39;2012-09-10 10:18:40&#39;); 4、日期和时间的运算操作 【例6.49】 计算指定日期加上间隔天数后的结果，输入语句如下： SELECT DATE &#39;2019-09-28&#39; + integer &#39;10&#39;; 【例6.50】 计算指定日期加上间隔小时后的结果，输入语句如下： SELECT DATE &#39;2012-09-28&#39; + interval &#39;3 hour&#39;; 【例6.51】 计算指定日期加上指定时间后的结果，输入语句如下： SELECT DATE &#39;2012-09-28&#39; + time &#39;06:00&#39;; 【例6.52】 计算指定日期和时间加上间隔时间后的结果，输入语句如下： SELECT TIMESTAMP &#39;2012-09-28 02:00:00&#39; + interval &#39;10 hours&#39;; 【例6.53】 计算指定日期之间的间隔天数，输入语句如下： SELECT date &#39;2012-11-01&#39; - date &#39;2012-09-10&#39;; 【例6.54】 计算指定日期减去间隔天数后的结果，输入语句如下： SELECT DATE &#39;2012-09-28&#39; - integer &#39;10&#39;; 【例6.55】 计算整数与天数相乘的结果，输入语句如下： SELECT 15 * interval &#39;2 day&#39;; 【例6.56】 计算整数与秒数相乘的结果，输入语句如下： SELECT 50 * interval &#39;2 second&#39;; 【例6.57】 计算小时数与整数相乘的结果，输入语句如下： SELECT interval &#39;1 hour&#39; / integer &#39;2&#39;; 条件判断函数1、CASE expr WHEN v1 THEN r1 [WHEN v2 THEN r2][ELSE rn] END;意思是如果expr的值等于某个vn，则返回对应位置THEN后面的结果，如果与所有值都不相等，则返回ELSE后面的rn。 【例6.58】使用CASE value WHEN语句执行分支操作，输入语句如下： SELECT CASE 2 WHEN 1 THEN &#39;one&#39; WHEN 2 THEN &#39;two&#39; ELSE &#39;more&#39; END; 2、CASE WHEN v1 THEN r1 [WHEN v2 THEN r2][ELSE rn] END; 【例6.59】使用CASE WHEN语句执行分支操作，输入语句如下： SELECT CASE WHEN 1&lt;0 THEN &#39;true&#39; ELSE &#39;false&#39; END; 系统信息函数1、获取PostgreSQL版本号 【例6.60】查看当前PostgreSQL版本号，输入语句如下： SELECT VERSION(); 2、获取用户名的函数 【例6.61】获取当前登陆用户名称，输入语句如下： SELECT USER, CURRENT_USER; 加密函数1、加密函数MD5(str) 【例6.62】使用MD5函数加密字符串，输入语句如下： SELECT MD5 (&#39;mypwd&#39;); 2、加密函数ENCODE(str,pswd_str) 【例6.63】使用ENCODE加密字符串，输入语句如下： SELECT ENCODE(&#39;secret&#39;,&#39;hex&#39;), LENGTH(ENCODE(&#39;secret&#39;,&#39;hex&#39;)); 3、解密函数DECODE(cypt_str,pswd_str) 【例6.64】使用DECODE函数解密被ENCODE加密的字符串，输入语句如下： SELECT DECODE(ENCODE(&#39;secret&#39;,&#39;hex&#39;),&#39;hex&#39;); 改变数据类型的函数CAST(x, AS type)函数将一个类型的值转换为另一个类型的值。 【例6.65】使用CAST函数进行数据类型的转换，将整数类型100转成两位字符串的类型10，SQL语句如下： SELECT CAST(100 AS CHAR(2)); 常见问题及解答疑问1：如何从日期时间值中获取年、月、日等部分日期或时间值？在PostgreSQL中，日期和时间是以字符串形式存储在数据表中，可以截取字符串，如dt = ‘2020-03-01 12:30:30’,则可以输入left(dt, 4)截取年份，输入mid(dt, 6, 2)截取月份，其他同理。 疑问2：如何计算年龄？年龄通过当前年龄减去出生年份来计算的。例如extract(year form m_birth)返回的结果是出生的年份，然后通过extract(year from current_date)获取当前年份，两者相减就是年龄。]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL：五. 数据类型和运算符]]></title>
    <url>%2F2019%2F08%2Fdatabase%2FPostgreSql%2F20190810_%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[PostgreSQL支持多种数据类型，主要有整数类型、浮点数类型、任意精度数值、日期/时间类型、字符串类型、二进制类型、布尔类型和数组类型等。 PostgreSQL数据类型介绍 1、数值类型：整数类型、浮点数类型、任意精度类型 1.整数类型整数类型包括：SMALLINT、INT(INTEGER)、BIGINT三种，三者在取值空间和存储范围上有所不同，不同的存储空间也决定了不同的查询效率。应根据实际需要选择最适合的类型，以在查询效率和存储空间上有所平衡。 2.浮点数类型实际工作中很多地方需要用到带小数的数值，PostgreSQL使用浮点数来表示小数。浮点数类型有两种：REAL和DOUBLE PRECISION。PostgreSQL也支持使用标准的SQL语法，即：float和float(p)来声明非精确的数值类型，p表示可接受的精度。REAL类型对应float(1)~float(24)，DOUBLE PRECISION对应float(25)~float(53)，未声明精度时将被当作DOUBLE PRECISION处理。 3.任意精度类型NUMERIC表示任意精度类型，PostgreSQL中任意精度类型可存储最多1000位精度的数字并且准确地进行计算，非常适合用于货币金额和其它要求计算准确的数据，但是，NUMERIC类型的运算速度要比整数类型或者浮点数类型要慢很多。使用格式为：NUMERIC(M,N)。其中，M称为精度，表示总位数；N称为标度，表示小数位。M和N决定了NUMERIC的取值范围，当用户数据的精度超出指定精度时，会进行四舍五入处理。 4.序号类型序号类型SERIAL和BIGSERIAL并不是真正的类型， 只是为在表中设置唯一标识做的概念上的便利。在目前的实现中，下面一句话： CREATE TABLE tablename (colname SERIAL); 等价于： CREATE SEQUENCE tablename_colname_seq; CREATE TABLE tablename( colname integer DEFAULT nextval(&#39;tablename_colname_seq&#39;) NOT NULL ); 类型名 SERIAL 和 SERIAL4 是等效的： 两个都创建 INTEGRE 字段。类型名 BIGSERIAL 和 SERIAL8 也一样，只不过它创建一个 BIGINT 字段。 如果你预计在表的生存期中使用的标识数目超过 2^31 ，那么你应该使用 BIGSERIAL。 2、日期时间类型 PostgreSQL保存日期时间格式的数据类型有多种，主要有：TIME、DATE、TIMESTAMP、INTERVAL。日期时间类型输入像字符串类型输入一样，需要加单引号。每种日期时间类型都有合法的取值范围，超出范围时系统会将”零”插入数据记录中。 1.时间类型时间类型是TIME和TIMEwith time zone，默认情况下为不带时区(即:TIME)。不带时区时间格式可接受输入方式有：HH:MM:SS、HH:MM、HHMMSS。带时间格式输入可用系统的NOW()函数。时间、时区输入参考如下。 时间输入：示例 描述04:05:06.789 ISO 860104:05:06 ISO 860104:05 ISO 8601040506 ISO 860104:05 AM 与 04:05 一样；AM 不影响数值04:05 PM 与 16:05一样；输入小时数必须 &lt;= 1204:05:06.789-8 ISO 860104:05:06-08:00 ISO 860104:05-08:00 ISO 8601040506-08 ISO 860104:05:06 PST 用名字声明的时区 时区输入：示例 描述PST 太平洋标准时间(Pacific Standard Time)-8:00 ISO-8601 与 PST 的偏移-800 ISO-8601 与 PST 的偏移-8 ISO-8601 与 PST 的偏移zulu 某军方对 UTC 的缩写z zulu的缩写 2.DATE类型DATE类型用于仅需要日期值时，日期输入格式为：YYYY-MM-DD、YYYYMMDD。输入DATE类型数据时，可以使用字符串或数字类型的数据输入，符合DATE的日期格式即可。可以使用CURRENT_DATE或NOW()插入当前系统时间。 3.TIMESTAMP类型时间戳类型的有效输入由一个日期和时间的联接组成，后面跟着一个可选的时区，一个可选的 AD 或者 BC。时间戳输入格式为：YYYY-MM-DD HH:MM:SS。带时区输入格式为：2019-03-22 4:05:06 -8:00 4.INTERVAL类型 INTERVAL类型输入格式如下：quantity unit [quantity unit…] [direction] quantity 是一个数字或符号； unit 是 second, minute, hour, day, week, month, year, decade, century, millennium, 或这些单位的缩写或复数； direction 可以是 ago 或者为空。符号 @ 是一个可选的东西。不同的单位以及相应正确的符号都是隐含地增加。 3、字符串类型、二进制类型 PostgreSQL支持两种字符型数据：文本字符串和二进制字符串。PostgreSQL提供了三种存储字符串的类型：char、varchar、text。bytea类型用于允许存储二进制字串。 1.char和varchar类型两种类型最多存储用户自定义长度N个字符。超出长度会产生错误，存储字符小于定义长度时，CHAR类型会用空格补满存储空间，VARCHAR类型只存储实际长度。 2.text类型TEXT不是标准的SQL类型，许多数据库系统都实现了这一类型，在PostgreSQL中，TEXT可存储任意长度的字符串。 3.bytea类型PostgreSQL提供了BYTEA类型，用于存储二进制字符串。BYTEA类型数据存储空间为用户实际二进制字符串加4字节。例如向file表file_byte字段插入E’\001’数据，SQL语句如下： INSERT INTO file file_byte VALUES (E&#39;\\001); 4、布尔类型、位串类型 PostgreSQL支持标准的 SQL boolean 数据类型，boolean值只能有两种： ‘真’(‘True’) 或 ‘假’(‘False’)。boolean有两种值外的第三种状态，’未知’(‘Unknow’)，用 SQL空状态表示。位串就是一串 1 和 0 的字符串。它们可以用于存储和视觉化位掩码。 布尔类型boolean类型存储空间为1字节，可接受的”真”值的有效文本输入值有：TRUE、’t’、’true’、’y’、’yes’、’1’。”假”值可接受的有效输入值有：FALSE、’f’、’false’、’n’、’no’、’0’。建议使用与SQL标准兼容的TRUE和FALSE做为boolean类型的输入值。查询时使用字母 t 和 f做为boolean型数据显示。 位串类型有两种类型的SQL位类型：bit(n) 和 bit varying(n)；bit类型的数据必须准确匹配长度n；bit varying类型数据是最大长度为n的变长类型；把一个位串值转换成bit(n)，那么它的右边将被截断或者在右边补齐零，以符合定义的n位长度，不会抛出任何错误。把一个位串数值转换成 bit varying(n)，如果它超过了n位，那么它的右边将被截断。示例：创建包括a(bit)，b(bit varying)两列表test，插入数据后执行查询，SQL语句如下： CREATE TABLE test (a bit(3), b bit varying(5)); INSERT INTO test VALUES (B&#39;101&#39;, B&#39;00&#39;); INSERT INTO test VALUES (B&#39;10&#39;::bit(3), B&#39;101&#39;); SELECT * FROM test; 5、数组类型 PostgreSQL 允许将字段定义成定长或不定长的多维数组，数组类型可以是任何基本类型或用户定义类型(复合类型和域的数组还不支持)。 数据类型定义数组类型定义是通过在数组元素类型名后面国方括号：[]来命名的。PostgreSQL目前的实现并不强制限制数组长度，即：声明长度和未声明长度的数组相同。也不强制数组维数，特定元素类型的数组都被认为是相同的类型，不管他们的大小或者维数。创建数组类型字段示例如下： CREATE TABLE array_tmp( name text, pay_by_quarter integer[], schedule text[][], squares integer[3][3] --指定长度后仍然不会限制长度 ); 数组类型数据插入数组类型数据插入用大括号把值括起来并且用逗号将它们分开。可以在任意数组值周围添加双引号，如果值包含逗号或者花括弧，必须加上双引号输入。数据类型数据插入，还可以使用ARRAY构造器。示例如下： INSERT INTO array_tmp VALUES( &#39;freeoa&#39;, &#39;{1,2,3,4}&#39;, &#39;{{"include {"},{"2value"}}&#39;, &#39;{{111,122},{211, 222}}&#39;); INSERT INTO array_tmp VALUES ( &#39;liuht&#39;, ARRAY[1,2,3,4], ARRAY[[&#39;value 11&#39;, &#39;value 12&#39;], [&#39;value 21&#39;, &#39;value 22&#39;]], ARRAY[[111,122],[211, 222]]); --使用ARRAY构造器 数组类型数据的查询和其他语言一样，PostgreSQL中数组也是通过下标数字的方式进行访问，只是PostgreSQL中数组元素的下标是从1开始n结束，格式如：[n]。对于一维或更多维数组，查询一个数组的部分数据查询格式为：[脚标界上:脚标下界]。 -- 数组下标定位查询及返回结果： SELECT name, schedule FROM array_tmp WHERE schedule[1][1]=&#39;value 11&#39;; -- 查询多维数据的部分数据， -- 如查询单维字段pay_by_quarter的第2,3列数据，及多维列schedule的第1维的1列数据和第2维第一列数据。SQL语句及查询结果如下： SELECT pay_by_quarter[2:3],schedule[1:2][1:1] FROM array_tmp; 6、复合类型 PostgreSQL复合类型描述一行或者一条记录的结构，实际上它只是一个字段名和它们的数据类型的列表。在PostgreSQL中你可以像使用简单数据类型那样使用复合类型。 常见数据类型总结表： 类型名称 存储空间 数据范围 说明 案例 SMALLINT 2字节 -32768~32767 小范围整型 如：例5.1 INT(INTEGER) 4字节 －2147483648〜2147483647 普通整型 BIGINT 8字节 -9223372036854775808〜9223372036854775807 大整数 REAL 4字节 6位十进制数字精度 浮点数类型 如：例5.2 DOUBLE PRECISION 8字节 15位十进制数字精度 双精度浮点数类型 NUMERIC(M,N) 变长 任意 任意精度类型 如：例5.3 SERIAL 4字节 1 ~ +2147483647 自增整数 BIGSERIAL 8字节 1 ~ +9223372036854775807 大范围的自增整数 TIME 8字节 00:00:00 ~ 24:00:00 时间类型(只用于一天内的时间)［无时区］ 如：例5.4和例5.5，5.6 TIME[with time zone] 12字节 00:00:00+1359~24:00:00-1359 时间类型(只用于一天内的时间)［含时区］ 例5.11 DATE 4字节 4713 BC~32767 AD 只用于一天的日期 如：例5.7，5.8，5.9 TIMESTAMP 8字节 4713 BC~5874897 AD 日期和时间［无时区］ 1毫秒/14位 如：例5.10 TIMESTAMP[with time zone] 8字节 4713 BC~5874897 AD 日期和时间［含时区］ INTERVAL 12字节 -178000000年~178000000年 时间间隔(1毫秒/14位) 4字节 YYYY-MM-DD或YYYYMMDD 日期类型 如：例5.7，5.8，5.9 char(n)/character(n) 用户定义 定长，有长度限制 varchar(n)/character varying(n) 用户定义 变长，有长度限制 如：例5.12 text 实际长度 变长，无长度限制 如：例5.13 tytea 4字节加上实际的二进制字串 变长，无长度限制 如：例5.14 boolean 1字节 ‘真’(‘True’) 或 ‘假’(‘False’) 如：例5.15 数据类型案例SQL案例：【例5.1】创建表tmp1，其中字段x，y，z，数据类型依次为SMALLINT、INT、BIGINT,SQL语句如下： CREATE TABLE tmp1 (x SMALLINT, y INT, z BIGINT ); 【例5.2】创建表tmp2，其中字段x，y，z数据类型依次为FLOAT(5)、REAL和DOUBLE PRECISION，SQL语句如下： CREATE TABLE tmp2 (x FLOAT(5), y REAL, z DOUBLE PRECISION ); 【例5.3】创建表tmp3，其中字段x，y数据类型依次为NUMERIC(5,1) 和NUMERIC (5,2)和，向表中插入数据9.12、9.15，SQL语句如下： CREATE TABLE tmp3 ( x NUMERIC (5,1), y NUMERIC (5,2)); 向表中插入数据的SQL语句如下： INSERT INTO tmp3 VALUES(9.12, 9.15); 查看表中的数据的SQL语句,可以看到PostgreSQL对插入的数据9.12进行了四舍五入的处理。【例5.4】创建数据表tmp4，定义数据类型为TIME的字段t，向表中插入值‘10:05:05’，‘23:23’。首先创建表tmp4，SQL语句如下： CREATE TABLE tmp4( t TIME ); 向表中插入数据，SQL语句如下： INSERT INTO tmp4 values(&#39;10:05:05 &#39;), (&#39;23:23&#39;); 【例5.5】表tmp4中插入值‘101112’，SQL语句如下：向表中插入数据，SQL语句如下： INSERT INTO tmp4 values(&#39;101112&#39;); 也可以使用系统日期函数向TIME字段列插入值。【例5.6】向tmp4表中插入系统当前时间，SQL语句如下：由于由时间函数获得的时间是带时区的，所以需要先将字段属性修改为带时区类型的时间： ALTER TABLE tmp4 ALTER COLUMN t TYPE time without time zone; 删除表中的数据： DELETE FROM tmp4; 向表中插入数据，SQL语句如下： INSERT INTO tmp4 values (CURRENT_TIME) ,(NOW()); 【例5.7】创建数据表tmp5，定义数据类型为DATE的字段d，向表中插入“YYYY-MM-DD”和“YYYYMMDD”字符串格式日期，SQL语句如下：首先创建表tmp5： CREATE TABLE tmp5(d DATE); 向表中插入“YYYY-MM-DD“和“YYYYMMDD”格式日期： INSERT INTO tmp5 values(&#39;1998-08-08&#39;),(&#39;19980808&#39;),(&#39;20101010&#39;); 【例5.8】向tmp5表中插入“YY-MM-DD“和“YYMMDD”字符串格式日期，SQL语句如下：首先删除表中的数据： DELETE FROM tmp5; 向表中插入“YY-MM-DD“和“YYMMDD”格式日期： INSERT INTO tmp5 values(&#39;99-09-09&#39;),( &#39;990909&#39;), ( &#39;000101&#39;) ,( &#39;121212&#39;); 【例5.9】向tmp5表中插入系统当前日期，SQL语句如下：首先删除表中的数据： DELETE FROM tmp5; 向表中插入系统当前日期： INSERT INTO tmp5 values(NOW() ); NOW()函数返回日期和时间值，在保存到数据库时，只保留了其日期部分。TIMESTAMP的日期格式为YYYY-MM-DD HH:MM:SS。在存储时需要8个字节，因此在插入数据时，要保证在合法的取值范围内。【例5.10】创建数据表tmp7，定义数据类型为TIMESTAMP的字段ts，向表中插入值 ‘1996-02-02 02:02:02’，NOW()，SQL语句如下：创建数据表和字段： CREATE TABLE tmp7( ts TIMESTAMP); 向表中插入数据： INSERT INTO tmp7 values (&#39;1996-02-02 02:02:02&#39;), ( NOW() ); 【例5.11】创建数据表tmp7h，定义数据类型为TIME的字段th，向表中插入值‘10:05:05’，‘23:23’。首先创建表tmp7h，SQL语句如下： CREATE TABLE tmp7h( t TIME with time zone); 向表中插入数据，SQL语句如下： INSERT INTO tmp7h values(&#39;10:05:05 PST &#39;), (&#39;10:05:05&#39;); 【例5.12】创建tmp8表，定义字段ch和vch数据类型依次为CHARACTER（4）、CHARACTER VARYING（4），向表中插入不同长度的字符串，SQL语句如下：创建表tmp8： CREATE TABLE tmp8( ch CHARACTER (4), vch CHARACTER VARYING (4) ); 输入数据： INSERT INTO tmp8 VALUES(&#39;ab&#39;, &#39;ab&#39;), (&#39;abcd&#39;, &#39;abcd&#39;), (&#39;ab &#39;, &#39;ab &#39;); 查询结果： SELECT concat(&#39;(&#39;, ch, &#39;)&#39;), concat(&#39;(&#39;,vch,&#39;)&#39;) FROM tmp8; 【例5.13】创建tmp9表，定义字段te数据类型依次为TEXT，向表中插入不同长度的字符串，SQL语句如下：创建表tmp9： CREATE TABLE tmp9(te TEXT); 输入数据： INSERT INTO tmp9 VALUES(&#39;ab&#39;),(&#39;abcd&#39;),(&#39;ab &#39;); 查询结果： SELECT concat(&#39;(&#39;, te, &#39;)&#39;) FROM tmp9; 【例5.15】创建表tmp11，定义BYTEA类型的字段b，向表中插入布尔型数据“TRUE”和“FALSE”。首先创建表tmp11，SQL语句如下： CREATE TABLE tmp11( b BOOLEAN ); 插入数据： INSERT INTO tmp11 VALUES(TRUE), (FALSE), (&#39;y&#39;), (&#39;no&#39;), (&#39;0&#39;); 【例5.16】创建表tmp12，定义数组类型的字段bt，向表中插入一些数组数值。首先创建表tmp12，SQL语句如下： CREATE TABLE tmp12( bt int[]); 插入数据： INSERT INTO tmp12 VALUES(&#39;{{1,1,1},{2,2,2},{3,3,3}}&#39;); 常见运算符介绍1、算数运算符：包括加（+），减（-），乘（*），除（/），求余（或模运算，%，返回余数）例5.16】创建表tmp14，定义数据类型为INT的字段num，插入值64，对num值进行算术运算：首先创建表tmp14，输入语句如下： CREATE TABLE tmp14 ( num INT); 向字段num插入数据64： INSERT INTO tmp14 VALUES (64); 接下来，对num值进行加法和减法运算： SELECT num, num+10, num-10, num+5-3, num+36.5 FROM tmp14; 【例5.17】对tmp14表中的num进行乘法，除法运算。 SELECT num, num *2, num /2, num/3, num%3 FROM tmp14; 【例5.18】用0除num。 SELECT num, num / 0, num %0 FROM tmp14; 2、比较运算符： 运算符 作用 案例 = 等于 如：例5.19 &lt;&gt;(!=) 不等于 如：例5.20 &lt;= 小于等于 如：例5.21 &gt;= 大于等于 如：例5.23 &lt; 小于 如：例5.22 &gt; 大于 如：例5.24 LEAST 有两个或多个参数时，返回最小值 如：例5.27 GREATEST 有两个或多个参数时，返回最大值 如：例5.28 BETWEEN…AND… 判断一个值是否在两个值中间 如：例5.25，5.26 IN（NOT IN） 判断一个值是IN列表中的任意一个值 如：例5.29，5.30，5.31 LIKE 通配符匹配 如：例5.32 【例5.19】使用“=”进行相等判断，SQL语句如下： SELECT 1=0, &#39;2&#39;=2, 2=2,&#39;b&#39;=&#39;b&#39;, (1+3) = (2+1),NULL=NULL; 【例5.20】使用‘&lt;&gt;’和‘!=’进行不相等的判断，SQL语句如下： SELECT &#39;good&#39;&lt;&gt;&#39;god&#39;, 1&lt;&gt;2, 4!=4, 5.5!=5, (1+3)!=(2+1),NULL&lt;&gt;NULL; 【例5.21】使用‘&lt;=’进行比较判断，SQL语句如下： SELECT &#39;good&#39;&lt;=&#39;god&#39;, 1&lt;=2, 4&lt;=4, 5.5&lt;=5, (1+3) &lt;= (2+1),NULL&lt;=NULL; 【例5.22】使用‘&lt;’进行比较判断，SQL语句如下： SELECT &#39;good&#39;&lt;&#39;god&#39;, 1&lt;2, 4&lt;4, 5.5&lt;5, (1+3) &lt; (2+1),NULL&lt;NULL; 【例5.23】使用‘&gt;=’进行比较判断，SQL语句如下： SELECT &#39;good&#39;&gt;=&#39;god&#39;, 1&gt;=2, 4&gt;=4, 5.5&gt;=5, (1+3) &gt;= (2+1),NULL&gt;=NULL; 【例5.24】使用‘&gt;’进行比较判断，SQL语句如下： SELECT &#39;good&#39;&gt;&#39;god&#39;, 1&gt;2, 4&gt;4, 5.5&gt;5, (1+3) &gt; (2+1),NULL&gt;NULL; 【例5.25】使用BETWEEN AND 进行值区间判断，输入SQL语句如下： SELECT 4 BETWEEN 2 AND 5, 4BETWEEN 4 AND 6,12 BETWEEN 9 AND 10; 【例5.26】使用BETWEEN AND 进行字符串的比较，输入SQL语句如下： SELECT &#39;x&#39; BETWEEN &#39;f&#39; AND &#39;g&#39;, &#39;b&#39; BETWEEN &#39;a&#39; AND &#39;c&#39;; 【例5.27】使用LEAST运算符进行大小判断，SQL语句如下： SELECT least(2,0), least(20.0,3.0,100.5), least(&#39;a&#39;,&#39;c&#39;,&#39;b&#39;),least(10,NULL); 【例5.28】使用GREATEST运算符进行大小判断，SQL语句如下： SELECT greatest(2,0), greatest(20.0,3.0,100.5), greatest(&#39;a&#39;,&#39;c&#39;,&#39;b&#39;),greatest(10,NULL); 【例5.29】使用NOT IN运算符进行判断，SQL语句如下： SELECT 2 IN (1,3,5,9), &#39;thks&#39; IN (&#39;lius&#39;,&#39;thks&#39;); 例5.30】使用NOT IN运算符进行判断，SQL语句如下： SELECT 2 NOT IN (1,3,5), &#39;thks&#39; NOT IN (&#39;jsi&#39;,&#39;thks&#39;); 【例5.31】存在NULL值时的IN运算，SQL语句如下： SELECT NULL IN (1,3,null),&#39;abc&#39; IN (&#39;abc&#39;, null, &#39;ded&#39;); 【例5.32】使用运算符LIKE进行字符串匹配运算，SQL语句如下： -- %匹配任何数目的字符；_只能匹配一个字符 SELECT &#39;stud&#39; LIKE &#39;stud&#39;, &#39;stud&#39; LIKE &#39;stu_&#39;,&#39;stud&#39; LIKE &#39;%d&#39;,&#39;stud&#39; LIKE &#39;t___&#39;, &#39;s&#39; LIKE NULL; 3、逻辑运算符| 运算符 | 作用 | 案例 || — | — | — || NOT | 逻辑非 | 如：例5.33 || AND | 逻辑与 | 如：例5.34 || OR | 逻辑或 | 如：例5.35 | 【例5.33】分别使用非运算符“NOT”进行逻辑判断，SQL语句如下： SELECT NOT &#39;1&#39;, NOT &#39;y&#39;, NOT &#39;0&#39;, NOT NULL, NOT &#39;n&#39;; 【例5.34】分别使用与运算符“AND”进行逻辑判断，SQL语句如下： SELECT &#39;1&#39;AND &#39;y&#39;,&#39;1&#39;AND &#39;0&#39;,&#39;1&#39;AND NULL, &#39;0&#39;AND NULL; 【例5.35】使用或运算符“OR”进行逻辑判断，SQL语句如下： SELECT &#39;1&#39; OR &#39;t&#39; OR &#39;0&#39;, &#39;1&#39;OR &#39;y&#39;,&#39;1&#39; OR NULL, &#39;0&#39;OR NULL, NULL OR NULL; 常见问题及解答疑问1：PostgreSQL可以存储文件吗？ PostgreSQL中的TEXT字段可以存储数据量较大的文件，可以使用这些数据类型存储图像，声音或者是大容量的文本内容，例如网页或者文档。但是对这些字段的处理会降低数据库的性能，如果不是非必要，可以选择只存储文件的路径。]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL：三. 数据库的基本操作]]></title>
    <url>%2F2019%2F08%2Fdatabase%2FPostgreSql%2F20190808_%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[创建数据库【例3.1】创建一个数据库名称为sample_db，数据库的属性参数采用默认的设置。 CREATE DATABASE sample_db; 修改数据库属性【例3.2】修改test数据库的名字和拥有者，输入语句如下： ALTER DATABASE mytest RENAME TO mytest1; ALTER DATABASE mytest1 OWNER TO postgres1; 删除数据库【例3.3】删除mytest1数据库，输入语句如下： DROP DATABASE mytest1; 综合案例-数据库的创建和删除 数据库的基本操作流程：步骤1：登录数据库。启动pgAdmin 4，输入密码连接服务器。步骤2：创建数据库zoo，执行过程如下。CREATE DATABASE zoo;命令执行后，刷新数据库，即可看到新创建的数据库zoo，表明语句成功执行。步骤3：选择当前数据库为zoo，右击并在弹出的快捷菜单中选择【属性】菜单命令，即可在打开的对话框中查看数据库的属性。步骤4：修改数据库的连接最大值为10，输入以下SQL语句。ALTER DATABASE zoo WITH CONNECTION LIMIT = 10;步骤5：SQL语句执行后，选择当前数据库为zoo，右击并在弹出的快捷菜单中选择【属性】菜单命令，在打开的对话框中选择【定义】选项卡，即可看到连接限制数被修改为10。步骤6：删除数据库zoo，执行SQL语句如下。DROP DATABASE zoo;语句执行完毕，将数据库zoo从系统中删除。 常见问题及解答]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL：二. PostgreSQL 11 的安装与配置]]></title>
    <url>%2F2019%2F08%2Fdatabase%2FPostgreSql%2F20190807_%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[安装与启动PostgreSQL 11安装与配置可参考官网：https://www.pgadmin.org/ Linux系统下安装Postgresql 11 Linux操作系统的发行版比较多。本章节以常用的Linux系统CentOS 7操作系统为例，讲解如何安装Postgresql 11。步骤1：创建postgres用户。[root@VMTest postgresql11]# useradd -g postgres post123步骤2：下载rpm离线安装包。下载地址如下：https://download.postgresql.org/pub/repos/yum/11/redhat/rhel-7-x86_64/需要下载的安装包如下：postgresql11-11.2-1PGDG.rhel7.x86_64.rpmpostgresql11-libs-11.2-1PGDG.rhel7.x86_64.rpmpostgresql11-server-11.2-1PGDG.rhel7.x86_64.rpm步骤3：使用rpm -ivh安装Postgresql 11的rpm包。[root@VMTest ~]# cd /home/lpf/soft/postgresql11/ #安装包存放路径[root@VMTest ~]# systemctl start postgresql-11 #启动postgresq步骤4：如果要卸载Postgresql 11，则需要先停止Postgresql服务，然后执行以下命令即可：[root@VMTest ~]# rpm -qe postgresql11-libs-11.2-1PGDG.rhel7.x86_64[root@VMTest ~]# rpm -qe postgresql11-11.2-1PGDG.rhel7.x86_64[root@VMTest ~]# rpm -qe postgresql11-server-11.2-1PGDG.rhel7.x86_64步骤5：初始化数据库。[root@VMTest ~]# /usr/pgsql-11/bin/postgresql-11-setup initdbInitializing database … OK步骤6：设置开机启动数据库。[root@VMTest ~]# systemctl enable postgresql-11 #设置开机启动[root@VMTest ~]# systemctl start postgresql-11 #启动postgresq 常见问题及解答]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL介绍]]></title>
    <url>%2F2019%2F08%2Fdatabase%2FPostgreSql%2F20190806_postgresql%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[数据库基础数据库（DataBase，DB）是一个长期存储在计算机内的、有组织的、有共享的、统一管理的数据集合。它是一个按数据结构来存储和管理数据的计算机软件系统。即数据库包含两层含义：保管数据的“仓库”以及数据管理的方法和技术。 数据库的特点包括： 实现数据共享，减少数据冗余 采用特定的数据类型； 具有较高的数据独立性； 具有统一的数据控制功能。 表：在关系数据库中，数据库表是一系列二维数组的集合，用来存储数据和操作数据的逻辑结构。它由纵向的列和横向的行组成，行被称为记录，是组织数据的单位；列被称为字段，每一列表示记录的一个属性，都有相应的描述信息，如数据类型、数据宽度等。 数据类型：决定了数据在计算机中的存储格式，代表不同的信息类型。常用的数据类型有：整数数据类型，浮点数数据类型，精确小数类型，二进制数据类型，日期/时间数据类型，字符串数据类型。 主键（PRIMARY KEY）又称主码，用于唯一地标识表中得每一条记录。可以定义表中的一列或多列为主键，主键列上没有两行相同的值，也不能为空值。假如，下表给每一个作者分配一个“编号”，该编号作为表数据表的主键，如果出现相同的值，将提示错误，系统不能确定查询的究竟是哪一条记录；如果把作者的“姓名”作为主键，则不能出现重复的名字，这与现实不相符合，因此“姓名”字段不适合做为主键。 什么是开源：PostgreSQL是一个开源数据库管理系统，那么什么是开源呢？开源是开放源码的简称，是被非赢利软件组织（美国的Open Source Initiative协会）注册为认证标记，并对其进行了正式的定义，用于描述那些源码可以被公众使用的软件，并且此软件的使用、修改和发行也不受许可证的限制。这意味着软件在提供的时候，同时提供了源码。开源许可赋予用户使用、修改和重新发布它而不需要付许可费用的权力。 数据库技术构成数据库技术构成： 数据库系统 SQL语言 数据库访问技术 1.数据库系统有3个主要的组成部分。 ⑴ 数据库：用于存储数据的地方。⑵ 数据库管理系统：用于管理数据库的软件。⑶ 数据库应用程序：为了提高数据库系统的处理能力所使用的管理 数据库的软件补充。 2.sql语言对数据库进行查询和修改操作的语言叫做SQL。SQL的含义是结构化查询语言。SQL语言包含4个部分。⑴ 数据定义语言（DDL）：DROP、CREATE、ALTER等语句。⑵ 数据操作语言（DML）：INSERT（插入）、UPDATE（修改）、DELETE（删除）语句。⑶ 数据查询语言（DQL）：SELECT语句。⑷ 数据控制语言（DCL）：GRANT、REVOKE、COMMIT、ROLLBACK等语句。 3.数据库访问技术 ODBC JDBC ADO.NET PDO 什么是PostgreSQL1.客户机-服务器软件服务器是整个应用系统资源的存储与管理中心，多个客户端则各自处理相应的功能，共同实现完整的应用。在客户/服务器结构中，客户端用户的请求被传送到数据库服务器，数据库服务器进行处理后，将结果返回给用户，从而减少了网络数据传输量。用户使用应用程序时，首先启动客户端通过有关命令告知服务器进行连接以完成各种操作，而服务器则按照此请示提供相应的服务。每一个客户端软件的实例都可以向一个服务器或应用程序服务器发出请求。 2.PostgreSQL发展历程PostgreSQL的发展历程可以追溯到1986年，加州大学伯克利分校开发一个名叫Postgres的关系数据库服务器。到了1994年，向Postgres 中增加了SQL语言的解释器，命名为Postgres95，并随后将其源代码发布到互联网上供大家使用，成为一个开放源码的数据库管理系统。到了1996年，Postgres95名称被更改为PostgreSQL，表示它支持查询语言标准，同时版本号也重新从6.0开始。自从版本6.0之后，出现了很多后续发行，在系统中也出现了很多改进。2016年9月29日，PostgreSQL全球开发组发布PostgreSQL 9.6版本，该版本允许用户纵向扩展和横向扩展来提高数据库的查询性能，同时增加了并行查询、同步复制改进、短语搜索等功能，从而使复制、聚合、索引、排序等过程变得更加高效，使其性能和可用性得到极大提高。2018年10月18日，PostgreSQL全球开发组发布PostgreSQL 11版本。 3.PostgreSQL的优势⑴ 价格⑵ 速度⑶ 容易使用⑷ 可移植性⑸ 丰富的接口⑹ 支持查询语言⑺ 相互配合的开源软件较多⑻ 安全性和连接性 网站参考 PostgreSQL中文网：http://www.postgres.cn/v2/home 源码简书：https://www.jianshu.com/p/53fe4d9475e0 个人博客参考：https://postgres.fun/20100802210528.html PostgreSQL Tutorial：https://www.postgresqltutorial.com/ 源码下载：https://git.postgresql.org/gitweb/?p=postgresql.git;a=summary 线上源码：https://doxygen.postgresql.org/ginbtree_8c.html]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL介绍]]></title>
    <url>%2F2019%2F08%2Fdatabase%2FPostgreSql%2F20190809_%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[创建数据表下面的案例是如何添加主键约束，外键约束，唯一约束，非空约束，默认约束等； 1.使用主键约束：有单字段主键，多字段联合主键；【例1】定义数据表tb_emp1，假设表中间没有主键id，为了唯一确定一个员工，可以把name、deptId联合起来做为主键，SQL语句如下： CREATE TABLE tb_emp1 ( name VARCHAR(25), deptId INT, salary FLOAT, PRIMARY KEY(name,deptId) ); 2.使用外键约束：【例2】创建一个部门表tb_dept1，名称不能为空，SQL语句如下： CREATE TABLE tb_dept2 ( id int PRIMARY KEY, name VARCHAR(22) NOT NULL, location VARCHAR(50) ); 定义数据表tb_emp2，让它的键deptId作为外键关联到tb_dept2的主键id，SQL语句为： CREATE TABLE tb_emp2 ( id INT PRIMARY KEY, name VARCHAR(25), deptId INT, salary FLOAT, CONSTRAINT fk_emp_dept2 FOREIGN KEY(deptId) REFERENCES tb_dept1(id) ); 3.使用唯一约束【例3】定义数据表tb_dept2，指定部门的名称唯一，SQL语句如下： CREATE TABLE tb_dept2 ( id INT PRIMARY KEY, name VARCHAR(22) UNIQUE, location VARCHAR(50) ); 在定义完所有列之后指定唯一约束，语法规则如下：[CONSTRAINT &lt;约束名&gt;] UNIQUE(&lt;字段名&gt;)【例4】定义数据表tb_dept3，指定部门的名称唯一，SQL语句如下： CREATE TABLE tb_dept3 ( id INT PRIMARY KEY, name VARCHAR(22), location VARCHAR(50), CONSTRAINT STH UNIQUE(name) ); 4.非空约束和默认约束【例5】定义数据表tb_emp7，指定员工的部门编号默认为1111，SQL语句如下：CREATE TABLE tb_emp7(id INT PRIMARY KEY,name VARCHAR(25) NOT NULL,deptId INT DEFAULT 1111,salary FLOAT,CONSTRAINT fk_emp_dept3 FOREIGN KEY (deptId) REFERENCES tb_dept1(id)); 修改数据表【例4.6】将数据表tb_dept3改名为tb_department3。 ALTER TABLE tb_dept3 RENAME TO tb_department3; 【例4.7】将数据表tb_dept1中name字段的数据类型由VARCHAR(22)的修改成VARCHAR(30)。 ALTER TABLE tb_dept1 ALTER COLUMN name TYPE VARCHAR(30); 【例4.8】将数据表tb_dept1中的location字段名称改为loc，数据类型保持不变，SQL语句如下： ALTER TABLE tb_dept1 RENAME location TO loc; 【例4.9】在数据表tb_dept1中添加一个没有完整性约束的INT类型的字段managerId（部门经理编号），SQL语句如下： ALTER TABLE tb_dept1 ADD COLUMN managerId INT; 【例4.10】在数据表tb_dept1中添加一个不能为空的VARCHAR(12)类型的字段column1，SQL语句如下： ALTER TABLE tb_dept1 ADD COLUMN column1 VARCHAR(12) not null; 删除数据表删除字段的语法格式如下：ALTER TABLE &lt;表名&gt; DROP &lt;字段名&gt;;“字段名”指需要从表中删除的字段的名称。【例1】删除数据表tb_dept1表中的managerid字段。 ALTER TABLE tb_dept1 DROP managerid; 【例2】删除数据表tb_emp9中的外键约束。首先创建表tb_emp9，创建外键deptId关联tb_dept1表的主键id，SQL语句如下： CREATE TABLE tb_emp9 ( id INT PRIMARY KEY, name VARCHAR(25), deptId INT, salary FLOAT, CONSTRAINT fk_emp_dept FOREIGN KEY (deptId) REFERENCES tb_dept1(id) ); ALTER TABLE tb_emp9 DROP CONSTRAINT fk_emp_dept; 【例3】删除数据表tb_dept2，SQL语句如下： DROP TABLE IF EXISTS tb_dept2; 语句执行完毕之后，数据表列表中已经不存在名称为tb_dept2的表，删除操作成功。在数据库中创建两个关联表，首先，创建表tb_dept2，SQL语句如下： CREATE TABLE tb_dept2 ( id INT PRIMARY KEY, name VARCHAR(22), location VARCHAR(50) ); 接下来创建表tb_emp，SQL语句如下： CREATE TABLE tb_emp ( id INT PRIMARY KEY, name VARCHAR(25), deptId INT, salary FLOAT, CONSTRAINT fk_emp_dept FOREIGN KEY (deptId) REFERENCES tb_dept2(id) ); 首先直接删除父表tb_dept2，输入删除语句如下： DROP TABLE tb_dept2; 接下来，解除关联子表tb_emp的外键约束，SQL语句如下： ALTER TABLE tb_emp DROP CONSTRAINT fk_emp_dept; 语句成功执行后，将取消表tb_enp和表tb_dept2之间的关联关系，此时，可以输入删除语句，将原来的父表tb_dept2删除，SQL语句如下： DROP TABLE tb_dept2; PostgreSQL 11新特性-新增带默认值的字段不在重写数据表步骤1：新增测试数据表tt，语句如下： CREATE TABLE tt(id int, name text); 步骤2：插入500万行测试数据，语句如下： INSERT INTO t1 (id,name ) SELECT n, n || &#39;_ALTER TABLE TEST &#39; FROM generate_series (1,5000000) n; 步骤3：查看数据表tt的relfilenode和relpages信息，语句如下： SELECT relname,relfilenode, relpages FROM pg_class WHERE relname=&#39;tt&#39;; 步骤4：新增带默认值的字段ffname，语句如下： ALTER TABLE tt ADD COLUMN ffname text DEFAULT &#39;默认值&#39;; 步骤5：再次查看数据表tt的relfilenode和relpages信息，语句如下： SELECT relname,relfilenode, relpages FROM pg_class WHERE relname=&#39;tt&#39;; 从结果可以看出，relfilenode和relpages的数据并没有发生变化 综合案例-数据表的基本操作步骤1：登录数据库。启动pgAdmin 4，输入密码连接服务器。步骤2：创建数据库company，执行过程如下。 CREATE DATABASE company; 步骤3：创建表offices。创建表offices的语句如下： CREATE TABLE offices ( officeCode INT NOT NULL UNIQUE, city VARCHAR(50) NOT NULL, address VARCHAR(50) NOT NULL, country VARCHAR(50) NOT NULL, postalCode VARCHAR(15) NOT NULL, PRIMARY KEY (officeCode) ); 步骤4 创建表employees。创建表employees的语句如下： CREATE TABLE employees ( employeeNumber INT NOT NULL PRIMARY KEY, lastName VARCHAR(50) NOT NULL, firstName VARCHAR(50) NOT NULL, mobile VARCHAR(25) NOT NULL, officeCode INT NOT NULL, jobTitle VARCHAR(50) NOT NULL, birth DATE, note VARCHAR(255), sex VARCHAR(5), CONSTRAINT office_fk FOREIGN KEY(officeCode) REFERENCES offices(officeCode) ); 步骤5：将表employees的birth字段改名为employee_birth。修改字段名，需要用到ALTER TABLE语句，输入语句如下： ALTER TABLE employees RENAME birth TO employee_birth; 步骤6：修改sex字段，数据类型为CHAR(1)，非空约束。修改字段数据类型，需要用到ALTER TABLE语句，输入语句如下： ALTER TABLE employees ALTER COLUMN sex TYPE CHAR(1); 步骤7：修改sex字段为非空约束。 ALTER TABLE employees ALTER COLUMN sex SET NOT NULL; 步骤8：删除字段note。删除字段，需要用到ALTER TABLE语句，输入语句如下： ALTER TABLE employees DROP note; 步骤9：增加字段名favoriate_activity，数据类型为VARCHAR(100)。增加字段，需要用到ALTER TABLE语句，输入语句如下： ALTER TABLE employees ADD COLUMN favoriate_activity VARCHAR(100); 步骤10：删除表offices。在创建表employees表时候，设置了表的外键，该表关联了其父表的officeCode主键，如前面所述，删除关联表时，要先删除子表employees的外键约束，才能删除父表，因此，必须先删除employees表的外键约束。1）删除employees表的外键约束，输入如下语句： ALTER TABLE employees DROP CONSTRAINT office_fk; 其中office_fk为employees表的外键约束的名称，语句执行成功后，即可删除offices父表。2）删除表offices，输入如下语句： DROP TABLE offices; 步骤11：将表employees名称修改为employees_info。修改数据表名，需要用到ALTER TABLE语句，输入语句如下： ALTER TABLE employees RENAME TO employees_info; 常见问题及解答]]></content>
      <categories>
        <category>数据库</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取百度图片并把图片存到本地]]></title>
    <url>%2F2019%2F07%2Fpython%2Fspider%2F%E7%99%BE%E5%BA%A6%E5%9B%BE%E7%89%87%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[爬取百度图片并把图片存到本地： import re import requests from urllib import error from bs4 import BeautifulSoup import os num = 0 numPicture = 0 file = &#39;&#39; List = [] def Find(url): global List print(&#39;正在检测图片总数，请稍等.....&#39;) t = 0 i = 1 s = 0 while t &lt; 1000: Url = url + str(t) try: Result = requests.get(Url, timeout=7) except BaseException: t = t + 60 continue else: result = Result.text pic_url = re.findall(&#39;&quot;objURL&quot;:&quot;(.*?)&quot;,&#39;, result, re.S) # 先利用正则表达式找到图片url s += len(pic_url) if len(pic_url) == 0: break else: List.append(pic_url) t = t + 60 return s def recommend(url): Re = [] try: html = requests.get(url) except error.HTTPError as e: return else: html.encoding = &#39;utf-8&#39; bsObj = BeautifulSoup(html.text, &#39;html.parser&#39;) div = bsObj.find(&#39;div&#39;, id=&#39;topRS&#39;) if div is not None: listA = div.findAll(&#39;a&#39;) for i in listA: if i is not None: Re.append(i.get_text()) return Re def dowmloadPicture(html, keyword): global num # t =0 pic_url = re.findall(&#39;&quot;objURL&quot;:&quot;(.*?)&quot;,&#39;, html, re.S) # 先利用正则表达式找到图片url print(&#39;找到关键词:&#39; + keyword + &#39;的图片，即将开始下载图片...&#39;) for each in pic_url: print(&#39;正在下载第&#39; + str(num + 1) + &#39;张图片，图片地址:&#39; + str(each)) try: if each is not None: pic = requests.get(each, timeout=7) else: continue except BaseException: print(&#39;错误，当前图片无法下载&#39;) continue else: string = file + r&#39;\\&#39; + keyword + &#39;_&#39; + str(num) + &#39;.jpg&#39; fp = open(string, &#39;wb&#39;) fp.write(pic.content) fp.close() num += 1 if num &gt;= numPicture: return if __name__ == &#39;__main__&#39;: # 主函数入口 word = input(&quot;请输入搜索关键词(可以是人名，地名等): &quot;) # 比如百度图片上搜索：苹果 # add = &#39;http://image.baidu.com/search/flip?tn=baiduimage&amp;ie=utf-8&amp;word=%e8%8b%b9%e6%9e%9c&amp;pn=120&#39; url = &#39;http://image.baidu.com/search/flip?tn=baiduimage&amp;ie=utf-8&amp;word=&#39; + word + &#39;&amp;pn=&#39; tot = Find(url) Recommend = recommend(url) # 记录相关推荐 print(&#39;经过检测{}类图片共有{}张&#39;.format(word, tot)) numPicture = int(input(&#39;请输入想要下载的图片数量： &#39;)) file = input(&#39;请建立一个存储图片的文件夹，输入文件夹名称即可：&#39;) y = os.path.exists(file) if y == 1: print(&#39;该文件已存在，请重新输入&#39;) file = input(&#39;请建立一个存储图片的文件夹，)输入文件夹名称即可&#39;) os.mkdir(file) else: os.mkdir(file) t = 0 tmp = url while t &lt; numPicture: try: url = tmp + str(t) result = requests.get(url, timeout=10) print(url) except error.HTTPError as e: print(&#39;网络错误，请调整网络后重试&#39;) t = t + 60 else: dowmloadPicture(result.text, word) t = t + 60 print(&#39;当前搜索结束，感谢使用&#39;) print(&#39;猜你喜欢&#39;) for re in Recommend: print(re, end=&#39; &#39;) 执行结果如下，比如搜索杨树： 存到本地的效果如下图： 共勉，(๑•̀ㅂ•́)و✧加油]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬取心灵毒鸡汤、你好污啊 网站数据并存入本地txt文件]]></title>
    <url>%2F2019%2F07%2Fpython%2Fspider%2F%E6%9C%89%E6%AF%92%E6%AE%B5%E5%AD%90%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[心灵毒鸡汤 网站如下：https://www.nihaowua.com/home.html 代码如下： `pythonimport requestsimport randomfrom lxml import etree 安装：pip install fake_useragentfrom fake_useragent import UserAgent def get_random_ua(): #随机UA ua = UserAgent() return ua.random headers = { &#39;User-Agent&#39;: get_random_ua() } url = &#39;https://www.nihaowua.com/home.html&#39; def main(): #写入txt文本程序 count = 0 while True: try: with open(&quot;soup.txt&quot;, &quot;a&quot;, encoding=&#39;utf-8&#39;) as f: res = requests.get(url=url, headers=headers, timeout=10) selector = etree.HTML(res.text) content = selector.xpath(&#39;//section/div/*/text()&#39;)[0] text = str(count) + str(content) f.write(text + &#39;\n&#39;) count += 1 print(&#39;*****正在爬取中，这是第{}次爬取，内容为：{}&#39;.format(count, content)) except Exception as e: print(&#39;exception:&#39;, e) continue if __name__ == &#39;__main__&#39;: main() ``` 执行结果如下： 存入文本中的数据如下： 毒鸡汤网站如下：http://www.nows.fun/ import requests from lxml import etree from fake_useragent import UserAgent def get_random_ua(): # 随机UA ua = UserAgent() return ua.random headers = { &#39;User-Agent&#39;: get_random_ua() } url = &#39;http://www.nows.fun/&#39; def main(): # 写入txt文本程序 count = 0 while True: try: with open(&quot;soup_v1.txt&quot;, &quot;a&quot;, encoding=&#39;utf-8&#39;) as f: res = requests.get(url=url, headers=headers, timeout=10) selector = etree.HTML(res.text) content = selector.xpath(&#39;//span[@id=&quot;sentence&quot;]/text()&#39;)[0] text = str(count) + str(content) f.write(text + &#39;\n&#39;) count += 1 print(&#39;*****正在爬取中，这是第{}次爬取，内容为：{}&#39;.format(count, content)) except Exception as e: print(&#39;exception:&#39;, e) continue if __name__ == &#39;__main__&#39;: main() 你好污啊 网站如下：https://www.nihaowua.com/ 代码如下： `python import requests import random from lxml import etree from fake_useragent import UserAgent def get_random_ua(): #随机UA ua = UserAgent() return ua.random headers = { &#39;User-Agent&#39;: get_random_ua() } url = ‘https://www.nihaowua.com/&#39; def main(): # 写入txt文本程序 count = 0 while True: res = requests.get(url=url, headers=headers, timeout=10) selector = etree.HTML(res.text) content = selector.xpath(&#39;//section/div/*/text()&#39;)[0] with open(&quot;NiHaoWu.txt&quot;, &quot;a&quot;) as f: text = str(count) + &#39; &#39; + content f.write(text + &#39;\n&#39;) count += 1 print(&#39;这是第{}次爬取,内容为：{}&#39;.format(count, content)) if __name__ == &#39;__main__&#39;: main() ``` 执行结果如下图： 存入文本数据如下： 放到阿里云机子上跑的爬虫代码加了去重，钉钉报警 db.py # -*- encoding: utf-8 -*- import hashlib import time from sqlalchemy import create_engine from sqlalchemy import Column, VARCHAR, Integer, TIMESTAMP, CHAR from sqlalchemy.orm import sessionmaker from sqlalchemy.ext.declarative import declarative_base engine = create_engine(&#39;mysql+pymysql://root:123456@localhost/test?charset=utf8&#39;) DBSession = sessionmaker(bind=engine) session = DBSession() Base = declarative_base() class YoududuanziItem(Base): &quot;&quot;&quot;段子信息&quot;&quot;&quot; __tablename__ = &#39;duanzi_for_fun&#39; desc = &#39;段子信息&#39; id = Column(Integer, primary_key=True, autoincrement=True) duplicate_hash = Column(CHAR(40), index=True, unique=True, doc={&#39;zh&#39;: &quot;url hash&quot;}) crawl_time = Column(TIMESTAMP, doc={&#39;zh&#39;: &#39;当前时间&#39;}) centence = Column(VARCHAR(200), index=True, doc={&#39;zh&#39;: &#39;段子&#39;}) @classmethod def creat_table(cls): &quot;&quot;&quot;创建数据表&quot;&quot;&quot; cls.__table__.create(bind=engine, checkfirst=True) def insert(self, centence): url_sha = self.get_contern_url_hash(centence) crawled_time = time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;) try: is_exist = session.query(YoududuanziItem).filter(YoududuanziItem.duplicate_hash == url_sha).all() if not is_exist: item = YoududuanziItem(duplicate_hash=url_sha, crawl_time=crawled_time, centence=centence) session.add(item) session.commit() return True else: return False except BaseException as e: session.rollback() session.close() raise BaseException(f&quot;数据插入失败: \n{url_sha} \n{centence} \n{e}&quot;) def get_contern_url_hash(self, content_url): hash = hashlib.sha1() hash.update(str(content_url).encode(&#39;utf-8&#39;)) url_sha = hash.hexdigest() return url_sha 爬虫代码： # -*- encoding: utf-8 -*- import time import json import requests import logging from lxml import etree from fake_useragent import UserAgent from my_test.db import session, YoududuanziItem class YoududuanziSpider(object): def __init__(self): self.headers = { &#39;User-Agent&#39;: self.get_random_ua() } self.url = &#39;http://www.nows.fun/&#39; # 钉钉报警模板字段，注意: 必须使用raw string, 不能使用多行字符串, 钉钉只处理没有转义的字符, 包含转义字符会导致解析失败 self.failure_template = (&#39;数据爬取信息：\n\n&#39; &#39;&gt; spider_name: {spider_name}\n\n&#39; &#39;&gt; table_name: {table_name}\n\n&#39; &#39;&gt; data_num: {data_num}\n\n&#39; &#39;&gt; last_data: {last_data}\n\n&#39; &#39;&gt; log_url: {log_url}\n\n&#39;) self.dingding_headers = { &quot;Content-Type&quot;: &quot;application/json;charset=utf-8&quot;, } def get_random_ua(self): # 随机UA ua = UserAgent() return ua.random def get_content(self): response = requests.get(url=self.url, headers=self.headers, timeout=10) selector = etree.HTML(response.text) centence = selector.xpath(&#39;//span[@id=&quot;sentence&quot;]/text()&#39;)[0] return centence def send_dingtalk(self, spider_name, table_name, data_num, last_data, log_url): try: content = self.failure_template.format( spider_name=spider_name, table_name=table_name, data_num=data_num, last_data=last_data, log_url=log_url ) msg = { &quot;msgtype&quot;: &quot;markdown&quot;, &quot;markdown&quot;: { &quot;title&quot;: &#39;爬取的段子信息&#39;, &quot;text&quot;: &#39;淘数爬虫：&#39; + content } } ding_url = &#39;https://oapi.dingtalk.com/robot/send?access_token=c1984aefbaff584bceb37b855b8380d7c6c78545fb749d068fc378df627fa786&#39; resp = requests.post(url=ding_url, headers=self.dingding_headers, data=json.dumps(msg), timeout=30) json_data = json.loads(resp.text) if resp.status_code == 200 and json_data[&#39;errcode&#39;] == 0: pass else: logging.error(&#39;钉钉报警发送失败{}&#39;.format(json_data[&#39;errmsg&#39;])) except Exception as e: logging.error(&quot;send dingtalk failed, exception: &quot;, e) def run(self): for i in range(100000): job_info = self.get_content() table.insert(job_info) time.sleep(2) if i % 1000 == 0: logging.info(f&#39;爬取进度：self.num={i}条数据！！！&#39;) self.send_dingtalk(spider_name=&#39;youduduanzi&#39;, table_name=&#39;duanzi_for_fun&#39;, data_num=5, last_data=job_info, log_url=self.url) if __name__ == &#39;__main__&#39;: duanzi = YoududuanziSpider() table = YoududuanziItem() table.creat_table() duanzi.run() 共勉，(๑•̀ㅂ•́)و✧加油]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式之6大设计原则详解]]></title>
    <url>%2F2019%2F06%2Fjava%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F20190629_6%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[1、单一职责原则 There should never be more than one reason for a class to change. 理解：不同的类具备不同的职责，各司其职。做系统设计是，如果发现有一个类拥有了两种职责，那么就要问一个问题：可以将这个类分成两个类吗？如果真的有必要，那就分开，千万不要让一个类干的事情太多。 总结：一个类只承担一个职责 2、开放封闭原则 Software entities like classes,modules and functions should be open for extension but closed for modifications. 理解：类、模块、函数，可以去扩展，但不要去修改。如果要修改代码，尽量用继承或组合的方式来扩展类的功能，而不是直接修改类的代码。当然，如果能保证对整个架构不会产生任何影响，那就没必要搞的那么复杂，直接改这个类吧。 总结：对软件实体的改动，最好用扩展而非修改的方式。 3、里式替换原则 Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it. 理解：父类可被子类替换，但反之不一定成立。也就是说，代码中可以将父类全部替换为子类，程序不会出现异常，但反过来就不一定了。 总结：在继承类是，务必重写（override）父类中所有的方法，尤其需要注意父类的protected方法（它们往往是让你重写的），子类尽量不要暴露自己的public方法供外界调用。 4、最少知识原则 Only talk to you immediate friends. 理解：尽量减少对象之间的交互，从而减小类之间的耦合。在做系统设计时，不要让一个类依赖于太多其他的类，需尽量减小依赖关系，否则死都不知道怎么死的。 总结：一定要做到：低耦合、高内聚。 5、接口隔离原则 The dependency of one class to another one should depend on the smallest possible interface. 理解：不要对外暴露没有实际意义的接口。也就是说，尽量保证接口的实用性。当需要对外暴露接口时，需要再三斟酌，若没必要对外提供就删了吧，因为一旦提供了就意味着，将来要多做一件事情，何苦给自己找事做呢。 总结：不要对外暴露没有实际意义的接口。 6、依赖倒置原则 High level modules should not depends upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions. 理解：高层模块不应该依赖于底层模块，而应该依赖于抽象。抽象不应依赖于细节，细节应依赖于抽象。应该面向接口编程，不该面向实现类编程。面向实现类编程相当于就事论事，那是正向依赖；面向接口编程，相当于透过现象看本质，抓住事务的共性，那就是反向依赖，即依赖倒置。 总结：面向接口编程，提取出事务的本质和共性。 将六大原则的英文首字母拼在一起就是SOLID（稳定的），所以也称之为SOLID原则。 只有满足了这六大原则，才能设计出稳定的软件架构，但它们只是原则，有时还是需要学会灵活应变，千万不要生搬硬套，否则只会把简单问题复杂化！ 最经典的 23 种设计模式中或多或少地都在使用这些设计原则，也就是说，设计模式是站在设计原则的基础之上的。下面来详细介绍Java中23种设计模式的概念，应用场景等情况，并结合他们的特点及设计模式的原则进行分析。 总体来说23种设计模式分为三大类： 创建型模式（5种）：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。 结构型模式（7种）：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。 行为型模式（11种）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。 如果想了解23种设计模式详解，可点击：设计模式概述 以及 23种设计模式的介绍]]></content>
      <categories>
        <category>Java</category>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态模式详解 (附java语言源码)]]></title>
    <url>%2F2019%2F06%2Fjava%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F20190624_%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[状态模式（State Pattern）: 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。(Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.) 核心：用于解决系统中 复杂对象的状态转换 以及不同状态下行为 的封装问题 现实场景： 电梯的运行：维修、正常、自动关门、自动开门、向上运行、向下运行、消防状态； 红绿灯：红灯、黄灯、绿灯； 企业或政府系统：公文的审批状态； 报销单据审批状态； 假条审批； 网上购物时，订单的状态下单：已付款，已发货，送货中，已收货。 开发中常见的场景： 银行系统中账号状态的管理； OA系统中公文状态的管理； 酒店系统中，房间状态的管理； 线程对象各状态之间的切换 案例场景：在酒店系统中，房间的状态变化：已预订，已入住，空闲。（当遇到这种需要频繁的修改状态时，考虑状态模式） 该过程用状态模式实现，大致有以下4步： 步骤1：定义State抽象状态类，定义一个接口以封装与Context的一个特定状态相关的行为。 public interface State { void handle(); } 步骤2：定义Context环境类，维护一个ConcreteState子类的实例，这个实例定义当前的状态。 /** * Context类 : 房间对象 * 如果是银行系统，这个Context类就是账号。根据金额不同，切换不同的状态！ */ public class HomeContext { private State state; public void setState(State s){ System.out.println(&quot;修改状态！&quot;); state = s; state.handle(); } } 步骤3：定义ConcreteState具体状态类，每一个类封装了一个状态对应的行为 1.已预订状态 /** * 已预订状态 */ public class BookedState implements State { @Override public void handle() { System.out.println(&quot;房间已预订！别人不能定！&quot;); } } 2.已入住状态 /** * 已入住状态 */ public class CheckedInState implements State { @Override public void handle() { System.out.println(&quot;房间已入住！请勿打扰！&quot;); } } 3.空闲状态 /** * 空闲状态 */ public class FreeState implements State { @Override public void handle() { System.out.println(&quot;房间空闲！！！没人住！&quot;); } } 步骤4：测试 public class Client { public static void main(String[] args) { HomeContext ctx = new HomeContext(); ctx.setState(new FreeState()); ctx.setState(new BookedState()); } } 执行结果如下图所示： 如果想了解更多设计模式，可点击：设计模式概述 以及 23种设计模式的介绍]]></content>
      <categories>
        <category>Java</category>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解释器模式详解 (没有附java语言源码)]]></title>
    <url>%2F2019%2F06%2Fjava%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F20190624_%E8%A7%A3%E9%87%8A%E5%99%A8%2F</url>
    <content type="text"><![CDATA[解释器模式（Interpreter Pattern）： 定义一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。（Given a language, define are presentation for its grammar along with an interpreter that uses there presentation to interpret sentences in the language.） 介绍： 是一种不常用的设计模式； 用于描述如何构成一个简单的语言解释器，主要用于使用面向对象语言开发的编译器和解释器设计； 当我们需要开发一种新的语言时，可以考虑使用解释器模式； 尽量不要使用解释器模式，后期维护会有很大麻烦。在项目中，可以使用Jruby，Groovy、java的js引擎来替代解释器的作用，弥补java语言的不足。 开发中常见的场景： EL表达式式的处理； 正则表达式解释器； SQL语法的解释器； 数学表达式解析器，如现成的工具包:Math Expression String Parser、Expression4J等。 如果想了解更多设计模式，可点击：设计模式概述 以及 23种设计模式的介绍]]></content>
      <categories>
        <category>Java</category>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[访问者模式详解 (没有附java语言源码)]]></title>
    <url>%2F2019%2F06%2Fjava%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F20190624_%E8%AE%BF%E9%97%AE%E8%80%85%2F</url>
    <content type="text"><![CDATA[访问者模式（Visitor Pattern）: 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素类别的前提下定义作用于这些元素的新操作。(Represent an operation to be performedon the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.) 模式动机：对于存储在一个集合中的对象，他们可能具有不同的类型(即使有一个公共的接口)，对于该集合中的对象，可以接受一类称为访问者的对象来访问，不同的访问者其访问方式也有所不同。 开发中的场景 : (应用范围非常窄，了解即可)： XML文档解析器设计; 编译器的设计; 复杂集合对象的处理 如果想了解更多设计模式，可点击：设计模式概述 以及 23种设计模式的介绍]]></content>
      <categories>
        <category>Java</category>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[责任链模式详解 (附java语言源码)]]></title>
    <url>%2F2019%2F06%2Fjava%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F20190624_%E8%B4%A3%E4%BB%BB%E9%93%BE%2F</url>
    <content type="text"><![CDATA[责任链模式（Chain of Responsibility Pattern）： 为解除请求的发送者和接收者之间的耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它。（Avoid coupling the sender of a requestits receiver by giving more than one object a chance to handle the request.Chain the receiving objects and pass the request along the chain until anobject handles it.） 理解：由于责任链的创建完全在客户端，因此新增新的具体处理者对原有类库没有任何影响，只需添加新的类，然后在客户端调用时添加即可。符合开闭原则。 现实中的场景： 打牌时，轮流出牌； 接力赛跑； 大学中，经学金审批； 公司中，公文审批。 公司里面，报销个单据需要经过流程：申请人填单申请，申请给经理；小于1000，经理审查；超过1000，交给总经理审批；总经理审批通过 公司里面，请假条的审批过程：如果请假天数小于3天，主任审批；如果请假天数大于等于3天，小于10天，经理审批；如果大于等于10天，小于30天，总经理审批；如果大于等于30天，提示拒绝 公司里面，SCM(Supply Chain Management供应链管理)系统中，采购审批子系统的设计： 采购金额小于5万，主任审批；采购金额大于等于5万，小于10万，经理审批；采购金额大于等于10万，小于20万，副总经理审批；采购金额大于等于20万，总经理审批 非链表方式实现职责链：通过集合、数组生成职责链更加实用！实际上，很多项目中，每个具体的Handler并不是由开发团队定义的，而是项目上线后由外部单位追加的，所以使用链表方式定义COR链就很困难。 开发中常见的场景： Java中，异常机制就是一种责任链模式。一个try可以对应多个catch，当第一个catch不匹配类型，则自动跳到第二个catch； Javascript语言中，事件的冒泡和捕获机制。Java语言中，事件的处理采用观察者模式； Servlet开发中，过滤器的链式处理； Struts2中，拦截器的调用也是典型的责任链模式。 案例 ：（链表方式定义职责链）请假条审批流程，我们可以在请假处理流程中，增加新的“副总经理”角色，审批大于等于10天，小于20天的请假。审批流程变为：① 如果请假天数小于3天，主任审批；② 如果请假天数大于等于3天，小于10天，经理审批；③ 大于等于10天，小于20天的请假，副总经理审批；④ 如果大于等于20天，小于30天，总经理审批；⑤ 如果大于等于30天，提示拒绝； 该过程的实现大致有以下几个步骤： 步骤1：封装请假的基本信息 /** * 封装请假的基本信息 */ public class LeaveRequest { private String empName;//员工姓名 private int leaveDays;//请假天数 private String reason;//请假原因 public LeaveRequest(String empName, int leaveDays, String reason) { super(); this.empName = empName; this.leaveDays = leaveDays; this.reason = reason; } public String getEmpName() { return empName; } public void setEmpName(String empName) { this.empName = empName; } public int getLeaveDays() { return leaveDays; } public void setLeaveDays(int leaveDays) { this.leaveDays = leaveDays; } public String getReason() { return reason; } public void setReason(String reason) { this.reason = reason; } } 步骤2：定义抽象处理者(Handler) /** * 抽象类 */ public abstract class Leader { protected String name; protected Leader nextLeader; //责任链上的后继对象 public Leader(String name) { super(); this.name = name; } //设定责任链上的后继对象 public void setNextLeader(Leader nextLeader) { this.nextLeader = nextLeader; } //处理请求的核心的业务方法 public abstract void handleRequest(LeaveRequest request); } 步骤3：定义具体处理者(ConcreteHandler) 1.主任： /** * 主任 */ public class Director extends Leader { public Director(String name) { super(name); } @Override public void handleRequest(LeaveRequest request) { if(request.getLeaveDays()&lt;3){ System.out.println(&quot;员工：&quot;+request.getEmpName()+&quot;请假，天数：&quot;+request.getLeaveDays()+&quot;,理由：&quot;+request.getReason()); System.out.println(&quot;主任：&quot;+this.name+&quot;,审批通过！&quot;); }else{ if(this.nextLeader!=null){ this.nextLeader.handleRequest(request); } } } } 2.经理 /** * 经理 */ public class Manager extends Leader { public Manager(String name) { super(name); } @Override public void handleRequest(LeaveRequest request) { if(request.getLeaveDays()&lt;10){ System.out.println(&quot;员工：&quot;+request.getEmpName()+&quot;请假，天数：&quot;+request.getLeaveDays()+&quot;,理由：&quot;+request.getReason()); System.out.println(&quot;经理：&quot;+this.name+&quot;,审批通过！&quot;); }else{ if(this.nextLeader!=null){ this.nextLeader.handleRequest(request); } } } } 3.副总经理 /** * 副总经理 */ public class ViceGeneralManager extends Leader { public ViceGeneralManager(String name) { super(name); } @Override public void handleRequest(LeaveRequest request) { if(request.getLeaveDays()&lt;20){ System.out.println(&quot;员工：&quot;+request.getEmpName()+&quot;请假，天数：&quot;+request.getLeaveDays()+&quot;,理由：&quot;+request.getReason()); System.out.println(&quot;副总经理：&quot;+this.name+&quot;,审批通过！&quot;); }else{ if(this.nextLeader!=null){ this.nextLeader.handleRequest(request); } } } } 4.总经理 /** * 总经理 */ public class GeneralManager extends Leader { public GeneralManager(String name) { super(name); } @Override public void handleRequest(LeaveRequest request) { if(request.getLeaveDays()&lt;30){ System.out.println(&quot;员工：&quot;+request.getEmpName()+&quot;请假，天数：&quot;+request.getLeaveDays()+&quot;,理由：&quot;+request.getReason()); System.out.println(&quot;总经理：&quot;+this.name+&quot;,审批通过！&quot;); }else{ System.out.println(&quot;莫非&quot;+request.getEmpName()+&quot;想辞职，居然请假&quot;+request.getLeaveDays()+&quot;天！&quot;); } } } 步骤4：测试 public class Client { public static void main(String[] args) { Leader a = new Director(&quot;张三&quot;);//主任 Leader b = new Manager(&quot;李四&quot;);//经理 Leader b2 = new ViceGeneralManager(&quot;李小四&quot;);//副总经理 Leader c = new GeneralManager(&quot;王五&quot;);//总经理 //组织责任链对象的关系 a.setNextLeader(b); b.setNextLeader(b2); b2.setNextLeader(c); //开始请假操作 LeaveRequest req1 = new LeaveRequest(&quot;Jack&quot;, 14, &quot;回老家探亲！&quot;); a.handleRequest(req1); //审批流程 System.out.println(&quot;审批流程:&quot;+a.name+&quot;---&gt;&quot;+b.name+&quot;---&gt;&quot;+b2.name+&quot;---&gt;&quot;+c.name); } } 执行结果如下图所示： 如果想了解更多设计模式，可点击：设计模式概述 以及 23种设计模式的介绍]]></content>
      <categories>
        <category>Java</category>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[备忘录模式详解 (附java语言源码)]]></title>
    <url>%2F2019%2F06%2Fjava%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F20190620_%E5%A4%87%E5%BF%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[备忘录模式（Memento Pattern）： 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保持该状态，这样以后就可以将该对象恢复到保存的状态。（Without violating encapsulates, capture and externalize an object’s internal state so that the object can be restored to this state later.） 核心 ：就是保存某个对象内部状态的拷贝，这样以后就可以将该对象恢复到原先的状态。 现实场景 ： 录入大批人员资料。正在录入当前人资料时，发现上一个人录错了，此时需要恢复上一个人的资料，再进行修改； Word文档编辑时，忽然电脑死机或断电，再打开时，可以看到word提示你恢复到以前的文档； 管理系统中，公文撤回功能。公文发送出去后，想撤回来。 开发中常见的应用场景 ： 棋类游戏中的，悔棋 普通软件中的，撤销操作 数据库软件中的，事务管理中的，回滚操作 Photoshop软件中的，历史记录 备忘录模式的实现大致需要4个步骤： 步骤1：定义源发器类（Originator），负责创建一个备忘录Memento,用以记录当前时刻它的内部状态，并可使用备忘录恢复内部状态 /** * 源发器类 Originator */ public class Emp { private String ename; private int age; private double salary; //进行备忘操作，并返回备忘录对象 public EmpMemento memento(){ return new EmpMemento(this); } //进行数据恢复，恢复成制定备忘录对象的值 public void recovery(EmpMemento mmt){ this.ename = mmt.getEname(); this.age = mmt.getAge(); this.salary = mmt.getSalary(); } public Emp(String ename, int age, double salary) { super(); this.ename = ename; this.age = age; this.salary = salary; } public String getEname() { return ename; } public void setEname(String ename) { this.ename = ename; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public double getSalary() { return salary; } public void setSalary(double salary) { this.salary = salary; } } 步骤2：定义备忘录类（Memento）,负责存储Oreginator对象的内部状态，并可防止Originator以外的其它对象访问备忘录（Memento）。 /** * 备忘录类 Memento */ public class EmpMemento { private String ename; private int age; private double salary; public EmpMemento(Emp e) { this.ename = e.getEname(); this.age = e.getAge(); this.salary = e.getSalary(); } //get/set方法 public String getEname() { return ename; } public void setEname(String ename) { this.ename = ename; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public double getSalary() { return salary; } public void setSalary(double salary) { this.salary = salary; } } 步骤3：定义 负责人类（CareTaker），负责保存好备忘录（Memento）。 /** * 负责人类 :负责管理备忘录对象 */ public class CareTaker { private EmpMemento memento; //private List&lt;EmpMemento&gt; list = new ArrayList&lt;EmpMemento&gt;(); public EmpMemento getMemento() { return memento; } public void setMemento(EmpMemento memento) { this.memento = memento; } } 步骤4：测试 /** * 测试 */ public class Client { public static void main(String[] args) { CareTaker taker = new CareTaker(); Emp emp = new Emp(&quot;张三丰&quot;, 48, 900); System.out.println(&quot;第一次打印对象--- 姓名：&quot;+emp.getEname()+&quot; 年龄：&quot;+emp.getAge()+&quot; 薪水：&quot;+emp.getSalary()); taker.setMemento(emp.memento()); //备忘一次 System.out.println(&quot;注意：备忘一次---&quot;); emp.setAge(18); emp.setEname(&quot;张无忌&quot;); emp.setSalary(9000); System.out.println(&quot;第二次打印对象--- 姓名：&quot;+emp.getEname()+&quot; 年龄：&quot;+emp.getAge()+&quot; 薪水：&quot;+emp.getSalary()); emp.recovery(taker.getMemento()); //恢复到备忘录对象保存的状态 System.out.println(&quot;注意：恢复到备忘录对象保存的状态---&quot;); System.out.println(&quot;第三次打印对象--- 姓名：&quot;+emp.getEname()+&quot; 年龄：&quot;+emp.getAge()+&quot; 薪水：&quot;+emp.getSalary()); } } 执行结果如下图所示： 如果想了解更多设计模式，可点击：设计模式概述 以及 23种设计模式的介绍]]></content>
      <categories>
        <category>Java</category>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中介者模式详解 (附java语言源码)]]></title>
    <url>%2F2019%2F06%2Fjava%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F20190619_%E4%B8%AD%E4%BB%8B%E8%80%85%2F</url>
    <content type="text"><![CDATA[中介者模式（Mediator Pattern）： 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。（Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly and it lets you vary their interaction independently.） 中介者模式的本质：解耦多个同事对象之间的交互关系。每个对象都持有中介者对象的引用，只跟中介者对象打交道。我们通过中介者对象统一管理这些交互关系。 应用思路：如果一个系统中，对象之间的联系呈网状结构，对象之间存在大量的多对多关系，导致关系很复杂。这是可以引入一个中介者对象，各个同事对象只跟中介者对象打交道，将复杂的网络结构化解成为如下的星型结构： 开发中常见的场景： MVC模式(其中的C，控制器就是一个中介者对象。M和V都和他打交道) 窗口游戏程序，窗口软件开发中窗口对象也是一个中介者对象 图形界面开发GUI中，多个组件之间的交互，可以通过引入一个中介者对象来解决，可以是整体的窗口对象或者DOM对象 Java.lang.reflect.Method#invoke() 案例： 比如说，一个公司有三个部门：财务部、市场部、研发部。那么总经理就扮演中介者的角色。用代码实现大致有以下5个步骤： 步骤1：定义抽象中介者，定义了同事对象到中介者对象的接口。 /** * 中介者接口 */ public interface Mediator { void register(String dname, Department d); void command(String dname); } 步骤2：定义具体中介者对象，实现抽象中介者类的方法，他需要知道所有具体同事类，并从具体同事接收消息，向具体同事发出命令。 /** * 总经理实现中介者接口 */ public class President implements Mediator { private Map&lt;String,Department&gt; map = new HashMap&lt;String , Department&gt;(); @Override public void command(String dname) { map.get(dname).selfAction(); } @Override public void register(String dname, Department d) { map.put(dname, d); } } 步骤3：定义抽象同事类 /** * 部门接口：同事类 */ public interface Department { void selfAction(); //做本部门的事情 void outAction(); //向总经理发出申请 } 步骤4：定义具体同事类，每个具体同事只知道自己的行为，而不了解其他同事类的情况，但他们却都认识中介者对象。 /** * 研发部 */ public class Development implements Department { private Mediator mediator; //持有中介者(总经理)的引用 public Development(Mediator mediator) { super(); this.mediator = mediator; mediator.register(&quot;development&quot;, this); } @Override public void outAction() { System.out.println(&quot;研发部向总经理发出申请：汇报工作！没钱了，需要资金支持！&quot;); } @Override public void selfAction() { System.out.println(&quot;研发部：专心科研，开发项目！&quot;); } } /** * 财务部 */ public class Finacial implements Department { private Mediator mediator; //持有中介者(总经理)的引用 public Finacial(Mediator mediator) { super(); this.mediator = mediator; mediator.register(&quot;finacial&quot;, this); } @Override public void outAction() { System.out.println(&quot;财务部向总经理发出申请：汇报工作！没钱了，钱太多了！怎么花?&quot;); } @Override public void selfAction() { System.out.println(&quot;财务部：数钱！&quot;); } } /** * 市场部 */ public class Market implements Department { private Mediator mediator; //持有中介者(总经理)的引用 public Market(Mediator mediator) { super(); this.mediator = mediator; mediator.register(&quot;market&quot;, this); } @Override public void outAction() { System.out.println(&quot;市场部向总经理发出申请：汇报工作！项目承接的进度，需要资金支持！&quot;); mediator.command(&quot;finacial&quot;); } @Override public void selfAction() { System.out.println(&quot;市场部：跑去接项目！&quot;); } } 步骤5：测试 /** * 测试 */ public class Client { public static void main(String[] args) { Mediator m = new President(); Market market = new Market(m); Development devp = new Development(m); Finacial f = new Finacial(m); market.selfAction(); market.outAction(); } } 执行结果如下图所示： 如果想看更多设计模式，可点此链接：设计模式概述 以及 23种设计模式的介绍]]></content>
      <categories>
        <category>Java</category>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器模式详解 (附java语言源码)]]></title>
    <url>%2F2019%2F06%2Fjava%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F20190618_%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[迭代器模式（Iterator Pattern）： 提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。（Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.） 开发中常见的场景： JDK内置的迭代器(List/Set) 场景： 提供一种可以遍历聚合对象的方式。又称为：游标cursor模式 聚合对象：存储数据 迭代器：遍历数据 代码实现可分为以下3步： 步骤1：自定义的迭代器接口 /** * 自定义的迭代器接口 */ public interface MyIterator { void first(); //将游标指向第一个元素 void next(); //将游标指向下一个元素 boolean hasNext();//判断是否存在下一个元素 boolean isFirst(); boolean isLast(); Object getCurrentObj(); //获取当前游标指向的对象 } 步骤2：自定义的聚合类 import java.util.ArrayList; import java.util.List; /** * 自定义的聚合类 */ public class ConcreteMyAggregate { private List&lt;Object&gt; list = new ArrayList&lt;Object&gt;(); public void addObject(Object obj){ this.list.add(obj); } public void removeObject(Object obj){ this.list.remove(obj); } public List&lt;Object&gt; getList() { return list; } public void setList(List&lt;Object&gt; list) { this.list = list; } //获得迭代器 public MyIterator createIterator(){ return new ConcreteIterator(); } //使用内部类定义迭代器，可以直接使用外部类的属性 private class ConcreteIterator implements MyIterator { private int cursor; //定义游标用于记录遍历时的位置 @Override public void first() { cursor = 0; } @Override public Object getCurrentObj() { return list.get(cursor); } @Override public boolean hasNext() { if(cursor&lt;list.size()){ return true; } return false; } @Override public boolean isFirst() { return cursor==0?true:false; } @Override public boolean isLast() { return cursor==(list.size()-1)?true:false; } @Override public void next() { if(cursor&lt;list.size()){ cursor++; } } } } 步骤3：测试 public class Client { public static void main(String[] args) { ConcreteMyAggregate cma = new ConcreteMyAggregate(); cma.addObject(&quot;aa&quot;); cma.addObject(&quot;bb&quot;); cma.addObject(&quot;cc&quot;); MyIterator iter = cma.createIterator(); while(iter.hasNext()){ System.out.println(iter.getCurrentObj()); iter.next(); } } } 执行结果如下图所示： 如果想了解更多设计模式，可点击：设计模式概述 以及 23种设计模式的介绍]]></content>
      <categories>
        <category>Java</category>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令模式详解 (附java语言源码)]]></title>
    <url>%2F2019%2F06%2Fjava%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F20190617_%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[命令模式（Command Pattern）： 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可取消的操作。（Encapsulate a request as an object,thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.） 何时使用：在某些场合，比如要对行为进行”记录、撤销/重做、事务”等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将”行为请求者”与”行为实现者”解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。 主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。 开发中常见的场景： Struts2中，action的整个调用过程中就有命令模式。Struts其实就是一种将请求和呈现分离的技术，其中必然涉及命令模式的思想。比如 : struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。 数据库事务机制的底层实现 命令的撤销和恢复 经典的命令模式包括4个角色： Command：定义命令的统一接口 ConcreteCommand：Command接口的实现者，用来执行具体的命令，某些情况下可以直接用来充当Receiver。 Receiver：命令的实际执行者 Invoker：命令的请求者，是命令模式中最重要的角色。这个角色用来对各个命令进行控制。 命令模式的代码大致可分为5步：步骤1：定义接收者 （Receiver） ,接收者执行与请求相关的操作，具体实现对请求的业务处理；未抽象前，实际执行操作内容的对象。 /** * 真正的命令的执行者 */ public class Receiver { public void action(){ System.out.println(&quot;Receiver.action()&quot;); } } 步骤2：定义抽象命令类（Command） public interface Command { /** * 这个方法是一个返回结果为空的方法。 * 实际项目中，可以根据需求设计多个不同的方法 */ void execute(); } 步骤3：定义具体命令类（ConcreteCommand） public class ConcreteCommand implements Command { private Receiver receiver; //命令的真正的执行者 public ConcreteCommand(Receiver receiver) { super(); this.receiver = receiver; } @Override public void execute() { //命令真正执行前或后，执行相关的处理！ receiver.action(); } } 步骤4：定义调用者/请求者（Invoker） /** * 调用者/发起者 */ public class Invoke { //也可以通过容器List&lt;Command&gt;容纳很多命令对象，进行批处理。 // 数据库底层的事务管理就是类似的结构！ private Command command; public Invoke(Command command) { super(); this.command = command; } //业务方法 ，用于调用命令类的方法 public void call(){ command.execute(); } } 步骤5：定义客户类（Client） /** * 测试 */ public class Client { public static void main(String[] args) { Command c = new ConcreteCommand(new Receiver()); Invoke i = new Invoke(c); i.call(); //new Receiver().action(); } } 执行结果如下图所示： 如果想了解更多设计模式，可点击：设计模式概述 以及 23种设计模式的介绍]]></content>
      <categories>
        <category>Java</category>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板方法模式详解 (附java语言源码)]]></title>
    <url>%2F2019%2F06%2Fjava%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F20190614_%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[模版方法模式（Template Pattern）: 定义一个操作中的算法的骨架，而将一些步骤延迟到子类。TemplateMethod 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。(Define the skeleton of an algorithm inan operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing thealgorithm’s structure.) 核心：处理步骤父类中定义好，具体实现延迟到子类实现。 什么时候用到模板方法模式：实现一个算法时，整体步骤很固定。但是，某些部分易变，易变部分可以抽象出来，供子类实现。 开发中常见的场景：非常频繁，各个框架，类库中都有他的影子。比如： 数据库访问的封装； Junit单元测试； servlet中关于doGet/doPost方法调用； Hibernate中模板程序； spring中JDBCTemplate , HibernateTemplate等 案例：比如说客户到银行办理业务，大致有以下三个过程： 取号排队； 办理具体业务 (存钱，转账，理财等)； 对银行工作人员进行评分； 用模板方法模式，代码实现如下： package designpattern.templatemethod; public abstract class BankTemplateMethod { //具体方法 public void takeNumber(){ System.out.println(&quot;取号排队&quot;); } public abstract void transact(); //办理具体的业务 //钩子方法 public void evaluate(){ System.out.println(&quot;反馈评分&quot;); } public final void process(){ //模板方法！！！ this.takeNumber(); this.transact(); this.evaluate(); } } package designpattern.templatemethod; public class Client { public static void main(String[] args) { BankTemplateMethod btm = new DrawMoney(); btm.process(); //采用匿名内部类 BankTemplateMethod btm2 = new BankTemplateMethod() { @Override public void transact() { System.out.println(&quot;我要存钱！&quot;); } }; btm2.process(); BankTemplateMethod btm3 = new BankTemplateMethod() { @Override public void transact() { System.out.println(&quot;我要理财！我这里有2000万韩币&quot;); } }; btm3.process(); } } class DrawMoney extends BankTemplateMethod { @Override public void transact() { System.out.println(&quot;我要取款！！！&quot;); } } 执行结果如下图所示： 如果想了解更多设计模式，可点击：设计模式概述 以及 23种设计模式的介绍]]></content>
      <categories>
        <category>Java</category>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何突破网站对selenium的屏蔽]]></title>
    <url>%2F2019%2F06%2Fpython%2Fspider%2Fselenium%2F20190613_%E7%AA%81%E7%A0%B4%E5%B1%8F%E8%94%BD%2F</url>
    <content type="text"><![CDATA[使用selenium模拟浏览器进行数据抓取无疑是当下最通用的数据采集方案，它通吃各种数据加载方式，能够绕过客户JS加密，绕过爬虫检测，绕过签名机制。它的应用，使得许多网站的反采集策略形同虚设。由于selenium不会在HTTP请求数据中留下指纹，因此无法被网站直接识别和拦截。 这是不是就意味着selenium真的就无法被网站屏蔽了呢？非也。selenium在运行的时候会暴露出一些预定义的Javascript变量（特征字符串），例如”window.navigator.webdriver”，在非selenium环境下其值为undefined，而在selenium环境下，其值为true（如下图所示为selenium驱动下Chrome控制台打印出的值）。 常见的特征串如下所示： webdriver __driver_evaluate __webdriver_evaluate __selenium_evaluate __fxdriver_evaluate __driver_unwrapped __webdriver_unwrapped __selenium_unwrapped __fxdriver_unwrapped _Selenium_IDE_Recorder _selenium calledSelenium _WEBDRIVER_ELEM_CACHE ChromeDriverw driver-evaluate webdriver-evaluate selenium-evaluate webdriverCommand webdriver-evaluate-response __webdriverFunc __webdriver_script_fn __$webdriverAsyncExecutor __lastWatirAlert __lastWatirConfirm __lastWatirPrompt $chrome_asyncScriptInfo $cdc_asdjflasutopfhvcZLmcfl_ 了解了这个特点之后，就可以在浏览器客户端JS中通过检测这些特征串来判断当前是否使用了selenium，并将检测结果附加到后续请求之中，这样服务端就能识别并拦截后续的请求。 下面讲一个具体的例子。 一个能够有效检测并屏蔽selenium的网站应用：大众点评网的验证码表单页，如果是正常的浏览器操作，能够有效的通过验证，但如果是使用selenium就会被识别，即便验证码输入正确，也会被提示“请求异常,拒绝操作”，无法通过验证 可以看到它检测了”webdriver”, “driver_evaluate”, “webdriver_evaluate”等等这些selenium的特征串。提交验证码的时候抓包可以看到一个_token参数（很长），selenium检测结果应该就包含在该参数里，服务端借以判断“请求异常,拒绝操作”。 现在才进入正题，如何突破网站的这种屏蔽呢？ 我们已经知道了屏蔽的原理，只要我们能够隐藏这些特征串就可以了。但是还不能直接删除这些属性，因为这样可能会导致selenium不能正常工作了。我们采用曲线救国的方法，使用中间人代理，比如fidder, proxy2.py或者mitmproxy，将JS文件（本例是yoda.*.js这个文件）中的特征字符串给过滤掉（或者替换掉，比如替换成根本不存在的特征串），让它无法正常工作，从而达到让客户端脚本检测不到selenium的效果。 下面我们验证下这个思路。这里我们使用mitmproxy实现中间人代理），对JS文件（本例是yoda.*.js这个文件）内容进行过滤。启动mitmproxy代理并加载response处理脚本： # coding:utf-8 # modify_response.py import re from mitmproxy import ctx def response(flow): &quot;&quot;&quot;修改应答数据&quot;&quot;&quot; if &#39;/js/yoda.&#39; in flow.request.url: # 屏蔽selenium检测 for webdriver_key in [&#39;webdriver&#39;, &#39;__driver_evaluate&#39;, &#39;__webdriver_evaluate&#39;, &#39;__selenium_evaluate&#39;, &#39;__fxdriver_evaluate&#39;, &#39;__driver_unwrapped&#39;, &#39;__webdriver_unwrapped&#39;, &#39;__selenium_unwrapped&#39;, &#39;__fxdriver_unwrapped&#39;, &#39;_Selenium_IDE_Recorder&#39;, &#39;_selenium&#39;, &#39;calledSelenium&#39;, &#39;_WEBDRIVER_ELEM_CACHE&#39;, &#39;ChromeDriverw&#39;, &#39;driver-evaluate&#39;, &#39;webdriver-evaluate&#39;, &#39;selenium-evaluate&#39;, &#39;webdriverCommand&#39;, &#39;webdriver-evaluate-response&#39;, &#39;__webdriverFunc&#39;, &#39;__webdriver_script_fn&#39;, &#39;__$webdriverAsyncExecutor&#39;, &#39;__lastWatirAlert&#39;, &#39;__lastWatirConfirm&#39;, &#39;__lastWatirPrompt&#39;, &#39;$chrome_asyncScriptInfo&#39;, &#39;$cdc_asdjflasutopfhvcZLmcfl_&#39;]: ctx.log.info(&#39;Remove&quot;{}&quot;from{}.&#39;.format(webdriver_key,flow.request.url)) flow.response.text=flow.response.text.replace(&#39;&quot;{}&quot;&#39;.format(webdriver_key),&#39;&quot;NO-SUCH-ATTR&quot;&#39;) flow.response.text=flow.response.text.replace(&#39;t.webdriver&#39;,&#39;false&#39;) flow.response.text=flow.response.text.replace(&#39;ChromeDriver&#39;,&#39;&#39;) 解决方法：mitmproxy因为mitmproxy可以拦截请求，所以在响应中，将包含的webdriver的JS中的关键字替换成其他的字符就可以了。 if &quot;/_next/static/js/common_pdd&quot; in flow.request.url: flow.response.text = flow.response.text.replace(&quot;webdriver&quot;, &quot;userAgent&quot;)]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>selenium</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[享元模式详解 (附java语言源码)]]></title>
    <url>%2F2019%2F06%2Fjava%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F20190613_%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[享元模式（Flyweight Pattern）： 运用共享技术有效地支持大量细粒度的对象。（Use sharing to support large numbers offine-grained objects efficiently.） 享元模式核心： 享元模式以共享的方式高效地支持大量细粒度对象的重用。 享元对象能做到共享的关键是区分了内部状态和外部状态。• 内部状态：可以共享，不会随环境变化而改变• 外部状态：不可以共享，会随环境变化而改变 享元模式的优缺点：优点： 极大减少内存中对象的数量， 相同或相似对象内存中只存一份，极大的节约资源，提高系统性能 外部状态相对独立，不影响内部状态 缺点 模式较复杂，使程序逻辑复杂化 为了节省内存，共享了内部状态，分离出外部状态，而读取外部状态使运行时间变长。用时间换取了空间。 享元模式开发中应用的场景： 享元模式由于其共享的特性，可以在任何“池”中操作，比如：线程池、数据库连接池。 String类的设计也是享元模式 享元模式实现： FlyweightFactory享元工厂类：创建并管理享元对象，享元池一般设计成键值对 FlyWeight抽象享元类：通常是一个接口或抽象类，声明公共方法，这些方法可以向外界提供对象的内部状态，设置外部状态。 ConcreteFlyWeight具体享元类：为内部状态提供成员变量进行存储 UnsharedConcreteFlyWeight非共享享元类：不能被共享的子类可以设计为非共享享元类 案例：比如围棋软件设计，每个围棋棋子都是一个对象，有如下属性：颜色形状,大小,(这些是可以共享的)称之为：内部状态。而围棋的位置(这些不可以共享)称之为：外部状态。该过程可分为以下5步： 步骤1：定义抽象享元类 /** * 享元类 */ public interface ChessFlyWeight { void setColor(String c); String getColor(); void display(Coordinate c); } 步骤2：定义具体享元类 /** * 具体享元类 */ class ConcreteChess implements ChessFlyWeight { private String color; public ConcreteChess(String color) { super(); this.color = color; } @Override public void display(Coordinate c) { System.out.println(&quot;棋子颜色：&quot;+color); System.out.println(&quot;棋子位置：&quot;+c.getX()+&quot;----&quot;+c.getY()); } @Override public String getColor() { return color; } @Override public void setColor(String c) { this.color = c; } } 步骤3：定义非共享享元类 /** * 外部状态 UnSharedConcreteFlyWeight */ public class Coordinate { private int x,y; public Coordinate(int x, int y) { super(); this.x = x; this.y = y; } public int getX() { return x; } public void setX(int x) { this.x = x; } public int getY() { return y; } public void setY(int y) { this.y = y; } } 步骤4：定义享元工厂类 /** * 享元工厂类 */ public class ChessFlyWeightFactory { //享元池 private static Map&lt;String,ChessFlyWeight&gt; map = new HashMap&lt;String, ChessFlyWeight&gt;(); public static ChessFlyWeight getChess(String color){ if(map.get(color)!=null){ return map.get(color); }else{ ChessFlyWeight cfw = new ConcreteChess(color); map.put(color, cfw); return cfw; } } } 步骤5：测试 public class Client { public static void main(String[] args) { ChessFlyWeight chess1 = ChessFlyWeightFactory.getChess(&quot;黑色&quot;); ChessFlyWeight chess2 = ChessFlyWeightFactory.getChess(&quot;黑色&quot;); System.out.println(chess1); System.out.println(chess2); System.out.println(&quot;增加外部状态的处理===========&quot;); chess1.display(new Coordinate(10, 10)); chess2.display(new Coordinate(20, 20)); } } 测试结果如下图所示： 如果想了解更多设计模式，可点击：设计模式概述 以及 23种设计模式的介绍]]></content>
      <categories>
        <category>Java</category>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[外观模式详解 (附java语言源码)]]></title>
    <url>%2F2019%2F06%2Fjava%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F20190613_%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[外观模式（Facade Pattern）： 为子系统中的一组接口提供一个一致的接口。Façade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。（Provide a unified interface to a set of interfaces in a subsystem. Façade defines a higher-level interface that makes the subsystem easier to use.） 外观模式核心： 为子系统提供统一的入口。封装子系统的复杂性，便于客户端调用。使得客户端和子系统之间解耦，让子系统内部的模块功能更容易扩展和维护； 根据迪米特法则(最少知识原则)： 一个软件实体应当尽可能少的与其他实体发生相互作用。 开发中常见的场景 ： 应用频率很高。哪里都会遇到。各种技术和框架中，都有外观模式的使用。如：JDBC封装后的，commons提供的DBUtils类，Hibernate提供的工具类、Spring JDBC工具类等 简单来说，该模式就是把一些复杂的流程封装成一个接口供给外部用户更简单的使用。这个模式中，设计到3个角色。 1）子系统角色 : 实现了子系统的功能。它对客户角色和Facade时未知的。它内部可以有系统内的相互交互，也可以由供外界调用的接口。 2） 门面角色：外观模式的核心。它被客户角色调用，它熟悉子系统的功能。内部根据客户角色的需求预定了几种功能的组合。 3）客户角色 : 通过调用Facede来完成要实现的功能。 案例：比如，注册公司流程，分三步：步骤1：定义子系统角色 /** * 工商局 */ public interface 工商局 { void checkName(); //核名 } class 海淀区工商局 implements 工商局 { @Override public void checkName() { System.out.println(&quot;检查名字是否有冲突！&quot;); } } /** * 质检局 */ public interface 质检局 { void orgCodeCertificate(); //办理组织机构代码证 } class 海淀质检局 implements 质检局 { @Override public void orgCodeCertificate() { System.out.println(&quot;在海淀区质检局办理组织机构代码证！&quot;); } } /** * 税务局 */ public interface 税务局 { void taxCertificate(); //办理税务登记证 } class 海淀税务局 implements 税务局 { @Override public void taxCertificate() { System.out.println(&quot;在海淀税务局办理税务登记证！&quot;); } } /** * 银行 */ class 中国工商银行 implements 银行 { @Override public void openAccount() { System.out.println(&quot;在中国工商银行开户！&quot;); } } 步骤2：定义门面角色 /** * 门面角色：办理注册公司流程的门面对象 */ public class RegisterFacade { public void register(){ 工商局 a = new 海淀区工商局(); a.checkName(); 质检局 b = new 海淀质检局(); b.orgCodeCertificate(); 税务局 c = new 海淀税务局(); c.taxCertificate(); 银行 d = new 中国工商银行(); d.openAccount(); } } 步骤3：定义客户角色 /** * 客户端调用 */ public class Client1 { public static void main(String[] args) { new RegisterFacade().register(); } } 执行结果如下图所示：客户端不需要知道系统内部的实现细节，甚至都不用知道系统内部的构成。客户端只需要跟Facade交互就可以了。 最后以一个图片来解释外观模式的好处： 如果想了解更多设计模式，可点击：设计模式概述 以及 23种设计模式的介绍]]></content>
      <categories>
        <category>Java</category>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Selenium显示等待和隐式等待的区别]]></title>
    <url>%2F2019%2F06%2Fpython%2Fspider%2Fselenium%2F20190612_%E9%9A%90%E5%BC%8F%E5%92%8C%E6%98%BE%E7%A4%BA%E7%AD%89%E5%BE%85%2F</url>
    <content type="text"><![CDATA[selenium的显示等待原理：显示等待，就是明确的要等到某个元素的出现或者是某个元素的可点击等条件，等不到，就一直等，除非在规定的时间之内都没找到，那么久跳出Exception(简而言之，就是直到元素出现才去操作，如果超时则报异常) from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC driver = webdriver.Chrome() driver.get(&#39;http://www.baidu&#39;) element = WebDriverWait(driver,5,0.5).util( EC.presence_of_element_located((By.ID,&#39;kw&#39;)) ) element.send_keys(&#39;hello&#39;) driver.quit() WebDriverWait(driver,timeout,poll_frequency=0.5,ignored_exceptions=None) driver:浏览器驱动 timeout:最长超过时间，默认以秒为单位 poll_frequency:监测的时间间隔，默认为0.5秒 ignored_exceptions:超时后的异常信息，默认情况下抛NoSuchElementException异常 WebDriverWait一般有until和until_not方法配合使用 until(method,message) until_not(method ,message) selenium的隐式等待原理：隐式等待，就是在创建driver时，为浏览器对象创建一个等待时间，这个方法是得不到某个元素就等待一段时间，直到拿到某个元素位置。注意：在使用隐式等待的时候，实际上浏览器会在你自己设定的时间内部断的刷新页面去寻找我们需要的元素 from selenium import webdriver from selenium.webdriver.common.by import By from selenium.webdriver.support.ui import WebDriverWait from selenium.webdriver.support import expected_conditions as EC driver = webdriver.Chrome() driver.implicitly_wait(10) driver.get(&#39;http://www.baidu&#39;) implicitly_wait()默认参数的单位为妙，本例中设置等待时长为10秒，首先这10秒并非一个固定的等待时间，它并不影响脚本的执行速度。其次，它并不针对页面上的某一元素进行等待。当脚本执行到某个元素定位是，如果元素可以定位，则继续执行，如果元素定位不到，则它将以轮询的方式不断地判断元素是否被定位到。假设在第六秒定位到了元素则继续执行，若直到超出设置的时长10秒还没有定位到元素，则抛出异常。]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
        <category>selenium</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
        <tag>selenium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合模式详解 (附java语言源码)]]></title>
    <url>%2F2019%2F06%2Fjava%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F20190611_%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[组合模式（Composite Pattern）： 将对象组合成树形结构以表示“部分-整体”的层次结构。Composite 使得客户对单个对象和复合对象的使用具有一致性。（Compose object into tree structures torepresent part-whole hierarchy. Composite lets clients treat individual objectsand compositions of objects uniformly.） 组合模式的优缺点：优点： 可以清楚地定义分层次的复杂类型，表示对象的全部层次或者部分层次 ，它让客户端忽略了层次的差异，方便对整个层次经行控制。 客户端可以一致的使用一个组合模式或对单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端的代码。 在组合模式种增加新的容器构件和叶子构件都很方便，无需对现有类库进行任何修改，符合开闭原则。 为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合可以形成复杂的树形机构，但对树形结构的控制却很简单。 缺点： 在增加新的构件时就比较难咯。而且难以限定，有时候希望在一个容器种能有某些特定的对象，例如在某个文件夹只能有image或者gif等。这个就比较难以实现。 开发中的应用场景： 操作系统的资源管理器 GUI中的容器层次图 XML文件解析 OA系统中，组织结构的处理 Junit单元测试框架 : 底层设计就是典型的组合模式，TestCase(叶子)、TestUnite(容器)、Test接口(抽象) 组合模式核心 ： component (抽象构件：容器)：它可以是接口或者抽象类，为叶子构建和子容器构建对象声明接口，在该角色中可以包含所有子类共有的行为的实现和声明。在抽象构建中定义了访问及管理它的子构件的方法，如增加子构件，删除子构件，获取子构件等。它定义了叶子和容器构件的共同点 leaf(叶子构建)：叶子构建可以说就是各种类型的文件！叶子构建没有子构件。它实现了抽象构建中的定义的行为。对于那些访问子容器，删除子容器，增加子容器的就报错。 compsite(子容器构建)：它在组合模式中表示容器节点对象，容器结点是子节点，可以是子容器，也可以是叶子构建，它提供一个集合来存储子节点。它有容器特征，可以包含子节点 案例：使用组合模式，模拟杀毒软件，该软件能够对某个文件夹杀毒，也可以指定对某些文件杀毒。该过程大致可分为4步，代码如下：步骤1：定义AbstractFile : 抽象文件类，充当抽象构建。 /** * AbstractFile: 抽象文件类，充当抽象构建。 */ public abstract class AbstractFiles { public abstract void add(AbstractFiles af); public abstract void remove(AbstractFiles af); public abstract AbstractFiles get(int i); public abstract void killVirus(); } 步骤2：定义叶子节点：文件类型，在此只写了图片文件。 /** * 图片文件,继承自AbstractFiles */ public class ImageFile extends AbstractFiles { private String name; public ImageFile(String name) { this.name = name; } @Override public void add(AbstractFiles af) { System.out.println(&quot;不支持该方法&quot;); } @Override public void remove(AbstractFiles af) { System.out.println(&quot;不支持该方法&quot;); } @Override public AbstractFiles get(int i) { System.out.println(&quot;不支持该方法&quot;); return null; } @Override public void killVirus() { System.out.println(&quot;开始进行--&quot;+name+&quot;--文件杀毒&quot;); } } 步骤3：文件夹类型 import java.util.ArrayList; /** * 文件夹类型 ，继承自AbstractFiles */ public class Folder extends AbstractFiles { //文件夹类，所有的都可以用 private ArrayList&lt;AbstractFiles&gt; list = new ArrayList&lt;AbstractFiles&gt;(); private String name; public Folder(String name) { this.name=name; } @Override public void add(AbstractFiles af) { list.add(af); System.out.println(&quot;添加文件成功！&quot;); } @Override public void remove(AbstractFiles af) { if(list.remove(af)) { System.out.println(&quot;删除成功&quot;); }else{ System.out.println(&quot;删除失败&quot;); } } @Override public AbstractFiles get(int i) { return list.get(i); } @Override public void killVirus() { System.out.println(&quot;对文件夹 &quot;+name+&quot; 进行杀毒&quot;); //递归调用 for(Object o:list) { ((AbstractFiles) o).killVirus(); } } } 步骤4：测试 /** * 测试 */ public class Client { public static void main(String[] args) { //创建一个文件类型 AbstractFiles f1 = new Folder(&quot;主文件夹&quot;); //创建文件 AbstractFiles file1= new ImageFile(&quot;美妙月亮。png&quot;); AbstractFiles file2= new ImageFile(&quot;大海.jpg&quot;); AbstractFiles file3= new ImageFile(&quot;沙漠杨树.gif&quot;); f1.add(file1); f1.add(file2); f1.add(file3); //file1.killVirus(); f1.killVirus(); } } 测试结果如下图所示： 如果想了解更多设计模式，可点击：设计模式概述 以及 23种设计模式的介绍]]></content>
      <categories>
        <category>Java</category>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桥接模式详解 (附java语言源码)]]></title>
    <url>%2F2019%2F06%2Fjava%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F20190611_%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[桥接模式（Bridge Pattern） ： 将抽象部分与它的实现部分分离，使他们都可以独立地变化。（Decouple an abstraction from its implementation so that the two can vary independently.） 就像一个桥，将两个变化维度连接起来。各个维度都可以独立的变化。故称之为：桥接模式 核心要点 ： 处理多层继承结构，处理多维度变化的场景，将各个维度设计成独立的继承结构，使各个维度可以独立的扩展在抽象层建立关联。 桥接模式优点： 分离抽象部分和实现部分：桥梁模式分离了抽象部分和实现部分，从而极大的提高了系统的灵活性。让抽象部分和实现部分独立出来，分别定义接口，这有助于对系统进行分层，从而产生更好的结构化的系统。 更好的扩展性：桥梁模式使得抽象部分和实现部分可以分别独立的扩展，而不会相互影响，从而大大提高了系统的可扩展性。 桥接模式实际开发中应用场景: JDBC驱动程序; AWT中的Peer架构; 银行日志管理： 格式分类：操作日志、交易日志、异常日志距离分类：本地记录日志、异地记录日志 人力资源系统中的奖金计算模块： 奖金分类：个人奖金、团体奖金、激励奖金。部门分类：人事部门、销售部门、研发部门。 OA系统中的消息处理： 业务类型：普通消息、加急消息、特急消息发送消息方式：系统内消息、手机短信、邮件 案例一：考虑这样一个实际的业务功能：发送提示消息。基本上所有带业务流程处理的系统都会有这样的功能，比如OA上有未处理完毕的文件，需要发送一条消息提示他。从业务上看，消息又分为普通消息、加急消息，不同的消息类型，业务功能处理是不一样的，比如加急消息是在消息上添加加急；从发送消息的手段上看，又有系统内短消息、邮件等。该过程可分为5步：步骤1：定义发送消息方法的接口 /** * 实现消息发送的统一接口 */ public interface MessageImplementor { //要发送的消息的内容和接收人 void send(String message, String toUser); } 步骤2：定义发送消息方法接口的实现类 /** * 系统内短消息的实现类 * SMS(Short Message Service)短信息服务 */ public class MessageSMS implements MessageImplementor { @Override public void send(String message, String toUser) { System.out.println(String.format(&quot;使用系统内部短消息的方法，发送消息 %s 给 %s&quot;, message, toUser)); } } /** * 邮件短消息的实现类 */ public class MessageEmail implements MessageImplementor { @Override public void send(String message, String toUser) { System.out.println(String.format(&quot;使用邮件短消息的方法，发送消息 %s 给 %s&quot;, message, toUser)); } } 步骤3：定义抽象消息类 /** * 抽象消息类 */ public abstract class AbstractMessage { //持有一个实现部分的对象 MessageImplementor implementor; //构造方法，传入实现部分的对象 public AbstractMessage(MessageImplementor implementor) { this.implementor = implementor; } //发送消息，委派给实现部分的方法 public void sendMessage(String message, String toUser) { this.implementor.send(message, toUser); } } 步骤4：定义普通消息类和加急消息类，继承抽象消息类 /** * 普通消息类 */ public class CommonMessage extends AbstractMessage { //构造方法，传入实现部分的对象 public CommonMessage(MessageImplementor implementor) { super(implementor); } @Override public void sendMessage(String message, String toUser) { //对于普通消息，直接调用父类方法，发送消息即可 super.sendMessage(message, toUser); } } /** * 加急消息类 */ public class UrgencyMessage extends AbstractMessage { //构造方法 public UrgencyMessage(MessageImplementor implementor) { super(implementor); } @Override public void sendMessage(String message, String toUser) { message = &quot;加急：&quot; + message; super.sendMessage(message, toUser); } //扩展它自己的功能，监控某个消息的处理状态 public Object watch(String messageId) { //根据给出的 消息编码(messageId) 查询消息的处理状态， // 组织成监控的处理状态，然后返回。 return null; } } 步骤5：测试 /** * 测试类 */ public class TestBridge { public static void main(String[] args) { MessageImplementor implementor = new MessageSMS(); AbstractMessage abstractMessage = new CommonMessage(implementor); abstractMessage.sendMessage(&quot;加班申请速批&quot;, &quot;陈总&quot;); implementor = new MessageEmail(); abstractMessage = new UrgencyMessage(implementor); abstractMessage.sendMessage(&quot;加班申请速批&quot;, &quot;陈总&quot;); } } 测试结果如下图所示： 案例二：桥接的用意是：将抽象化与实现化解耦，使得二者可以独立变化，像我们常用的JDBC桥DriverManager一样，JDBC进行连接数据库的时候，在各个数据库之间进行切换，基本不需要动太多的代码，甚至丝毫不用动，原因就是JDBC提供统一接口，每个数据库提供各自的实现，用一个叫做数据库驱动的程序来桥接就行了。类图如下：该过程大致也分为5步：步骤1：定义接口 public interface Sourceable { public void method(); } 步骤2：定义接口的实现类 public class SourceSub1 implements Sourceable { @Override public void method() { System.out.println(&quot;this is the first sub!&quot;); } } public class SourceSub2 implements Sourceable { @Override public void method() { System.out.println(&quot;this is the second sub!&quot;); } } 步骤3：定义抽象类 public abstract class Bridge { private Sourceable source; public void method(){ source.method(); } // getter/setter方法 public Sourceable getSource() { return source; } public void setSource(Sourceable source) { this.source = source; } } 步骤4：继承这个抽象类 public class MyBridge extends Bridge { public void method(){ getSource().method(); } } 步骤5：测试 public class BridgeTest { public static void main(String[] args) { Bridge bridge = new MyBridge(); //调用第一个对象 Sourceable source1 = new SourceSub1(); bridge.setSource(source1); bridge.method(); //调用第二个对象 Sourceable source2 = new SourceSub2(); bridge.setSource(source2); bridge.method(); } } 测试结果如下图所示：这样，就通过对Bridge类的调用，实现了对接口Sourceable的实现类SourceSub1和SourceSub2的调用。下图是JDBC连接的原理，有数据库学习基础的，一结合就都懂了。 如果想了解更多设计模式，可点击：设计模式概述 以及 23种设计模式的介绍]]></content>
      <categories>
        <category>Java</category>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适配器模式详解 (附java语言源码)]]></title>
    <url>%2F2019%2F06%2Fjava%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F20190605_%E9%80%82%E9%85%8D%E5%99%A8%2F</url>
    <content type="text"><![CDATA[适配器模式（Adapter Pattern）： 将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。（Convert the interface of a class into another interface clients except. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces.） 定义一个包装类，用于包装不兼容接口的对象： 包装类 = 适配器Adapter； 被包装对象 = 适配者Adaptee = 被适配的类 使用场景： 系统需要复用现有类，而该类的接口不符合系统的需求，可以使用适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。 多个组件功能类似，但接口不统一且可能会经常切换时，可使用适配器模式，使得客户端可以以统一的接口使用它们 需要一个统一的输出接口，但是输入类型却不可预知。 主要作用：把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。 类的适配器模式和对象的适配器模式的选择： 适配器模式的形式分为：类的适配器模式 &amp; 对象的适配器模式 灵活使用时：选择对象的适配器模式，类适配器使用对象继承的方式，是静态的定义方式；而对象适配器使用对象组合的方式，是动态组合的方式。 需要同时配源类和其子类：选择对象的适配器，对于对象适配器，一个适配器可以把多种不同的源适配到同一个目标。 需要重新定义Adaptee的部分行为：选择类适配器。对于类适配器，适配器可以重定义Adaptee的部分行为，相当于子类覆盖父类的部分实现方法。对于对象适配器，要重定义Adaptee的行为比较困难。 仅仅希望使用方便时：选择类适配器，对于类适配器，仅仅引入了一个对象，并不需要额外的引用来间接得到Adaptee。对于对象适配器，需要额外的引用来间接得到Adaptee。 下面以一个案例来介绍设配器模式：该过程大概分成4步： 步骤1：定义目标接口（Target）：客户所期待的接口。目标可以是具体的或抽象的类，也可以是接口。 public interface Target { void handleReq(); } 步骤2：定义 需要适配的类（Adaptee）：需要适配的类或适配者类。 /** * 被适配的类 * (相当于例子中的，PS/2键盘) */ public class Adaptee { public void request(){ System.out.println(&quot;可以完成客户请求的需要的功能！&quot;); } } 步骤3：定义适配器（Adapter）：通过包装一个需要适配的对象，把原接口转换成目标接口。 类适配器方式: /** * 适配器 (类适配器方式) * (相当于usb和ps/2的转接器) */ public class Adapter extends Adaptee implements Target { @Override public void handleReq() { super.request(); } } 对象适配器方式: /** * 适配器 (对象适配器方式,使用了组合的方式跟被适配对象整合) * (相当于usb和ps/2的转接器) */ public class Adapter2 implements Target { private Adaptee adaptee; @Override public void handleReq() { adaptee.request(); } public Adapter2(Adaptee adaptee) { super(); this.adaptee = adaptee; } } 步骤4：测试 /** * 客户端类:测试 */ public class Client { public void test1(Target t){ t.handleReq(); } public static void main(String[] args) { Client c = new Client(); Adaptee a = new Adaptee(); // Target t = new Adapter(); Target t = new Adapter2(a); c.test1(t); } } 测试结果如下图所示： 如果想了解更多设计模式，可点击：设计模式概述 以及 23种设计模式的介绍]]></content>
      <categories>
        <category>Java</category>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型模式详解 (附java语言源码)]]></title>
    <url>%2F2019%2F06%2Fjava%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F20190604_%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[原型模式（Prototype Pattern）: 用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。(Specify the kinds of objects to create using a prototypical instance, and create new objects by copying the prototype.) 通过原型模式，绕过构造方法创建对象，利用内存直接拷贝对象，提高对象的创建性效率。在有大量的对象创建或者类初始化消耗多资源的场景下可以利用原型模式来优化。当然在实现的过程中，要注意浅拷贝与深拷贝的问题，防止写出 bug。 浅拷贝和深拷贝 : 浅拷贝（浅克隆） ：浅复制仅仅复制所考虑的对象，而不复制它所引用的对象。深拷贝（深克隆） ：深复制把要复制的对象所引用的对象都复制了一遍。 可以利用串行化来做深复制，所谓对象序列化就是将对象的状态转换成字节流，以后可以通过这些值再生成相同状态的对象。 开发中的应用场景 ： 原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者。 spring中bean的创建实际就是两种：单例模式和原型模式。（当然，原型模式需要和工厂模式搭配起来）。 如果需要短时间创建大量对象，并且new的过程比较耗时。则可以考虑使用原型模式！ 很多软件提供的CTRL+C和CTRL+V操作的就是原型模式的典型应用！ 可以看一下:普通new方式创建对象和clone方式创建对象的效率差异 /** * 如果需要短时间创建大量对象，并且new的过程比较耗时。则可以考虑使用原型模式！ */ public class Client4 { public static void main(String[] args) throws Exception { testNew(1000); testClone(1000); } public static void testNew(int size){ long start = System.currentTimeMillis(); for(int i=0;i&lt;size;i++){ Laptop t = new Laptop(); } long end = System.currentTimeMillis(); System.out.println(&quot;new的方式创建耗时：&quot;+(end-start)); } public static void testClone(int size) throws CloneNotSupportedException{ long start = System.currentTimeMillis(); Laptop t = new Laptop(); for(int i=0;i&lt;size;i++){ Laptop temp = (Laptop) t.clone(); } long end = System.currentTimeMillis(); System.out.println(&quot;clone的方式创建耗时：&quot;+(end-start)); } } class Laptop implements Cloneable { //笔记本电脑 public Laptop() { try { Thread.sleep(10); //模拟创建对象耗时的过程! } catch (InterruptedException e) { e.printStackTrace(); } } @Override protected Object clone() throws CloneNotSupportedException { Object obj = super.clone(); //直接调用object对象的clone()方法！ return obj; } } 执行结果如下图所示：由此可见 : 如果需要短时间创建大量对象，并且new的过程比较耗时。则可以考虑使用原型模式！ 再看原型模式的例子： 案例有以下三步： 步骤一： import java.io.Serializable; /** * 工作经历实现序列化接口 */ public class WorkExperience implements Serializable { private static final long serialVersionUID = 1L; private String workDate; private String company; //提供getter/setter方法 public String getWorkDate() { return workDate; } public void setWorkDate(String workDate) { this.workDate = workDate; } public String getCompany() { return company; } public void setCompany(String company) { this.company = company; } } 步骤二： import java.io.*; public class People implements Serializable,Cloneable { private static final long serialVersionUID = 1L; private String name; private String sex; private Integer age; private WorkExperience work; public People(String name) { this.name = name; work = new WorkExperience(); } //设置个人信息 public void setPersonalInfo(String sex , Integer age) { this.sex=sex; this.age=age; } //设置工作经历 public void setWorkExperience(String workDate,String company) { work.setWorkDate(workDate); work.setCompany(company); } //显示 public void display(){ System.out.println(String.format(&quot;%s %s %s&quot;, name,sex,age)); System.out.println(String.format(&quot;工作经历：%s %s&quot;, work.getWorkDate(), work.getCompany())); } //浅复制 public Object clone(){ Object obj = null; try{ obj = super.clone(); }catch (CloneNotSupportedException e){ e.printStackTrace(); } return obj; } //深复制 public Object deepClone () throws IOException,ClassNotFoundException { //将对象写入流中，使用序列化和反序列化实现深复制 ByteArrayOutputStream bo = new ByteArrayOutputStream(); ObjectOutputStream oo = new ObjectOutputStream(bo); oo.writeObject(this); //从流中读出来 ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray()); ObjectInputStream oi = new ObjectInputStream(bi); return (oi.readObject()); } } 步骤三：测试类 /** * 测试类 */ public class TestPrototype { public static void main(String[] args) throws IOException,ClassNotFoundException { People p1 = new People(&quot;张三&quot;); p1.setPersonalInfo(&quot;男&quot;,23); p1.setWorkExperience(&quot;2016-2019&quot;,&quot;百度&quot;); People clone = (People) p1.clone(); //浅复制 clone.setPersonalInfo(&quot;男&quot;,20); clone.setWorkExperience(&quot;2017-2022&quot;,&quot;腾讯&quot;); p1.display(); clone.display(); People p2 = new People(&quot;李四&quot;); p2.setPersonalInfo(&quot;女&quot;,20); p2.setWorkExperience(&quot;2018-2020&quot;,&quot;美团&quot;); People deepClone = (People)p2.deepClone(); //深复制 deepClone.setPersonalInfo(&quot;女&quot;,22); deepClone.setWorkExperience(&quot;2018-2019&quot;,&quot;百度外卖&quot;); p2.display(); deepClone.display(); } } 测试结果如下图所示： 如果想了解更多设计模式，可点击：设计模式概述 以及 23种设计模式的介绍]]></content>
      <categories>
        <category>Java</category>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式详解 (附java语言源码)]]></title>
    <url>%2F2019%2F06%2Fjava%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F20190603_%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[代理模式（Proxy Pattern）: 为其他对象提供一个代理以控制对这个对象的访问。(Provide a surrogate or placeholder foranther object to control access to it.) 可以详细控制访问某个（某类）对象的方法，在调用这个方法前做前置处理，调用这个方法后做后置处理。 分类： 静态代理(静态定义代理类) 动态代理(动态生成代理类) : JDK自带的动态代理， javaassist字节码操作库实现,CGLIB，ASM(底层使用指令，可维护性较差) JDK自带的动态代理 : java.lang.reflect.Proxy , 作用：动态生成代理类和对象 java.lang.reflect.InvocationHandler(处理器接口) , 可以通过invoke方法实现对真实角色的代理访问。每次通过Proxy生成代理类对象对象时都要指定对应的处理器对象 动态代理相比于静态代理的优点抽象角色中(接口)声明的所以方法都被转移到调用处理器一个集中的方法中处理，这样，我们可以更加灵活和统一的处理众多的方法。 应用场景： 安全代理：屏蔽对真实角色的直接访问。 远程代理：通过代理类处理远程方法调用(RMI)。 延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象。( 比如你要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有100MB，在打开文件时不可能将所有的图片都显示出来，这样就可以使用代理模式，当需要查看图片时，用proxy来进行大图片的打开。) 开发框架中应用场景：实际上，随便选择一个技术框架都会用到代理模式！ struts2中拦截器的实现; 数据库连接池关闭处理; Hibernate中延时加载的实现; AspectJ的实现 , spring中AOP的实现; mybatis中实现拦截器插件; 日志拦截; 声明式事务处理; web service; RMI远程方法调用 核心角色： 抽象角色：定义代理角色和真实角色的公共对外方法； 真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用，– 关注真正的业务逻辑！； 代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。 将统一的流程控制放到代理角色中处理！ 静态代理：静态代理在使用时,需要定义接口或者父类,被代理对象与代理对象一起实现相同的接口或者是继承相同父类。下面举个案例来解释:模拟保存动作,定义一个保存动作的接口:IUserDao.java,然后目标对象实现这个接口的方法UserDao.java,此时如果使用静态代理方式,就需要在代理对象(UserDaoProxy.java)中也实现IUserDao接口.调用的时候通过调用代理对象的方法来调用目标对象.该过程需要以下四步： 第一步：定义接口:IUserDao.java /** * 接口 */ public interface IUserDao { void save(); } 第二步：定义目标对象:UserDao.java /** * 接口实现目标数据 */ public class UserDao implements IUserDao { @Override public void save() { System.out.println(&quot;------已经保存数据！------&quot;); } } 第三步：定义代理对象:UserDaoProxy.java /** * 代理对象，静态代理 */ public class UserDaoProxy implements IUserDao{ // //接收保存目标对象 private IUserDao iUserDao; public UserDaoProxy(IUserDao iUserDao) { this.iUserDao = iUserDao; } @Override public void save() { System.out.println(&quot;开始事务...&quot;); iUserDao.save();//执行目标对象的方法 System.out.println(&quot;提交事务...&quot;); } } 第四步：测试：TestProxy.java /** * 测试 */ public class TestProxy { public static void main(String[] args) { //目标对象 UserDao target = new UserDao(); //代理对象,把目标对象传给代理对象,建立代理关系 UserDaoProxy proxy = new UserDaoProxy(target); //执行的是代理的方法 proxy.save(); } } 测试结果如下图所示:静态代理可以做到在不修改目标对象的功能前提下,对目标功能扩展。但有可能因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多。同时,一旦接口增加方法,目标对象与代理对象都要维护.如何解决静态代理中的缺点呢? 答案是可以使用动态代理方式 动态代理：也叫做:JDK代理,接口代理 动态代理有以下特点: 代理对象,不需要实现接口； 代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型)总结：代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能用动态代理 比如对于上面的案例：接口类IUserDao.java以及接口实现类,目标对象UserDao是一样的,没有做修改.在这个基础上,增加一个代理工厂类(ProxyFactory.java),将代理类写在这个地方,然后在测试类(需要使用到代理的代码)中先建立目标对象和代理对象的联系,然后代用代理对象的中同名方法 代理工厂类:ProxyFactory.java import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; /** * 创建动态代理对象 * 动态代理不需要实现接口,但是需要指定接口类型 */ public class ProxyFactory { //维护一个目标对象 private Object target; public ProxyFactory(Object target){ this.target=target; } //给目标对象生成代理对象 public Object getProxyInstance(){ return Proxy.newProxyInstance( target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(&quot;开始事务2&quot;); //执行目标对象方法 Object returnValue = method.invoke(target, args); System.out.println(&quot;提交事务2&quot;); return returnValue; } } ); } } 测试类：TestDynamicProxy.java /** * 测试 */ public class TestDynamicProxy { public static void main(String[] args) { // 目标对象 IUserDao target = new UserDao(); // 【原始的类型 class designpattern.proxy.UserDao】 System.out.println(target.getClass()); // 给目标对象，创建代理对象 IUserDao proxy = (IUserDao) new ProxyFactory(target).getProxyInstance(); // class $Proxy0 内存中动态生成的代理对象 System.out.println(proxy.getClass()); // 执行方法 【代理对象】 proxy.save(); } } 测试结果如下图所示： 如果想了解更多设计模式，可点击：设计模式概述 以及 23种设计模式的介绍]]></content>
      <categories>
        <category>Java</category>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂模式详解 (附java语言源码)]]></title>
    <url>%2F2019%2F05%2Fjava%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F20190531_%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[工厂模式（Factory Pattern）： 定义一个用于创建对象的接口，让子类决定将哪一个类实例化，FactoryMethod使一个类的实例化延迟到其子类。（Define an interface for creating anobject, but let subclasses decide which class to instantiate. Factory methodlets a class defer instantiation to subclasses.） 工厂模式，也叫作静态工厂模式，顾名思义，就是用来生产对象的，在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则，如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：解耦 核心本质： 实例化对象，用工厂方法代替new操作； 将选择实现类、创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。实现了创建者和调用者的分离。 应用场景： JDK中Calendar的getInstance方法； JDBC中Connection对象的获取； Hibernate中SessionFactory创建Session； spring中IOC容器创建管理bean对象； XML解析时的DocumentBuilderFactory创建解析器对象； 反射中Class对象的newInstance() 详细分类： 简单工厂模式：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）；虽然某种程度不符合设计原则，但实际使用最多。 工厂方法模式：用来生产同一等级结构中的固定产品。（支持增加任意产品）；不修改已有类的前提下，通过增加新的工厂类实现扩展。 抽象工厂模式：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）；不可以增加产品，可以增加产品族！ 工厂方法模式和简单工厂模式区别： 简单工厂模式只有一个（对于一个项目或者一个独立模块而言）工厂类，而工厂方法模式有一组实现了相同接口的工厂类。 结构复杂度：从这个角度比较，显然简单工厂模式要占优。简单工厂模式只需一个工厂类，而工厂方法模式的工厂类随着产品类个数增加而增加，这无疑会使类的个数越来越多，从而增加了结构的复杂程度。 代码复杂度：代码复杂度和结构复杂度是一对矛盾，既然简单工厂模式在结构方面相对简洁，那么它在代码方面肯定是比工厂方法模式复杂的了。简单工厂模式的工厂类随着产品类的增加需要增加很多方法（或代码），而工厂方法模式每个具体工厂类只完成单一任务，代码简洁。 客户端编程难度：工厂方法模式虽然在工厂类结构中引入了接口从而满足了OCP，但是在客户端编码中需要对工厂类进行实例化。而简单工厂模式的工厂类是个静态类，在客户端无需实例化，这无疑是个吸引人的优点。 面向对象设计的基本原则： OCP（开闭原则，Open-Closed Principle）：一个软件的实体应当对扩展开放，对修改关闭。 DIP（依赖倒转原则，Dependence Inversion Principle）：要针对接口编程，不要针对实现编程。 LoD（迪米特法则，Law of Demeter）：只与你直接的朋友通信，而避免和陌生人通信。 简单工厂模式例子： 比如，小明骑自行车去学校，开汽车去旅游，可用简单工厂模式实现： 第一步：建一个交通工具接口，汽车和自行车都实现这个接口 /** * 交通工具 */ interface IVehicle { void run(); } //汽车 class Car implements IVehicle{ @Override public void run() { System.out.println(&quot;开汽车去。。。&quot;); } } //自行车 class Bicycle implements IVehicle{ @Override public void run() { System.out.println(&quot;骑自行车去。。。&quot;); } } 第二步：创建一个车库，判断去选自行车还是选汽车 //车库 public class GarageFactory { public static IVehicle getVehicle(String type) { if (&quot;car&quot;.equals(type)) { return new Car(); } else if (&quot;bicycle&quot;.equals(type)) { return new Bicycle(); } throw new IllegalArgumentException(&quot;请输入车类型&quot;); } } 第三步：测试 public class TestSimpleFactory { public static void main(String[] args) { XiaoMing xiaoMing = new XiaoMing(); // 小明骑自行车去学校 IVehicle motorcycle = GarageFactory.getVehicle(&quot;bicycle&quot;); xiaoMing.goToSchool(motorcycle); // 小明开汽车去旅游 IVehicle car = GarageFactory.getVehicle(&quot;car&quot;); xiaoMing.travel(car); } } class XiaoMing{ public void goToSchool(IVehicle vehicle){ System.out.println(&quot;小明去学校：&quot;); vehicle.run(); } public void travel(IVehicle vehicle){ System.out.println(&quot;小明去旅游：&quot;); vehicle.run(); } } 控制台打印结果如下： 简单工厂模式拓展性不好，优秀的java代码是符合“开放-封闭”原则的，也就是说对扩展开发，对修改关闭，如果想骑电动车去上班，在这里就要增加if-else判断。对于这个问题，我们的工厂方法模式就可以解决这个问题。 工厂方法模式例子： 根据上面的例子，如果有车库，则可以按车类型来放置。只需要在上面例子的基础上，再加2步。 第一步：建一个车库接口，汽车和自行车都实现这个接口。 public interface VehicleGarage { IVehicle getVehicle(); } //汽车车库 class CarGarage implements VehicleGarage{ @Override public IVehicle getVehicle() { return new Car(); } } //自行车车库 class BicycleGarage implements VehicleGarage{ @Override public IVehicle getVehicle() { return new Bicycle(); } } 第二步：测试 public class TestFactoryMethod { public static void main(String[] args) { XiaoMing xiaoMing = new XiaoMing(); //小明骑自行车去学校 BicycleGarage bicycleGarage = new BicycleGarage(); IVehicle bicycle = bicycleGarage.getVehicle(); xiaoMing.goToSchool(bicycle); //小明开汽车去旅游 CarGarage carGarage = new CarGarage(); IVehicle car = carGarage.getVehicle(); xiaoMing.travel(car); } } 控制台打印结果如下： 工厂方法模式可以说在你能想到的开源框架源码中必定会使用的一个设计模式，因为开源框架很重要一点就是要有扩展性，而工厂方法模式恰恰具有可扩展性。 如果想了解更多设计模式，可点击：设计模式概述 以及 23种设计模式的介绍]]></content>
      <categories>
        <category>Java</category>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象工厂模式详解 (附java语言源码)]]></title>
    <url>%2F2019%2F05%2Fjava%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F20190531_%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%2F</url>
    <content type="text"><![CDATA[抽象工厂模式（Abstract Factory Pattern）： 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。（Provide an interface for creating families of related or dependent object without specifying their concrete classes.） 抽象工厂模式是工厂方法模式的升级版本，在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。 工厂方法是在解决一个产品多个层级方面的事情；而抽象工厂致力于解决多个产品多个层级方面的事情。举个例子：汽车是由很多零件组成的，比如轮胎、方向盘等等。举个例子：汽车是由很多零件组成的，比如轮胎、方向盘等等。现在如果我们是轮胎生产方，要生产宝马轮胎和奔驰轮胎，要用工厂方法还是抽象工厂实现呢？答案是：工厂方法。轮胎是一个产品，宝马轮胎和奔驰轮胎是 2 个不同层级的轮胎，所以用工厂方法解决就足够。假如现在我们是汽车生产方，要生产宝马汽车和奔驰汽车，汽车又包含轮胎和方向盘等等，要用哪个来实现？既然是上面的是工厂方法，那这个就用抽象工厂，因为这涉及到多个产品（轮胎、方向盘等等）和 2 个层级（宝马和奔驰）。 上面定义中：为创建一组相关或相互依赖的对象提供一个接口。这样子理解这句话，比如上面说的轮胎和方向盘，宝马汽车用的轮胎和方向盘需要都是宝马品牌的，也就是说在安装宝马汽车的轮胎和方向盘的时候，得用宝马生产的轮胎和方向盘，重要的一点是：轮胎和方向盘是互相依赖的，不能在宝马汽车上安装奔驰轮胎和宝马方向盘，因为有这个依赖关系，所以我们需要提供一个额外的接口，来保证宝马汽车使用的轮胎和方向盘都是宝马生产的。这就是抽象工厂干的事情。 案例可以分为以下4步： 第一步：创建抽象汽车工厂接口，宝马工厂和奔驰工厂实现这个接口。 //抽象汽车工厂接口 public interface AbstractCarFactory { void installWheel(); void installSteeringWheel(); } //宝马工厂 class BMWCarFactory implements AbstractCarFactory { @Override public void installWheel() { BMWWheelFactory bmwWheelFactory = new BMWWheelFactory(); String wheel = bmwWheelFactory.createWheel(); System.out.println(&quot;安装轮胎:&quot;+wheel); } @Override public void installSteeringWheel() { BMWSteeringWheelFacatory bmwSteeringWheelFacatory = new BMWSteeringWheelFacatory(); String steeringWheel = bmwSteeringWheelFacatory.createSteeringWheel(); System.out.println(&quot;安装方向盘：&quot; + steeringWheel); } } //奔驰工厂 class MercedesCarFacatory implements AbstractCarFactory { @Override public void installWheel() { MercedesWheelFactory mercedesWheelFactory = new MercedesWheelFactory(); String wheel = mercedesWheelFactory.createWheel(); System.out.println(&quot;安装轮胎:&quot;+wheel); } @Override public void installSteeringWheel() { MercedesSteeringWheelFacatory mercedesSteeringWheelFacatory = new MercedesSteeringWheelFacatory(); String steeringWheel = mercedesSteeringWheelFacatory.createSteeringWheel(); System.out.println(&quot;安装方向盘：&quot; + steeringWheel); } } 第二步：创建轮胎工厂接口，宝马轮胎工厂和奔驰轮胎工厂实现这个接口。 //轮胎工厂接口 public interface WheelFacatory { String createWheel(); } //宝马轮胎工厂 class BMWWheelFactory implements WheelFacatory { @Override public String createWheel() { System.out.println(&quot;宝马轮胎工厂生产轮胎&quot;); return &quot;宝马轮胎&quot;; } } //奔驰轮胎工厂 class MercedesWheelFactory implements WheelFacatory { @Override public String createWheel() { System.out.println(&quot;奔驰轮胎工厂生产轮胎&quot;); return &quot;奔驰轮胎&quot;; } } 第三步：创建方向盘工厂接口，宝马方向盘工厂和奔驰方向盘工厂实现这个接口。 //方向盘工厂接口 public interface SteeringWheelFacatory { String createSteeringWheel(); } //宝马方向盘工厂 class BMWSteeringWheelFacatory implements SteeringWheelFacatory{ @Override public String createSteeringWheel() { System.out.println(&quot;宝马方向盘工厂生产方向盘&quot;); return &quot;宝马方向盘&quot;; } } //奔驰方向盘工厂 class MercedesSteeringWheelFacatory implements SteeringWheelFacatory{ @Override public String createSteeringWheel() { System.out.println(&quot;奔驰方向盘工厂生产方向盘&quot;); return &quot;奔驰方向盘&quot;; } } 第四步：测试类 //测试 public class AbstractFactoryTest { public static void main(String[] args) { // 宝马员工安装轮胎和方向盘 BMWCarFactory bmwCarFactory = new BMWCarFactory(); bmwCarFactory.installWheel(); bmwCarFactory.installSteeringWheel(); // 奔驰员工安装轮胎和方向盘 MercedesCarFacatory mercedesCarFacatory = new MercedesCarFacatory(); mercedesCarFacatory.installWheel(); mercedesCarFacatory.installSteeringWheel(); } } 测试结果如下图所示： 如果想了解更多设计模式，可点击：设计模式概述 以及 23种设计模式的介绍]]></content>
      <categories>
        <category>Java</category>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰模式详解 (附java语言源码)]]></title>
    <url>%2F2019%2F05%2Fjava%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F20190530_%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[装饰模式（Decorator Pattern）： 动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator模式比生成子类的方式更为灵活。（Attach additional responsibilities to an object dynamically. Decorators provides a flexible alternative to subclasses for extending functionality.） 装饰模式（Decorator）：也叫包装器模式（Wrapper），装饰模式是一种用于提代继承的技术，无需通过子类增加继承就能拓展对象的新功能；使用对象的关联关系提代继承关系，更加灵活，同时避免类型体系的快速膨胀。 开发中使用的场景： 典型应用场景就是：IO中输入流和输出流的设计； Swing包中图形界面构件功能； Servlet API 中提供了一个request对象的Decorator设计模式的默认实现类HttpServletRequestWrapper，HttpServletRequestWrapper类，增强了request对象的功能； Struts2中，request，response,session对象的处理 装饰模式的优缺点： 优点： 扩展对象功能，比继承灵活，不会导致类个数急剧增加； 可以对一个对象进行多次装饰，创造出不同行为的组合，得到功能更加强大的对象； 具体构建类和具体装饰类可以独立变化，用户可以根据需要自己增加新的具体构件子类和具体装饰子类。 缺点： 产生很多小对象。大量小对象占据内存，一定程度上影响性能； 装饰模式易于出错，调试排查比较麻烦。 装饰模式和桥接模式的区别：两个模式都是为了解决过多子类对象问题。但他们的诱因不一样。桥模式是对象自身现有机制沿着多个维度变化，是既有部分不稳定。装饰模式是为了增加新的功能。 案例：比如去吃小摊，主体有煎蛋，火腿片等等，每个配料的价格都不一样，不管你怎么配配料，最终价格是手抓饼基础价加上每一种所选配料价格的总和。小摊的价格单如下：用装饰者模式即可解决此问题，主体是手抓饼和肉夹馍，而配料则是装饰者：类图如下：功能的实现大概有以下5个步骤：步骤1：定义Component（被装饰对象的基类）抽象组件:定义一个抽象接口，来规范准备附加功能的类 /** * 定义一个对象接口，可以给这些对象动态地添加职责 */ public abstract class Pancake { public String desc = &quot;我不是一个具体的煎饼&quot;; public String getDesc(){ return desc; } public abstract double price(); } 步骤2：ConcreteComponent（具体被装饰对象）具体组件：将要被附加功能的类，实现抽象构件角色接口 手抓饼：`java/** 定义一个对象，可以给这个对象添加一些职责:手抓饼*/public class TornCake extends Pancake { public TornCake() { desc = &quot;手抓饼&quot;; } @Override public double price() { return 4; }} 2. 肉夹馍： ```java /** * 定义一个对象，可以给这个对象添加一些职责:肉夹馍 */ public class Roujiamo extends Pancake { public Roujiamo() { desc = &quot;肉夹馍&quot;; } @Override public double price() { return 6; } } 步骤3：Decorator（装饰者抽象类）抽象装饰者：维持一个指向Component实例的引用，并定义一个与Component接口一致的接口。 /** * 持有对具体构件角色的引用并定义与抽象构件角色一致的接口 */ public abstract class Condiment extends Pancake { public abstract String getDesc(); } 步骤4：ConcreteDecorator（具体装饰者）具体装饰： 实现抽象装饰者角色，负责对具体构件添加额外功能。 煎蛋：`java/** 具体的装饰对象，给内部持有的具体被装饰对象，增加具体的职责。 煎蛋：FiredEgg*/public class FiredEgg extends Condiment { private Pancake pancake; @Overridepublic String getDesc() { return pancake.getDesc()+&quot;,煎蛋&quot;; } @Overridepublic double price() { return pancake.price()+2; } public FiredEgg(Pancake pancake) {//构造器 this.pancake = pancake; }} 2. 火腿片 ```java /** * 具体的装饰对象，给内部持有的具体被装饰对象，增加具体的职责。 * 火腿片：Ham */ public class Ham extends Condiment { private Pancake pancake; @Override public String getDesc() { return pancake.getDesc() + &quot;, 火腿片&quot;; } @Override public double price() { return pancake.price() + 1.5; } public Ham(Pancake pancake) { this.pancake = pancake; } } 松肉 /** * 具体的装饰对象，给内部持有的具体被装饰对象，增加具体的职责。 * 松肉：MeatFloss */ public class MeatFloss extends Condiment { private Pancake pancake; @Override public String getDesc() { return pancake.getDesc()+&quot;,松肉&quot;; } @Override public double price() { return pancake.price()+1; } public MeatFloss(Pancake pancake) { this.pancake = pancake; } } 黄瓜丝 /** * 具体的装饰对象，给内部持有的具体被装饰对象，增加具体的职责。 * 黄瓜丝：Cucumber */ public class Cucumber extends Condiment { private Pancake pancake; @Override public String getDesc() { return pancake.getDesc()+&quot;,黄瓜丝&quot;; } @Override public double price() { return pancake.price()+0.5; } public Cucumber(Pancake pancake) { this.pancake = pancake; } } 步骤5：测试 /** * 测试类 * author https://blog.csdn.net/cui_yonghua/article/details/90512943 */ public class TestDecorator { public static void main(String[] args) { Pancake tornCake = new TornCake(); tornCake = new FiredEgg(tornCake); tornCake = new MeatFloss(tornCake); //手抓饼+煎蛋+松肉 的价格 System.out.println(String.format(&quot;%s ￥%s&quot;, tornCake.getDesc(), tornCake.price())); Pancake roujiamo = new Roujiamo(); roujiamo = new FiredEgg(roujiamo); roujiamo = new FiredEgg(roujiamo); roujiamo = new Ham(roujiamo); roujiamo = new MeatFloss(roujiamo); roujiamo = new Cucumber(roujiamo); //肉夹馍+其它 的价格 System.out.println(String.format(&quot;%s ￥%s&quot;, roujiamo.getDesc(), roujiamo.price())); } } 控制台打印结果如下：至此，装饰模式的介绍，应用场景，优缺点，以及一个完整案例已介绍完毕！ 如果想了解更多设计模式，可点击：设计模式概述 以及 23种设计模式的介绍]]></content>
      <categories>
        <category>Java</category>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建造者模式详解 (附java语言源码)]]></title>
    <url>%2F2019%2F05%2Fnlp%2Fziranyuayn%2F</url>
    <content type="text"><![CDATA[建造者模式（Builder Pattern）： 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。（Separate the construction of a complex object from its representation so that the same construction process can create different representations.） 建造模式的本质： List item分离了对象子组件的单独构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况下使用。 由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。 建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。 应用场景： java中的StringBuilder类的append方法； SQL中的PreparedStatement； JDOM中，DomBuilder、SAXBuilder； 去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”； 一个对象有非常复杂的内部结构，想把复杂对象的创建和使用分离 建造者模式的优缺点： 优点： 封装性好，创建和使用分离；无需修改原有代码，符合“开闭原则”。 拓展性好，建造类之间独立，一定程度上解耦；代码解耦，模块化，方便维护。产品本身与创建过程解耦，可以使用相同的创建过程得到不同的产品。 缺点： 产品必须有共同点，使用范围有限。建造者模式创造出来的产品，其组成部分基本相同。如果产品之间的差异较大，则不适用这个模式。 若产品内部发生变化，建造者都要修改，成本较大；若内部变化复杂，会有很多的建造类。 与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。 Mybatis中用到的建造者模式：SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder等。比如：XMLConfigBuilder读取配置文件构建出Configuration对象，然后SqlSessionFactoryBuilder使用Configuration对象作为参数，构建出SqlSessionFactory对象。原因：这么做的原因是Mybatis的初始化工作较复杂，不是一个构造函数就能包括的。所以采用了分层构建方法。例如Mybatis中极其重要的Configuration对象，它庞大且复杂，初始化比较麻烦，所以使用专门的建造者XMLConfigBuilder进行构建。 实例：比如：建造者模式可以用于描述KFC如何创建套餐：套餐是一个复杂对象，它一般包含主食（如汉堡、鸡肉卷等）和饮料（如果汁、可乐等）等组成部分，不同的套餐有不同的组成部分，而KFC的服务员可以根据顾客的要求，一步一步装配这些组成部分，构造一份完整的套餐，然后返回给顾客。 类图如下： 整个过程大致可以分为5步： 第一，定义Product（产品角色）： 一个具体的产品对象。 /** * 一个具体的产品对象，实体 */ public class Meal { private String food; private String drink; public String getFood() { return food; } public void setFood(String food) { this.food = food; } public String getDrink() { return drink; } public void setDrink(String drink) { this.drink = drink; } } 第二，定义Builder（抽象建造者）： 创建一个Product对象的各个部件指定的抽象接口。 /** * 抽象建造者 */ public abstract class MealBuilder { Meal meal = new Meal(); public abstract void buildFood(); public abstract void buildDrink(); public Meal getMeal(){ return meal; } } 第三，定义ConcreteBuilder（具体建造者）： 实现抽象接口，构建和装配各个部件。 /** * 具体建造者：A套餐 */ public class MealA extends MealBuilder{ public void buildDrink() { meal.setDrink(&quot;可乐&quot;); } public void buildFood() { meal.setFood(&quot;薯条&quot;); } } /** * 具体建造者：B套餐 */ public class MealB extends MealBuilder{ public void buildDrink() { meal.setDrink(&quot;柠檬果汁&quot;); } public void buildFood() { meal.setFood(&quot;鸡翅&quot;); } } 第四，定义Director（指挥者）： 构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。 /** * 指挥者：构建一个使用Builder接口的对象 */ public class KFCServer { private MealBuilder mealBuilder; public KFCServer(MealBuilder mealBuilder) { //构造方法 this.mealBuilder = mealBuilder; } public Meal construct(){ //准备食物 mealBuilder.buildFood(); //准备饮料 mealBuilder.buildDrink(); //准备完毕，返回一个完整的套餐给客户 return mealBuilder.getMeal(); } } 第五，定义测试类： /** * 测试类 */ public class Test { public static void main(String[] args) { MealA a = new MealA();//创建套餐A对象 KFCServer waitera = new KFCServer(a);//准备套餐A的服务员 Meal mealA = waitera.construct();//获得套餐A System.out.print(&quot;套餐A的组成部分:&quot;); System.out.println(&quot;食物：&quot;+mealA.getFood()+&quot;； &quot;+&quot;饮品：&quot;+mealA.getDrink()); MealB b = new MealB(); KFCServer waiterb = new KFCServer(b); Meal mealB = waiterb.construct(); System.out.print(&quot;套餐B的组成部分:&quot;); System.out.println(&quot;食物：&quot;+mealB.getFood()+&quot;； &quot;+&quot;饮品：&quot;+mealB.getDrink()); } } 测试结果如下图所示： 如果想了解更多设计模式，可点击：设计模式概述 以及 23种设计模式的介绍]]></content>
      <categories>
        <category>自然语言处理</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建造者模式详解 (附java语言源码)]]></title>
    <url>%2F2019%2F05%2Fjava%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F20190529_%E5%BB%BA%E9%80%A0%E8%80%85%2F</url>
    <content type="text"><![CDATA[建造者模式（Builder Pattern）： 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。（Separate the construction of a complex object from its representation so that the same construction process can create different representations.） 建造模式的本质： List item分离了对象子组件的单独构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况下使用。 由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。 建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。 应用场景： java中的StringBuilder类的append方法； SQL中的PreparedStatement； JDOM中，DomBuilder、SAXBuilder； 去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的”套餐”； 一个对象有非常复杂的内部结构，想把复杂对象的创建和使用分离 建造者模式的优缺点： 优点： 封装性好，创建和使用分离；无需修改原有代码，符合“开闭原则”。 拓展性好，建造类之间独立，一定程度上解耦；代码解耦，模块化，方便维护。产品本身与创建过程解耦，可以使用相同的创建过程得到不同的产品。 缺点： 产品必须有共同点，使用范围有限。建造者模式创造出来的产品，其组成部分基本相同。如果产品之间的差异较大，则不适用这个模式。 若产品内部发生变化，建造者都要修改，成本较大；若内部变化复杂，会有很多的建造类。 与工厂模式的区别是：建造者模式更加关注与零件装配的顺序。 Mybatis中用到的建造者模式：SqlSessionFactoryBuilder、XMLConfigBuilder、XMLMapperBuilder、XMLStatementBuilder、CacheBuilder等。比如：XMLConfigBuilder读取配置文件构建出Configuration对象，然后SqlSessionFactoryBuilder使用Configuration对象作为参数，构建出SqlSessionFactory对象。原因：这么做的原因是Mybatis的初始化工作较复杂，不是一个构造函数就能包括的。所以采用了分层构建方法。例如Mybatis中极其重要的Configuration对象，它庞大且复杂，初始化比较麻烦，所以使用专门的建造者XMLConfigBuilder进行构建。 实例：比如：建造者模式可以用于描述KFC如何创建套餐：套餐是一个复杂对象，它一般包含主食（如汉堡、鸡肉卷等）和饮料（如果汁、可乐等）等组成部分，不同的套餐有不同的组成部分，而KFC的服务员可以根据顾客的要求，一步一步装配这些组成部分，构造一份完整的套餐，然后返回给顾客。 类图如下： 整个过程大致可以分为5步： 第一，定义Product（产品角色）： 一个具体的产品对象。 /** * 一个具体的产品对象，实体 */ public class Meal { private String food; private String drink; public String getFood() { return food; } public void setFood(String food) { this.food = food; } public String getDrink() { return drink; } public void setDrink(String drink) { this.drink = drink; } } 第二，定义Builder（抽象建造者）： 创建一个Product对象的各个部件指定的抽象接口。 /** * 抽象建造者 */ public abstract class MealBuilder { Meal meal = new Meal(); public abstract void buildFood(); public abstract void buildDrink(); public Meal getMeal(){ return meal; } } 第三，定义ConcreteBuilder（具体建造者）： 实现抽象接口，构建和装配各个部件。 /** * 具体建造者：A套餐 */ public class MealA extends MealBuilder{ public void buildDrink() { meal.setDrink(&quot;可乐&quot;); } public void buildFood() { meal.setFood(&quot;薯条&quot;); } } /** * 具体建造者：B套餐 */ public class MealB extends MealBuilder{ public void buildDrink() { meal.setDrink(&quot;柠檬果汁&quot;); } public void buildFood() { meal.setFood(&quot;鸡翅&quot;); } } 第四，定义Director（指挥者）： 构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。 /** * 指挥者：构建一个使用Builder接口的对象 */ public class KFCServer { private MealBuilder mealBuilder; public KFCServer(MealBuilder mealBuilder) { //构造方法 this.mealBuilder = mealBuilder; } public Meal construct(){ //准备食物 mealBuilder.buildFood(); //准备饮料 mealBuilder.buildDrink(); //准备完毕，返回一个完整的套餐给客户 return mealBuilder.getMeal(); } } 第五，定义测试类： /** * 测试类 */ public class Test { public static void main(String[] args) { MealA a = new MealA();//创建套餐A对象 KFCServer waitera = new KFCServer(a);//准备套餐A的服务员 Meal mealA = waitera.construct();//获得套餐A System.out.print(&quot;套餐A的组成部分:&quot;); System.out.println(&quot;食物：&quot;+mealA.getFood()+&quot;； &quot;+&quot;饮品：&quot;+mealA.getDrink()); MealB b = new MealB(); KFCServer waiterb = new KFCServer(b); Meal mealB = waiterb.construct(); System.out.print(&quot;套餐B的组成部分:&quot;); System.out.println(&quot;食物：&quot;+mealB.getFood()+&quot;； &quot;+&quot;饮品：&quot;+mealB.getDrink()); } } 测试结果如下图所示： 如果想了解更多设计模式，可点击：设计模式概述 以及 23种设计模式的介绍]]></content>
      <categories>
        <category>Java</category>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式详解 (附java语言源码)]]></title>
    <url>%2F2019%2F05%2Fjava%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F20190528_%E8%A7%82%E5%AF%9F%E8%80%85%2F</url>
    <content type="text"><![CDATA[观察者模式（Observer Pattern）： 定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。（Define a one-to-many dependency between objects so that when one object changes state all its dependents are notified and updated automatically.） 简单来说，就是 发布-订阅模式，发布者发布信息，订阅者获取信息，订阅了就能收到信息，没订阅就收不到信息。比如：有一个微信公众号服务，不定时发布一些消息，关注公众号就可以收到推送消息，取消关注就收不到推送消息。 观察者模式的核心：此设计模式最重要的作用就是 解耦！将观察者与被观察者解耦，使得他们之间的依赖性更小 观察者模式的优缺点： 优点： 观察者和被观察者之间抽象耦合。观察者模式容易扩展，被观察者只持有观察者集合，并不需要知道具体观察者内部的实现。 对象之间的保持高度的协作。当被观察者发生变化时，所有被观察者都会通知到，然后做出相应的动作。 缺点： 如果观察者太多，被观察者通知观察者消耗的时间很多，影响系统的性能。 当观察者集合中的某一观察者错误时就会导致系统卡壳，因此一般会采用异步方式。 跟代理模式对比：观察者模式和代理模式主要区别在它们功能不一样，观察者模式强调的是被观察者反馈结果，而代理模式是同根负责做同样的事情。 开发中常见的场景： 聊天室程序的，服务器转发给所有客户端 京东商城中，群发某商品打折信息 Servlet中，监听器的实现 邮件订阅 网络游戏(多人联机对战)场景中，服务器将客户端的状态进行分发 案例：比如天气预报系统会不定时发布一些消息，关注的用户就可以收到推送消息，取消关注就收不到推送消息。 用观察者模式完成该案例，大概有以下五步： 第一，定义被观察者接口：也就是一个抽象主题，它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。(也可以用抽象类来实现) /** * 抽象被观察者接口:声明了添加、删除、通知观察者方法 */ public interface Observed { public void registerObserver(Observer o); public void removeObserver(Observer o); public void notifyObserver(); } 第二，定义观察者接口：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。 /** * 抽象观察者:定义了一个update()方法，当被观察者调用notifyObservers()方法时， * 观察者的update()方法会被回调。 */ public interface Observer { public void update(String message); } 第三，定义具体被观察者角色，也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。比如下面代码，实现了Observed接口，对Observed接口的三个方法进行了具体实现，同时有一个List集合，用以保存注册的观察者，等需要通知观察者时，遍历该集合即可。 /** *被观察者，也就是天气服务发布系统 *实现了Observerable接口，对Observerable接口的三个方法进行了具体实现 */ public class WeatherServer implements Observed { //注意到这个List集合的泛型参数为Observer接口， //设计原则：面向接口编程而不是面向实现编程 private List&lt;Observer&gt; list; private String message; public WeatherServer() { list = new ArrayList&lt;Observer&gt;(); } @Override public void registerObserver(Observer o) { list.add(o); } @Override public void removeObserver(Observer o) { if(!list.isEmpty()){ list.remove(o); } } @Override public void notifyObserver() { for(int i=0;i&lt;list.size();i++){ Observer observer = list.get(i); observer.update(message); } } public void setInfomation(String s) { this.message = s; System.out.println(&quot;天气系统更新消息： &quot; + s); //消息更新，通知所有观察者 notifyObserver(); } } 第四，定义具体观察者角色：实现抽象观察者角色所需要的更新接口，一边使本身的状态与系统的状态相协调 /** * 定义具体观察者：实现了update方法 */ public class User implements Observer{ private String name; private String message; public User(String name) { this.name = name; } @Override public void update(String message) { this.message = message; read(); } public void read() { System.out.println(name + &quot; 收到推送消息： &quot; + message); } } 第五，编写一个测试类：首先注册了三个用户，zhangsan、lisi、wangwu。公众号发布了一条消息 “ 今天有大雨！！！”，三个用户都收到了消息。若用户zhangsan不想看到天气预报推送的消息，于是取消订阅了，这时公众号又推送了一条消息 “ 明天是晴天~~~”，此时用户zhangsan已经收不到消息，其他用户还是正常能收到推送消息。 /** * 测试类 */ public class TestObserver { public static void main(String[] args) { WeatherServer server = new WeatherServer(); Observer userZhang = new User(&quot;zhangsan&quot;); Observer userLi = new User(&quot;lisi&quot;); Observer userWang = new User(&quot;wangwu&quot;); server.registerObserver(userZhang); server.registerObserver(userLi); server.registerObserver(userWang); server.setInfomation(&quot;今天有大雨！！！&quot;); System.out.println(&quot;----------------------------------------------&quot;); server.removeObserver(userZhang); server.setInfomation(&quot;明天是晴天~~~&quot;); } } 测试的结果如下图： 如果想看更多设计模式，可点此链接：更多设计模式]]></content>
      <categories>
        <category>Java</category>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式详解（用java语言实现策略模式）]]></title>
    <url>%2F2019%2F05%2Fjava%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F20190527_%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[策略模式（Strategy Pattern）: 定义一系列的算法，把它们一个个封装起来，并且使他们可相互替换。本模式使得算法的变化可以独立于使用它的客户。(Define a family of algorithms,encapsulate each one and make them interchangeable.Strategy lets the algorithmvary independently from clients that use it.) 策略模式本质是：分离算法，选择实现 通俗来讲：策略模式对应于解决某一个问题的一个算法族，允许用户从该算法族中任选一个算法解决某一问题，同时可以方便的更换算法或者增加新的算法。并且由客户端决定调用哪个算法。 开发中常见的场景： JAVASE中GUI编程中，布局管理 ； Spring框架中，Resource接口，资源访问； javax.servlet.http.HttpServlet#service()； 如果一个方法有大量if else语句，可通过策略模式来消除掉； 一个系统，需要动态地在几个算法中选择一种，可用策略模式实现； 系统有很多类，而他们的区别仅仅在于他们的行为不同 策略模式的优点： 开闭原则； 避免使用多重条件转移语句； 提高了算法的保密性和安全性：可使用策略模式以避免暴露复杂的，与算法相关的数据结构。 策略模式体现了面向对象程序设计中非常重要的两个原则： 封装变化的概念。 编程中使用接口，而不是使用的是具体的实现类(面向接口编程)。 举例：我们就以Java中的TreeSet为例，TreeSet仅仅知道它只是接收一个Comparator这种接口类型，但是具体是哪种实现类，TreeSet并不关心，实现类在真正的传入TreeSet之前，TreeSet本身是不知道的，所以我们可以自己去实现Comparator接口，然后在实现类里面去封装好我们自己的规则（这里的规则你可以当做是算法），比如说我们要实现对一个集合的元素排序，但是到底是要升序排序还是降序排序，这个完全由我们来去控制，我们可以把这种变化的内容封装到自己的实现类中，真正运行的时候才知道具体的实现。比如： 下面用策略模式来实现一个简单的 加减乘除的功能：第一步：定义抽象策略角色，通常情况下使用接口或者抽象类去实现 /** * 为策略对象定义一个接口 */ public interface Strategy { //实现2个数可以计算 public int calc(int num1,int num2); } 第二步：定义具体策略角色（在此只定义加 减两种具体的策略） /** * 定义加法策略 */ public class AddStrategy implements Strategy { @Override public int calc(int num1, int num2) { //实现接口中的方法，完成两个数的和 return num1+num2; } } /** * 定义减法策略 */ public class SubStrategy implements Strategy { @Override public int calc(int num1, int num2) { //实现接口中的方法，完成两个数的差 return num1-num2; } } 第三步：定义环境角色，负责和具体的策略类交互，内部持有一个策略类的引用，给客户端调用。 /** * 环境角色：负责和具体的策略类交互 */ public class Environment { //持有对策略类的引用 private Strategy strategy; //有参的构造方法,通过构造器来注入 public Environment(Strategy strategy) { this.strategy = strategy; } public int calulate(int a,int b){ return strategy.calc(a,b); } } 第四步：测试 /** * 测试类 */ public class TestStrategy { public static void main(String[] args) { Environment e = new Environment(new AddStrategy());//传入具体的策略类 int result = e.calulate(5, 7); System.out.println(&quot;a+b=&quot;+result); Environment r = new Environment(new SubStrategy()); System.out.println(&quot;a-b=&quot;+r.calulate(9,3)); } } 控制台打印效果如图： 再比如：去买衣服 新客户小批量：原价，不打折 新客户大批量：打九折 老客户小批量：打八五折 老客户大批量：打8折 可用if else来实现，弊端也很明显，如代码注释中解释，代码参考如下： /** * 实现起来比较容易，符合一般开发人员的思路 * 假如，类型特别多，算法比较复杂时，整个条件语句的代码就变得很长，难于维护。 * 如果有新增类型，就需要频繁的修改此处的代码！ * 不符合开闭原则！ */ public class TestStrategy { public double getPrice(String type, double price) { if (type.equals(&quot;普通客户小批量&quot;)) { System.out.println(&quot;不打折,原价&quot;); return price; } else if (type.equals(&quot;普通客户大批量&quot;)) { System.out.println(&quot;打九折&quot;); return price * 0.9; } else if (type.equals(&quot;老客户小批量&quot;)) { System.out.println(&quot;打八五折&quot;); return price * 0.85; } else if (type.equals(&quot;老客户大批量&quot;)) { System.out.println(&quot;打八折&quot;); return price * 0.8; } return price; } } 下面用策略模式来实现去买衣服打折的问题：第一步：定义抽象策略角色，通常情况下使用接口或者抽象类去实现 public interface Strategy { public double getPrice(double standardPrice); } 第二步：定义具体策略角色 /** * 新客户小批量 */ public class NewCustomerFewStrategy implements Strategy { @Override public double getPrice(double standardPrice) { System.out.println(&quot;不打折，原价&quot;); return standardPrice; } } /** * 新客户大批量 */ public class NewCustomerManyStrategy implements Strategy { @Override public double getPrice(double standardPrice) { System.out.println(&quot;打九折&quot;); return standardPrice*0.9; } } /** * 老客户小批量 */ public class OldCustomerFewStrategy implements Strategy { @Override public double getPrice(double standardPrice) { System.out.println(&quot;打八五折&quot;); return standardPrice*0.85; } } /** * 老客户大批量 */ public class OldCustomerManyStrategy implements Strategy { @Override public double getPrice(double standardPrice) { System.out.println(&quot;打八折&quot;); return standardPrice*0.8; } } 第三步：定义环境角色，负责和具体的策略类交互，内部持有一个策略类的引用，给客户端调用。 /** * 负责和具体的策略类交互 * 这样的话，具体的算法和直接的客户端调用分离了，使得算法可以独立于客户端独立的变化。 * 如果使用spring的依赖注入功能，还可以通过配置文件，动态的注入不同策略对象，动态的切换不同的算法. */ public class Context { private Strategy strategy; //当前采用的算法对象 //可以通过构造器来注入 public Context(Strategy strategy) { super(); this.strategy = strategy; } //可以通过set方法来注入 public void setStrategy(Strategy strategy) { this.strategy = strategy; } public void pringPrice(double s){ System.out.println(&quot;您该报价：&quot;+strategy.getPrice(s)); } } 第四步：测试 /** * 测试类 */ public class Client { public static void main(String[] args) { Strategy s1 = new OldCustomerManyStrategy(); Context ctx = new Context(s1); ctx.pringPrice(500); } } 运行此类，控制台打印效果如图：至此，策略模式的解释 和2个详细的案例介绍已完毕~ 如果想了解更多设计模式，可点击：设计模式概述 以及 23种设计模式的介绍 如果觉得写的不错 或者想了解更多，欢迎收藏和关注~~]]></content>
      <categories>
        <category>Java</category>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫定时任务汇总]]></title>
    <url>%2F2019%2F05%2Fpython%2Fspider%2F%E6%9C%89%E7%94%A8%E4%BB%A3%E7%A0%81%2F20190526_%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[使用schedulers模块 -- coding: utf-8 --import osimport datetimefrom apscheduler.schedulers.blocking import BlockingScheduler def run_fast(): “””运行增量程序””” # os.popen(&#39;scrapy crawl kuaixun_egs&#39;) print(&#39;111&#39;) def create_timing(): “””创建定时任务””” scheduler = BlockingScheduler() scheduler.add_job(run_fast, ‘cron’, second=f”*/6”, next_run_time=datetime.datetime.now()) # 6秒运行1次 scheduler.start() create_timing() `]]></content>
      <categories>
        <category>python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式详解（附常见的7种单例模式源码）]]></title>
    <url>%2F2019%2F05%2Fjava%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F20190524_%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式（Singleton Pattern）:保证一个类仅有一个对象，并提供一个访问它的全局访问点。(Ensure a class only has one instance,and provide a globe point of access to it.) 常见应用场景： Windows的Task Manager（任务管理器）就是很典型的单例模式 windows的Recycle Bin（回收站）也是典型的单例应用。在整个系统运行过程中，回收站一直维护着仅有的一个实例。 项目中，读取配置文件的类，一般也只有一个对象。没有必要每次使用配置文件数据，每次new一个对象去读取。 网站的计数器，一般也是采用单例模式实现，否则难以同步。 应用程序的日志应用，一般都何用单例模式实现，这一般是由于共享的日志文件一直处于打开状态，因为只能有一个实例去操作否则内容不好追加。 数据库连接池的设计一般也是采用单例模式，因为数据库连接是一种数据库资源。 操作系统的文件系统，也是大的单例模式实现的具体例子，一个操作系统只能有一个文件系统。 Application 也是单例的典型应用（Servlet编程中会涉及到） 在Spring中，每个Bean默认就是单例的，这样做的优点是Spring容器可以管理 在servlet编程中，每个Servlet也是单例 在spring MVC框架/struts1框架中，控制器对象也是单例 一个产品注册了一个商标，那么它就是单例的 单例模式的优点： 由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动 时直接产生一个单例对象，然后永久驻留内存的方式来解决 单例模式可以在系统设置全局的访问点，优化环共享资源访问，例如可以设计 一个单例类，负责所有数据表的映射处理 常见单例模式有以下7种： 1.饿汉式：先创建后使用，线程安全，占用内存。代码如下： /** * 饿汉式单例模式 * @author cui_yonghua https://blog.csdn.net/cui_yonghua/article/details/90512943 */ public class ClassA { //1.私有化构造方法，使得在类的外部不能调用此方法，限制产生多个对象 private ClassA(){ } //2.在类的内部创建一个类的实例 //类初始化时，立即加载这个对象（没有延时加载的优势）。加载类时，天然的是线程安全的！ private static final ClassA instance = new ClassA(); //3.对外部提供调用方法：将创建的对象返回，只能通过类来调用 //方法没有同步，调用效率高！ public static ClassA getInstance(){ return instance; } //测试 public static void main(String[] args) { ClassA a = ClassA.getInstance(); ClassA b = ClassA.getInstance(); System.out.println(a==b); } } 控制台输出的结果如下图： 2.懒汉式：用的时候才创建，线程不安全，加锁会影响效率。资源利用率高了，但是，每次调用getInstance()方法都要同步，并发效率较低。代码如下： /** * 懒汉式单例模式 * @author cui_yonghua https://blog.csdn.net/cui_yonghua/article/details/90512943 */ public class ClassB { //1.私有化构造方法，使得在类的外部不能调用此方法，限制产生多个对象 private ClassB(){ } //2.在类的内部创建一个类的实例 private static ClassB instance ; //3.对外部提供调用方法：将创建的对象返回，只能通过类来调用 public static synchronized ClassB getInstance(){ if(instance == null) { instance = new ClassB(); } return instance; } //测试 public static void main(String[] args) { ClassB a = ClassB.getInstance(); ClassB b = ClassB.getInstance(); System.out.println(a==b); } } 控制台输出的结果如下图： 3.静态内部类方式：也即饿汉式和懒汉式的组合，调用getInstance()方法时才创建，达到了类似懒汉式的效果，同时又是线程安全的。代码如下： /** * 使用静态内部类方式实现单例模式 * @author cui_yonghua https://blog.csdn.net/cui_yonghua/article/details/90512943 */ public class ClassC { //1.私有化构造方法，使得在类的外部不能调用此方法，限制产生多个对象 private ClassC(){ } //2.在类的内部创建一个类的实例 private static class Holder{ private static ClassC instance = new ClassC(); } //3.对外部提供调用方法：将创建的对象返回，只能通过类来调用 public static ClassC getInstance(){ return Holder.instance; } //测试 public static void main(String[] args) { ClassC a = ClassC.getInstance(); ClassC b = ClassC.getInstance(); System.out.println(a==b); } } 控制台输出的结果如下图： 4.枚举方法：线程安全，实现简单，调用效率高，不能延时加载。枚举本身就是单例模式，由JVM从根本上提供保障并且可以天然的防止反射和反序列化漏洞！需要继承的场景它就不适用了。枚举方式是Effective Java作者提倡的方式。代码如下： /** * 使用枚举方法实现单例模式 * @author cui_yonghua https://blog.csdn.net/cui_yonghua/article/details/90512943 */ public enum ClassD { //定义一个枚举的元素，它就代表了Singleton的一个实例。 INSTANCE; //对外部提供调用方法：将创建的对象返回，只能通过类来调用 public void otherMethod(){ //功能处理 } //测试 public static void main(String[] args) { ClassD a = ClassD.INSTANCE; ClassD b = ClassD.INSTANCE; System.out.println(a==b); } } 5.双重校验锁式：通常线程安全，加volatile的作用是禁止指令重排。（由于JVM底层内部模型原因，偶尔会出问题。不建议使用）代码如下： /** * 使用双重校验锁来实现单例模式 * @author cui_yonghua https://blog.csdn.net/cui_yonghua/article/details/90512943 */ public class ClassE { //1.私有化构造方法，使得在类的外部不能调用此方法，限制产生多个对象 private ClassE(){ } //2.在类的内部创建一个类的实例 private volatile static ClassE instance; //volatile作用：保证多线程可以正确处理instance //3.对外部提供调用方法：将创建的对象返回，只能通过类来调用 public static ClassE getInstance(){ if(instance == null){ //检查实例，如果为空，就进入同步代码块 synchronized (ClassE.class){ if(instance == null){ //再检查一次，仍未空才创建实例 instance = new ClassE(); } } } return instance; } //测试 public static void main(String[] args) { ClassE a = ClassE.getInstance(); ClassE b = ClassE.getInstance(); System.out.println(a==b); } } 控制台输出的结果如下图： 6.使用ThreadLocal实现：线程安全，ThreadLocal采用以空间换时间的方式，为每一个线程都提供一份变量，因此可以同时访问而互不影响。代码如下： /** * 使用ThreadLocal实现单例模式 * @author cui_yonghua https://blog.csdn.net/cui_yonghua/article/details/90512943 */ public class ClassF { //1.私有化构造方法，使得在类的外部不能调用此方法，限制产生多个对象 private ClassF(){ } //2.在类的内部创建一个类的实例 private static final ThreadLocal&lt;ClassF&gt; tls = new ThreadLocal&lt;ClassF&gt;(){ @Override protected ClassF initialValue(){ return new ClassF(); } }; //3.对外部提供调用方法：将创建的对象返回，只能通过类来调用 public static ClassF getInstance(){ return tls.get(); } //测试 public static void main(String[] args) { ClassF a = ClassF.getInstance(); ClassF b = ClassF.getInstance(); System.out.println(a==b); } } 控制台输出的结果如下图： 7.使用CAS锁来实现：（CAS锁（Compare and Swap）：比较并交换，是一种有名的无锁算法，属于乐观锁）。用CAS锁来实现单例模式是线程安全的，代码如下： /** * 使用CAS锁来实现单例模式 * @author cui_yonghua https://blog.csdn.net/cui_yonghua/article/details/90512943 */ public class ClassG { //1.私有化构造方法，使得在类的外部不能调用此方法，限制产生多个对象 private ClassG(){ } //2.在类的内部创建一个类的实例 private static final AtomicReference&lt;ClassG&gt; instance = new AtomicReference&lt;ClassG&gt;(); //3.对外部提供调用方法：将创建的对象返回，只能通过类来调用 public static final ClassG getInstance(){ for(;;){ ClassG current = instance.get(); if(current != null){ return current; } current = new ClassG(); if(instance.compareAndSet(null,current)){ return current; } } } //测试 public static void main(String[] args) { ClassG a = ClassG.getInstance(); ClassG b = ClassG.getInstance(); System.out.println(a==b); } } 控制台输出的结果如下图： 如果如果想了解更多设计模式，可点击：设计模式概述 以及 23种设计模式的介绍 如果觉得文章写的不错，也可以小小地打赏一下嘛~ 也期待合作，“码”上改变~]]></content>
      <categories>
        <category>Java</category>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java设计模式汇总]]></title>
    <url>%2F2019%2F05%2Fjava%2Fjava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F20190524_%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[设计模式概述（Design pattern）：设计模式：代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 GOF介绍:在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 的书，该书首次提到了软件开发中设计模式的概念。四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则。 对接口编程而不是对实现编程。 优先使用对象组合而不是继承。 总的来说设计模式分为3大类： • 创建型模式（Creational Patterns）：（都是用来帮助我们创建对象的）这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。主要包括： 单例模式（Singleton Pattern）:保证一个类仅有一个对象，并提供一个访问它的全局访问点。(Ensure a class only has one instance,and provide a globe point of access to it.) 详细单例模式介绍可点此链接：单例模式详解（附常见的7种单例模式源码） 用Python实现单例模式：用Python 实现单例模式 （Python经典编程案例） 工厂模式（Factory Pattern）：定义一个用于创建对象的接口，让子类决定将哪一个类实例化，FactoryMethod使一个类的实例化延迟到其子类。（Define an interface for creating anobject, but let subclasses decide which class to instantiate. Factory methodlets a class defer instantiation to subclasses.） 详细工厂模式介绍可点此链接：工厂模式详解 (附java语言源码) Python实现工厂模式：用python实现工厂设计模式（Python经典编程案例） 抽象工厂模式（Abstract Factory Pattern）：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们的具体类。（Provide an interface for creating families of related or dependent object without specifying their concrete classes.） 详细抽象工厂模式介绍可点此链接：抽象工厂模式详解 (附java语言源码) 建造者模式（Builder Pattern）：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。（Separate the construction of a complex object from its representation so that the same construction process can create different representations.） 详细建造者模式介绍可点此链接：建造者模式详解 (附java语言源码) 原型模式（Prototype Pattern）:用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。(Specify the kinds of objects to create using a prototypical instance, and create new objects by copying the prototype.) 详细原型模式介绍可点此链接：原型模式详解 (附java语言源码) •结构型模式（Structural Patterns）：这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。主要包括： 适配器模式（Adapter Pattern）：将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。（Convert the interface of a class into another interface clients except. Adapter lets classes work together that couldn’t otherwise because of incompatible interfaces.） 详细适配器模式介绍可点此链接：适配器模式详解 (附java语言源码) 桥接模式（Bridge Pattern）：将抽象部分与它的实现部分分离，使他们都可以独立地变化。（Decouple an abstraction from its implementation so that the two can vary independently.） 详细桥接模式介绍可点此链接：桥接模式详解 (附java语言源码) 装饰模式（Decorator Pattern）：动态地给一个对象添加一些额外的职责。就扩展功能而言，Decorator模式比生成子类的方式更为灵活。（Attach additional responsibilities to an object dynamically. Decorators provides a flexible alternative to subclasses for extending functionality.） 详细装饰模式介绍可点此链接：装饰模式详解 (附java语言源码) 组合模式（Composite Pattern）：将对象组合成树形结构以表示“部分-整体”的层次结构。Composite 使得客户对单个对象和复合对象的使用具有一致性。（Compose object into tree structures torepresent part-whole hierarchy. Composite lets clients treat individual objectsand compositions of objects uniformly.） 详细组合模式介绍可点此链接：组合模式详解 (附java语言源码) 外观模式（Facade Pattern）：为子系统中的一组接口提供一个一致的接口。Façade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。（Provide a unified interface to a set of interfaces in a subsystem. Façade defines a higher-level interface that makes the subsystem easier to use.） 详细外观模式介绍可点此链接：外观模式详解 (附java语言源码) 享元模式（Flyweight Pattern）：运用共享技术有效地支持大量细粒度的对象。（Use sharing to support large numbers offine-grained objects efficiently.） 详细享元模式介绍可点此链接：享元模式详解 (附java语言源码) 代理模式（Proxy Pattern）:为其他对象提供一个代理以控制对这个对象的访问。(Provide a surrogate or placeholder foranther object to control access to it.) 详细代理模式介绍可点此链接：代理模式详解 (附java语言源码) • 行为型模式（Behavioral Patterns）：这些设计模式特别关注对象之间的通信。主要包括： 模版方法模式（Template Pattern）:定义一个操作中的算法的骨架，而将一些步骤延迟到子类。TemplateMethod 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。(Define the skeleton of an algorithm inan operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing thealgorithm’s structure.) 详细模版方法模式介绍可点此链接：模板方法模式详解 (附java语言源码) 命令模式（Command Pattern）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可取消的操作。（Encapsulate a request as an object,thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.） 详细命令模式介绍可点此链接：命令模式详解 (附java语言源码) 迭代器模式（Iterator Pattern）：提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。（Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.） 详细迭代器模式介绍可点此链接：迭代器模式详解 (附java语言源码) 观察者模式（Observer Pattern）：定义对象间的一种一对多的依赖关系，以便当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动刷新。（Define a one-to-many dependency between objects so that when one object changes state all its dependents are notified and updated automatically.） 详细观察者模式介绍可点此链接：观察者模式详解 (附java语言源码) 中介者模式（Mediator Pattern）：用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。（Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly and it lets you vary their interaction independently.） 详细中介者模式介绍可点此链接：中介者模式详解 (附java语言源码) 备忘录模式（Memento Pattern）：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保持该状态，这样以后就可以将该对象恢复到保存的状态。（Without violating encapsulates, captureand externalize an object’s internal state so that the object can be restored to this state later.） 详细备忘录模式介绍可点此链接：备忘录模式详解 (附java语言源码) 解释器模式（Interpreter Pattern）：定义一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。（Given a language, define are presentation for its grammar along with an interpreter that uses there presentation to interpret sentences in the language.） 详细解释器模式介绍可点此链接：解释器模式详解 (没有附java语言源码) 状态模式（State Pattern）:允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类。(Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.) 详细状态模式介绍可点此链接：状态模式详解 (附java语言源码) 策略模式（Strategy Pattern）:定义一系列的算法，把它们一个个封装起来，并且使他们可相互替换。本模式使得算法的变化可以独立于使用它的客户。(Define a family of algorithms,encapsulate each one and make them interchangeable. Strategy lets the algorithmvary independently from clients that use it.) 详细策略模式介绍可点此链接：策略模式详解（用java语言实现策略模式） 责任链模式（Chain of Responsibility Pattern）：为解除请求的发送者和接收者之间的耦合，而使多个对象都有机会处理这个请求。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它。（Avoid coupling the sender of a requestits receiver by giving more than one object a chance to handle the request.Chain the receiving objects and pass the request along the chain until anobject handles it.） 详细责任链模式介绍可点此链接：责任链模式详解 (附java语言源码) 访问者模式（Visitor Pattern）:表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素类别的前提下定义作用于这些元素的新操作。(Represent an operation to be performedon the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.) 详细访问者模式介绍可点此链接：访问者模式详解 (没有附java语言源码) 此外还有一些J2EE模式：这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 MVC 模式（MVC Pattern） 业务代表模式（Business Delegate Pattern） 组合实体模式（Composite Entity Pattern） 数据访问对象模式（Data Access Object Pattern） 前端控制器模式（Front Controller Pattern） 拦截过滤器模式（Intercepting Filter Pattern） 服务定位器模式（Service Locator Pattern） 传输对象模式（Transfer Object Pattern） 下面用一个图片来整体描述一下设计模式之间的关系：谢谢]]></content>
      <categories>
        <category>Java</category>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask案例_登录和遍历操作]]></title>
    <url>%2F2019%2F04%2Fpython%2Fweb%2F20190420_%E6%A1%88%E4%BE%8B_%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[flask案例_登录和遍历操作, 直接运行app.py文件： app.py# -*- encoding: utf-8 -*- from flask import Flask, render_template, request, redirect, session # 实例化一个app app = Flask(__name__) app.secret_key = &#39;aaa&#39; app.debug = True USER_DICT = { &#39;1&#39;: {&#39;name&#39;: &#39;大伟&#39;, &#39;age&#39;: 18}, &#39;2&#39;: {&#39;name&#39;: &#39;张三&#39;, &#39;age&#39;: 8}, &#39;3&#39;: {&#39;name&#39;: &#39;李四&#39;, &#39;age&#39;: 28} } # 创建视图函数，路由地址 @app.route(&#39;/login&#39;, methods=[&#39;GET&#39;, &#39;POST&#39;]) def login(): if request.method == &#39;GET&#39;: return render_template(&#39;login.html&#39;) user = request.form.get(&#39;user&#39;) # request.args 接收get方法的值 pwd = request.form.get(&#39;pwd&#39;) print(user, pwd) if user == &#39;tom&#39; and pwd == &#39;123&#39;: session[&#39;user_info&#39;] = user return redirect(&#39;/index&#39;) else: # 下面两种方式都可以 # return render_template(&#39;login.html&#39;, msg=&#39;用户名或密码错误&#39;) return render_template(&#39;login.html&#39;, **{&#39;msg&#39;: &#39;用户名或密码错误~&#39;}) @app.route(&#39;/logout&#39;) def logout(): del session[&#39;user_info&#39;] return redirect(&#39;/login&#39;) @app.route(&#39;/index&#39;) def index(): user_info = session.get(&#39;user_info&#39;) if not user_info: return redirect(&#39;/login&#39;) return render_template(&#39;index.html&#39;, user_dict=USER_DICT) @app.route(&#39;/detail&#39;) def detail(): user_info = session.get(&#39;user_info&#39;) if not user_info: return redirect(&#39;/login&#39;) uid = request.args.get(&#39;uid&#39;) info = USER_DICT.get(uid) return render_template(&#39;detail.html&#39;, info=info) if __name__ == &quot;__main__&quot;: app.run(host=&#39;0.0.0.0&#39;, port=9005) templates/login.html&lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-cn&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;休息系统-用户登录&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form method=&quot;post&quot;&gt; &lt;input type=&quot;text&quot;, name=&quot;user&quot;&gt; &lt;input type=&quot;text&quot;, name=&quot;pwd&quot;&gt; &lt;input type=&quot;submit&quot;, value=&quot;提交&quot;&gt; {{msg}} &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; templates/index.html&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; {% for k,v in user_dict.items() %} {{v.name}}查看详细 {% endfor %} &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; templates/detail.html &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h2&gt;详细信息&lt;/h2&gt; &lt;div&gt;{{ info.name }}&lt;/div&gt; &lt;div&gt;{{ info.age }}&lt;/div&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>python</category>
        <category>flask</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>flask</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python时间处理]]></title>
    <url>%2F2019%2F03%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20190313_%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[PyInstaller使用（简单） 秒级时间戳：10位数字；毫秒级时间戳：13位数字；微秒级时间戳：16位数字； datetimedatetime是Python处理日期和时间的标准库。 datetime表示的时间需要时区信息才能确定一个特定的时间，否则只能视为本地时间。 如果要存储datetime，最佳方法是将其转换为timestamp再存储，因为timestamp的值与时区完全无关。 from datetime import datetime, timedelta, timezone # 1. 获取当前日期和时间和指定日期和时间 now = datetime.now() # 获取当前datetime print(now, type(now)) dt = datetime(2019, 4, 19, 12, 20) # 用指定日期时间创建datetime print(dt) # 2. datetime转换为timestamp dt_stamp = dt.timestamp() print(dt_stamp) # timestamp转换为datetime print(datetime.fromtimestamp(dt_stamp)) print(datetime.utcfromtimestamp(dt_stamp)) # UTC时间 # 3. str转换为datetime cday = datetime.strptime(&#39;2019-6-1 18:19:59&#39;, &#39;%Y-%m-%d %H:%M:%S&#39;) print(cday) # datetime转换为str print(now.strftime(&#39;%a, %b %d %H:%M&#39;)) # 4. datetime加减 ten_hour = now + timedelta(hours=2) print(ten_hour) print(now - timedelta(days=1)) print(now + timedelta(days=2, hours=12)) # 5. 本地时间转换为UTC时间 # 北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间 tz_utc_8 = timezone(timedelta(hours=8)) # 创建时区UTC+8:00 dt = now.replace(tzinfo=tz_utc_8) # 强制设置为UTC+8:00 print(dt) # 6. 时区转换 # 可以先通过utcnow()拿到当前的UTC时间，再转换为任意时区的时间： utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc) print(utc_dt) # astimezone()将转换时区为北京时间: bj_dt = utc_dt.astimezone(timezone(timedelta(hours=8))) print(bj_dt) import datetime for i in range(1095, 1, -1): # start_date = &#39;{:%Y-%m-%d}&#39;.format(datetime.date.today() - datetime.timedelta(days=i)) end_date = &#39;{:%Y-%m-%d}&#39;.format(datetime.date.today() - datetime.timedelta(days=i-1)) duration = &#39;{} ~ {}&#39;.format(start_date, end_date) print(start_date) print(end_date) print(duration) date1 = datetime.datetime(2012, 3, 1, 00, 00, 00) timestamp = time.mktime(date1.timetuple()) print(&#39;格式化的时间转成时间戳：&#39;, timestamp) 练习假设你获取了用户输入的日期和时间如2015-1-21 9:01:30，以及一个时区信息如UTC+5:00，均是str，请编写一个函数将其转换为timestamp： import re from datetime import datetime, timezone, timedelta def to_timestamp(dt_str, tz_str): t = datetime.strptime(dt_str, &#39;%Y-%m-%d %H:%M:%S&#39;) tz = re.match(r&#39;\w{3}([\+\-]\d{1,2})\:\d{2}&#39;, tz_str).group(1) tz = int(tz) t_utc = t.replace(tzinfo=timezone(timedelta(hours=tz))) print(t_utc.timestamp()) return t_utc.timestamp() t1 = to_timestamp(&#39;2015-6-1 08:10:30&#39;, &#39;UTC+7:00&#39;) assert t1 == 1433121030.0, t1 t2 = to_timestamp(&#39;2015-5-31 16:10:30&#39;, &#39;UTC-09:00&#39;) assert t2 == 1433121030.0, t2 print(&#39;ok&#39;) ========================== 案例1：打印昨天的时间： # 引入 datetime 模块 import datetime def getYesterday(): today = datetime.date.today() oneday = datetime.timedelta(days=1) yesterday = today - oneday return yesterday # 输出 print(getYesterday()) # 2019-07-22 案例2：格式化时间 import time # 格式化成2019-07-23 11:45:39形式 print(time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime())) # 格式化成Sat Mar 28 22:24:24 2016形式 print(time.strftime(&quot;%a %b %d %H:%M:%S %Y&quot;, time.localtime())) # 将格式字符串转换为时间戳 a = &quot;Sat Mar 28 22:24:24 2019&quot; print(time.mktime(time.strptime(a, &quot;%a %b %d %H:%M:%S %Y&quot;))) 执行结果如下图： 案例3：输出某月的日历 import calendar cal = calendar.month(2019, 7) print(&quot;以下输出2016年1月份的日历:&quot;) print(cal) 执行结果如下图： 案例4：将字符串的时间转换为时间戳 import time a1 = &quot;2019-5-10 23:40:00&quot; # 先转换为时间数组 timeArray = time.strptime(a1, &quot;%Y-%m-%d %H:%M:%S&quot;) # 转换为时间戳 timeStamp = int(time.mktime(timeArray)) print(timeStamp) # 格式转换 - 转为 / a2 = &quot;2019-5-10 23:40:00&quot; # 先转换为时间数组,然后转换为其他格式 timeArray = time.strptime(a2, &quot;%Y-%m-%d %H:%M:%S&quot;) otherStyleTime = time.strftime(&quot;%Y/%m/%d %H:%M:%S&quot;, timeArray) print(otherStyleTime) 执行结果如下图: 案例5：获取几天前的时间 import time import datetime # 先获得时间数组格式的日期 threeDayAgo = (datetime.datetime.now() - datetime.timedelta(days=3)) # 转换为时间戳 timeStamp = int(time.mktime(threeDayAgo.timetuple())) # 转换为其他字符串格式 otherStyleTime = threeDayAgo.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) print(otherStyleTime) 执行结果如下图： 案例6：将时间戳转换为指定日期 import time # 获得当前时间时间戳 now = int(time.time()) #转换为其他日期格式,如:&quot;%Y-%m-%d %H:%M:%S&quot; timeArray = time.localtime(now) otherStyleTime = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, timeArray) print(otherStyleTime) 执行结果如下图： import datetime # 获得当前时间 now = datetime.datetime.now() # 转换为指定的格式 otherStyleTime = now.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) print(otherStyleTime) 执行结果如下图： 指定时间戳： import time timeStamp = 1556502800 timeArray = time.localtime(timeStamp) otherStyleTime = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, timeArray) print(otherStyleTime) import datetime timeStamp = 1557802800 dateArray = datetime.datetime.utcfromtimestamp(timeStamp) otherStyleTime = dateArray.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) print(otherStyleTime) 时间转换from datetime import datetime, timedelta aa = &#39;2020-10-28T01:14:42.000Z&#39; # aa= &#39;2018-08-06T10:00:00.000Z&#39; date_ = datetime.strptime(aa, &quot;%Y-%m-%dT%H:%M:%S.%fZ&quot;) #local_time = 2018-08-06 18:00:00 local_time = date_ + timedelta(hours=8) print(local_time) # 输出: 2020-10-28 09:14:42 gmt时间import time print(time.strftime(&quot;%Y-%m-%d %X&quot;,time.localtime())) from datetime import datetime GMT_FORMAT = &#39;%a %b %d %Y %H:%M:%S GMT 0800 (中国标准时间)&#39; print(datetime.utcnow().strftime(GMT_FORMAT)) # Thu Nov 12 2020 09:50:44 GMT 0800 (中国标准时间) # Thu Nov 12 2020 17:41:41 GMT 0800 (中国标准时间) # Fri Nov 13 2020 15:31:53 GMT 0800 (中国标准时间)]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python打包]]></title>
    <url>%2F2019%2F03%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20190311_%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[PyInstaller使用（简单） 安装 : pip install pyinstaller==3.4 安装即可 PyInstaller 命令基本语法： pyinstaller [options] script[script ...]|specfile pyinstaller test.py 参数及定义`常规-h 帮助-v 版本–distpath DIR 可执行文件生成目录 默认生成于脚本文件同级的dist目录下–workpath WORKPATH 临时文件目录，包括 .log,.pyz，默认有./build–y 无需确认备选输出目录–clean 构建结束后清除pyinstaller生成的缓存并删除临时文件–log-level LEVEL 构建时控制台输出日志级别，可选项：TRACE,DEBUG,INFO,WARN,ERROR,CRITICAL 默认为INFO 用于构造的参数-D 构造为包含可执行文件的文件夹（所有依赖及数据均存在于文件夹中）-F 构造为单个可执行文件–specpath DIR 存储构造sepc文件的目录-n NAME 定义生成的应用和spec文件的名字 默认为第一个py文件的文件名 寻找依赖及搜索的路径–add-data&lt;SRC;DEST or SRC:DEST&gt; 附加的需要添加进可执行文件的非二进制文件或文件夹，可多次使用（可以用于包含需要使用的数据文件）–add-binary&lt;SRC;DEST or SRC:DEST&gt; 附加的需要添加进可执行文件的二进制文件，可多次使用-p DIR 搜索导入模块的路径，可使用多个路径以搜索引入的模块，以’;’分隔或多次使用该参数。–hidden-import MODULENAME 标明并未显式于脚本中标识的引入模块–exclude-module EXCLUDES 可选的，需要忽略的模块或包（即使没有找到）–key KEY 加密二进制的密钥` 基本用法 假定Python项目的主函数入口为main.py,则打包命令如下 pyinstaller -F main.py -F参数大小写敏感 指定搜索路径，若有多个模块搜索路径需要指明 pyinstaller -F main.py -p /usr/local/python3/bin/python3 -p ./package 文档链接 https://media.readthedocs.org/pdf/pyinstaller/stable/pyinstaller.pdf]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python发布模块]]></title>
    <url>%2F2019%2F03%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20190310_%E5%8F%91%E5%B8%83%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[升级模块：pip install –upgrade 库名 一. 让别人pip install官方参考：https://packaging.python.org/tutorials/packaging-projects/ 参考文章：https://mp.weixin.qq.com/s/IZJfkfgDWSGNhuUJn6wRoQ 我的：https://pypi.org/ cuiyonghua cui1-A! https://github.com/wistbean/learn_python3_spider /Users/cuiyonghua/Desktop/my_work_files/softwares/mongodb/mongodata/etc/mongo.conf init from __future__ import absolute_import from .xiaocui import * name = &quot;xiaocui&quot; xiaocui.py # -*- coding: utf-8 -*- def output(): print(&#39;hello,这是&#39;) def output1(data): print(&#39;hello,这是：{}&#39;.format(data)) def susu(susu): print(&#39;susu:{}&#39;.format(susu)) setup.py: 这个文件主要是要告诉 setuptools ，我们的包里面的一些信息，比如名称啊，版本号啊，作者，邮箱等等 # -*- coding: utf-8 -*- import setuptools with open(&quot;README.md&quot;, &quot;r&quot;) as fh: long_description = fh.read() setuptools.setup( name=&quot;xiaocui&quot;, version=&quot;0.0.1&quot;, author=&quot;xiaocui&quot;, author_email=&quot;cui_yonghua6@163.com&quot;, description=&quot;This is an cui package, fa li wu bian&quot;, long_description=long_description, long_description_content_type=&quot;text/markdown&quot;, keywords=&quot;hello world example examples&quot;, url=&quot;https://github.com/cuiyonghua6/cui_package&quot;, packages=setuptools.find_packages(), classifiers=[ &#39;Programming Language :: Python :: 3&#39;, &#39;License :: OSI Approved :: MIT License&#39;, &#39;Operating System :: OS Independent&#39;, ] ) LICENCE MIT License Copyright (c) 2020 cuiyonghua6 Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the &quot;Software&quot;), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. python3 -m pip install –user –upgrade setuptools wheel python3 setup.py sdist bdist_wheel https://pypi.org/account/register/ https://test.pypi.org/account/register/ python3 -m pip install –user –upgrade twine (apt install twine)python3 -m twine upload dist/* 二. setup.py 参数解释--name 包名称 --version (-V) 包版本 --author 程序的作者 --author_email 程序的作者的邮箱地址 --maintainer 维护者 --maintainer_email 维护者的邮箱地址 --url 程序的官网地址 --license 程序的授权信息 --description 程序的简单描述 --long_description 程序的详细描述 --platforms 程序适用的软件平台列表 --classifiers 程序的所属分类列表 --keywords 程序的关键字列表 --packages 需要处理的包目录（包含__init__.py的文件夹） --py_modules 需要打包的python文件列表 --download_url 程序的下载地址 --cmdclass --data_files 打包时需要打包的数据文件，如图片，配置文件等 --scripts 安装时需要执行的脚步列表 --package_dir 告诉setuptools哪些目录下的文件被映射到哪个源码包。一个例子：package_dir = {&#39;&#39;: &#39;lib&#39;}，表示“root package”中的模块都在lib 目录中。 --requires 定义依赖哪些模块 --provides定义可以为哪些模块提供依赖 --find_packages() 对于简单工程来说，手动增加packages参数很容易，刚刚我们用到了这个函数，它默认在和setup.py同一目录下搜索各个含有 __init__.py的包。 其实我们可以将包统一放在一个src目录中，另外，这个包内可能还有aaa.txt文件和data数据文件夹。另外，也可以排除一些特定的包 find_packages(exclude=[&quot;*.tests&quot;, &quot;*.tests.*&quot;, &quot;tests.*&quot;, &quot;tests&quot;])--install_requires = [&quot;requests&quot;] 需要安装的依赖包 --entry_points 动态发现服务和插件，下面详细讲 下列entry_points中： console_scripts 指明了命令行工具的名称；在“redis_run = RedisRun.redis_run:main”中，等号前面指明了工具包的名称，等号后面的内容指明了程序的入口地址。 entry_points={&#39;console_scripts&#39;: [ &#39;redis_run = RedisRun.redis_run:main&#39;, ]} 三. 示例代码： from os import path as os_path from setuptools import setup import haipproxy this_directory = os_path.abspath(os_path.dirname(__file__)) # 读取文件内容 def read_file(filename): with open(os_path.join(this_directory, filename), encoding=&#39;utf-8&#39;) as f: long_description = f.read() return long_description # 获取依赖 def read_requirements(filename): return [line.strip() for line in read_file(filename).splitlines() if not line.startswith(&#39;#&#39;)] setup( name=&#39;haipproxy&#39;, # 包名 python_requires=&#39;&gt;=3.4.0&#39;, # python环境 version=haipproxy.__version__, # 包的版本 description=&quot;High aviariable proxy pool client for crawlers.&quot;, # 包简介，显示在PyPI上 long_description=read_file(&#39;README.md&#39;), # 读取的Readme文档内容 long_description_content_type=&quot;text/markdown&quot;, # 指定包文档格式为markdown author=&quot;Resolvewang&quot;, # 作者相关信息 author_email=&#39;resolvewang@foxmail.com&#39;, url=&#39;https://github.com/SpiderClub/haipproxy&#39;, # 指定包信息，还可以用find_packages()函数 packages=[ &#39;haipproxy&#39;, &#39;haipproxy.client&#39;, &#39;haipproxy.utils&#39; ], install_requires=read_requirements(&#39;requirements.txt&#39;), # 指定需要安装的依赖 include_package_data=True, license=&quot;MIT&quot;, keywords=[&#39;proxy&#39;, &#39;client&#39;, &#39;haipproxy&#39;], classifiers=[ &#39;Intended Audience :: Developers&#39;, &#39;License :: OSI Approved :: MIT License&#39;, &#39;Natural Language :: English&#39;, &#39;Programming Language :: Python :: 3.4&#39;, &#39;Programming Language :: Python :: 3.5&#39;, &#39;Programming Language :: Python :: 3.6&#39;, ],)]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python编码规范]]></title>
    <url>%2F2019%2F03%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20190307_python%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[标签（空格分隔）： python PEP8 代码 规范 在日常工作中，编写python代码时，大家有可能因为IDE的不同或者是没有遵循python的pep8规范而导致每个人的格式都不尽相同，导致其他人阅读起来比较吃力。但是有时候代码规范也并不是建议使用的，最主要的是风格一致性，每个组内的代码风格统一起来才是最重要的，根据自己的判断选择是否遵循PEP8。ps: 许多项目有自己的编码规范，在出现规范冲突时，项目自身的规范优先。 接下来我们只挑一些在工作中频繁遇到规范进行示例，为减少大家阅读时间，以 推荐 和 糟糕 来说明。 Code lay-out 代码布局Indentation 缩进每一级缩进使用4个空格。 推荐: # 与左括号对齐 foo = long_function_name(var_one, var_two, var_three, var_four) # 用更多的缩进来与其他行区分 def long_function_name( var_one, var_two, var_three, var_four): print(var_one) # 挂行缩进应该再换一行 foo = long_function_name( var_one, var_two, var_three, var_four) # 与内容对齐 my_list = [ 1, 2, 3, 4, 5, 6, ] # 与第一行第一个字符对齐 my_list = [ 1, 2, 3, 4, 5, 6, ] 糟糕: # 没有使用垂直对齐时，禁止把参数放在第一行 foo = long_function_name(var_one, var_two, var_three, var_four) # 当缩进没有与其他行区分时，要增加缩进 def long_function_name( var_one, var_two, var_three, var_four): print(var_one) my_list = [1, 2, 3, 4, 5, 6] Maximum Line Length 行的最大长度所有行限制的最大字符数为79。 Blank Lines 空行推荐: # 类与类之间前后用两个空行隔开 Class A:... Class B:... # 类中函数与函数之间前后用一个空行隔开 Class C: def c_a(self):... def c_b(self):... # 函数与函数之间前后用两个空行隔开 def a_run():... def b_run():... # 在函数中使用空行来区分逻辑段（谨慎使用）。 def c_run(): # 逻辑A ... ... # 逻辑B ... ... Imports 导入推荐: 导入应该按照以下顺序分组： 标准库导入 相关第三方库导入 本地应用/库特定导入 同时在每一组导入之间加入空行。 # 官方标准库导入 import os import sys # 第三方库 import arrow import requests # 导入本地库 import app # 以from导入标准库 from datetime import datetime # 以from导入第三方库 from ldap3 import Server # 以from导入本地库 from app import DB from . import create_app # 处理绝对路径过长时可以以相对路径进行替换 糟糕: # 在import中导入多个库 import sys, os Whitespace in Expressions and Statements 表达式和语句中的空格二元运算符中的空格： 推荐: i = i + 1 submitted += 1 x = x*2 - 1 hypot2 = x*x + y*y c = (a+b) * (a-b) 糟糕: i=i+1 submitted +=1 x = x * 2 - 1 hypot2 = x * x + y * y c = (a + b) * (a - b) 关键字参数或者默认参数值： 推荐: def complex(real, imag=0.0): return magic(r=real, i=imag) 糟糕: def complex(real, imag = 0.0): return magic(r = real, i = imag) Comments 注释当更新代码时，一定要记得同步更新注释，否则使阅读的人会陷入更糟糕的近况。 Documentation Strings 文档字符串推荐: &quot;&quot;&quot;Return a foobang Optional plotz says to frobnicate the bizbaz first. &quot;&quot;&quot; Function Annotation 函数或方法注释大家在写函数或者方法时，往往会漏掉当前方法或函数的作用，其实这个还是很重要的，这样往往不需要阅读你的逻辑就可以知道你准备干什么 推荐: &quot;&quot;&quot; def oa_notice_template(project, api, account, cpu, mem): &quot;&quot;&quot; 压测申请模板 :param project: 项目名称 :param api: 接口名称 :param account: 申请人 :param cpu: cpu核数 :param mem: 内存大小 :return: &quot;&quot;&quot; &quot;&quot;&quot; Other Recommendations 其他建议在编写代码时，阅读者追寻编写人时往往很困难，或者此文件具体是做什么的。这个时候我们稍微添加一些个人信息注释就很好做到追源了。 推荐: &quot;&quot;&quot; @Description: 接口测试上传 @Author : duanfei @Time : 2020/5/9 11:51 下午 @Site : @File : http_test.py &quot;&quot;&quot; import os ... Naming Conventions 命名规范命名规范很重要，很多时候你的命名能够大致的解释了变量、函数、类是用来做什么的。所以在命名的时候一定要选择贴近的词义，让阅读者可以理解 Package and Module Names 包名和模块名模块应该用简短全小写的名字，如果为了提升可读性，下划线也是可以用的。Python包名也应该使用简短全小写的名字，但不建议用下划线。 Class Names 类名类名一般使用单词首字母大写的约定 推荐: class CheckFunc:... 糟糕: # 首字符需大写，同时类名中无需带下划线 class check_func:... # 全部大写，同时类名中无需带下划线 class CHECK_FUNC:... Function Names 函数名函数名应该小写，如果想提高可读性可以用下划线分隔。 推荐: def check_func():... Variable Names 变量名一定要靠近变量的意思，不要使用一些意义不明的参数，如：i，j，k，特别注意永远不要使用字母‘l’（小写的L），‘O’（大写的O），或者‘I’（大写的I）作为单字符变量名。 糟糕: l = [] i = 0 xxx = [for i in xx] Constants 常量常量一般默认全部为大写, 同时一定要表明好注释 推荐: TOTAL = 10 # 订单总页数 # 最大溢出量 MAX_OVERFLOW = 1000 Exception Names 异常名因为异常一般都是类，所有类的命名方法在这里也适用。 推荐: class ErrorInvalidArgument(ApiError): &quot;&quot;&quot; 参数缺失或错误 &quot;&quot;&quot; code = 401001 code_name = &#39;Invalid_Argument&#39; message = &#39;invalid argument.&#39; zh_message = &#39;参数缺失或错误&#39; Programming Recommendations 编程建议关于异常处理： 推荐: try: value = collection[key] except KeyError: return key_not_found(key) else: return handle_value(value) 糟糕: try: return handle_value(collection[key]) except KeyError: return key_not_found(key) 关于返回结果处理： 不管在任何时候返回结果都需要保持一致。 推荐: def foo(x): if x &gt;= 0: return math.sqrt(x) else: return None def bar(x): if x &lt; 0: return None return math.sqrt(x) 糟糕: def foo(x): if x &gt;= 0: return math.sqrt(x) def bar(x): if x &lt; 0: return return math.sqrt(x) 关于True、Fakse的判断： 不要用 == 去和True或者False比较 推荐: if greeting: ... 糟糕: if greeting == True: ... if greeting is True: ... 附录 PEP8 规范链接： 官方链接、中文翻译 ==================================================规范—新手村（孙晓飞） 一. 基本常识 相信现代编译器的bug是很难遇到的也就是说，当你的程序出现bug的时候，最后去怀疑编译器和系统（windows除外） mr要有意义最大也是最重要的原因是——在采用squash合入master的时候，mr的title会作为这次merge的commit信息，没有意义的mr==没有意义的commit。那么，为什么commit要有意义呢……去面壁吧，不说这个问题了…… 不明白的代码，不要乱用！不明白的代码，不要乱用！ 不明白的代码，不要乱用！ OK我说了三遍了 不要有过多输出尤其是你开发的是一个包会被别人调用的情况下，因为别人连关都关不掉 没有经过profile过的程序做瓶颈优化都是耍流氓profile的方法参见：（假装有东西，等写完放过来） 万恶之源 有的人说重复代码是万恶之源，有的人说过早的重构（或优化）是万恶之源 这两种说法虽然是矛盾的，但是都说出了部分的真相——我个人的偏好是： if 存在重复代码 { if 不需要使用interface(go和java里的interface，python里的抽象类，c++里的模板)就可以解决{ do 干他！ } else { if 处于项目早期 { 项目优先 } else { do 干他！ } } } else { print(“大侠再见”) } 尊重IDE最重要的是尊重编译器的warning 代码不要给其他人造成心智负担包括但不仅限于： merge后的分支需要删除，无论本地还是远端，都要删除不要用注释代码的方式保留老代码；注释要有意义使用正确的变量名（Python）使用variable annotation 减少中文的使用包括但不仅限于，中文文档、CSDN、百度搜索等等 PyCharm 的doc string采用google style 减少语言原生http request的使用，改用成熟的包我们后面会有越来越多的调用其他service的情况，请使用更加成熟更加上层的包（例如go的gorequests、resty或者python的requests），尽量减少原生http包的使用 原因包括但不仅限于： 原生的http包是为了底层应用的，而我们是上层应用，不需要那么底层，就好像我们的web service不会手动从底层写一样 更加方便，许多的设置更加人性 不需要处理字符转义、文件读写等各种细节问题 长时间离开工位请关闭屏幕尤其是每天走之前，请记得对自己的电脑锁屏，避免不必要的麻烦 不然的话会在群里看到自己要请大家喝奶茶的消息 :) 程序是很少骗人的，如果出现了本地和远端或者服务器和docker运行结果不一致的情况，请先保证【环境一致】二. 学会提问将这一点单独拿出来讲是因为它很重要！！！！ 问别人错误之前，先看错误提示，如果根据错误提示能找到的答案，不要问 google是个好东西，很多error可以搜索得到 优先使用英文文档 三. 强制使用termius （windows用户强制，会折腾microsoft terminal的请忽略我）source tree （mac和windows）ShannonWIKIPyCharm的save action插件，在save的时候选择reformat以及optimizeGoLand的File Watchers里启用go fmt每个项目都要要设置line seperator为Unix模式，也就是使用\n。windows用户要尤其注意。除非你厉害，否则不要用vim或者emacs，人类发明很多工具是有理由的 四. 严格禁止使用IDE做VCS绝对路径，之前提过了 五. 一些代码规范 关于文件路径规定一下： 除了config文件，项目中绝对不准使用绝对路径！！！！！！！在任何地方，都不允许使用linux的相对路径，也就是”../“这种形式解释一下正确做法： 项目中，数据分为两种：一种是不需要外部传入的数据，这类数据的路径一定是相对于项目根目录的路径的，具体做法是用Python的函数获取项目的路径，然后其他素有路径都是相对于这个录几个的；另一种是外部挂载的数据，一般是是大数据或者敏感数据，这类是将路径写在config中，然后将config忽略来做到的 不允许绝对路径，不允许赤裸裸的相对路径！！！！！！！！！！！！！！！ 参数过多时 python代码，如果参数过多需要换行，建议采用这种形式： function( para_1, para_2, … ) 而不是： function(para_1, para_2, …) 更不能： function(para_1, para_2 ) 不要乱用字典各位，很严肃的提醒，字典（python里的dict，go、C++、java里的map）这种数据结构，适用于存储key-value结构，而且是key不定的情况，如果key是确定的，最好声明一个类来存储，否则代码维护性极差，我们之前已经吃过亏了，不要再吃亏了。因此，以后如果key是确定的情况，严禁使用字典作为传参手段，尤其是python，不要把编程语言的字典当成json来用。 git的开发规范 从master上，新建分支，然后做修改，commit，push，远端merge后，checkout到master，然后拉取远端，然后进入下一轮开发。严禁在master上做修改，然后checkout到新分支，然后提交！！！！]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python虚拟环境]]></title>
    <url>%2F2019%2F03%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20190306_python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[source activate conda_venvconda activate conda_venv source deactivate conda虚拟环境1、首先在所在系统中安装Anaconda。可以打开命令行输入conda -V检验是否安装以及当前conda的版本。 2、conda常用的命令。 1）conda list 查看安装了哪些包。 2）conda env list 或 conda info -e 查看当前存在哪些虚拟环境 3）conda update conda 检查更新当前conda 3、创建python虚拟环境。 使用 conda create -n your_env_name python=X.X（2.7、3.6等)命令创建python版本为X.X、名字为your_env_name的虚拟环境。your_env_name文件可以在Anaconda安装目录envs文件下找到。 4、使用激活(或切换不同python版本)的虚拟环境。 打开命令行输入python --version可以检查当前python的版本。 使用如下命令即可 激活你的虚拟环境(即将python的版本改变)。 Linux: source activate your_env_name(虚拟环境名称) Windows: activate your_env_name(虚拟环境名称) 这是再使用python –version可以检查当前python版本是否为想要的。 5、对虚拟环境中安装额外的包。 使用命令conda install -n your_env_name [package]即可安装package到your_env_name中 6、关闭虚拟环境(即从当前环境退出返回使用PATH环境中的默认python版本)。 使用如下命令即可。 Linux: source deactivate Windows: deactivate 7、删除虚拟环境。 使用命令conda remove -n your_env_name(虚拟环境名称) –all， 即可删除。 8、删除环境中的某个包。 使用命令conda remove –name your_env_name package_name 即可。]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python图形界面]]></title>
    <url>%2F2019%2F03%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20190305_%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[1. 用python画出玫瑰图案 import turtle as t # 定义一个曲线绘制函数 def DegreeCurve(n, r, d=1): for i in range(n): t.left(d) t.circle(r, abs(d)) # 初始位置设定 s = 0.2 # size t.setup(450*5*s, 750*5*s) t.pencolor(&quot;black&quot;) t.fillcolor(&quot;red&quot;) t.speed(100) t.penup() t.goto(0, 900*s) t.pendown() # 绘制花朵形状 t.begin_fill() t.circle(200*s,30) DegreeCurve(60, 50*s) t.circle(200*s,30) DegreeCurve(4, 100*s) t.circle(200*s,50) DegreeCurve(50, 50*s) t.circle(350*s,65) DegreeCurve(40, 70*s) t.circle(150*s,50) DegreeCurve(20, 50*s, -1) t.circle(400*s,60) DegreeCurve(18, 50*s) t.fd(250*s) t.right(150) t.circle(-500*s,12) t.left(140) t.circle(550*s,110) t.left(27) t.circle(650*s,100) t.left(130) t.circle(-300*s,20) t.right(123) t.circle(220*s,57) t.end_fill() # 绘制花枝形状 t.left(120) t.fd(280*s) t.left(115) t.circle(300*s,33) t.left(180) t.circle(-300*s,33) DegreeCurve(70, 225*s, -1) t.circle(350*s,104) t.left(90) t.circle(200*s,105) t.circle(-500*s,63) t.penup() t.goto(170*s,-30*s) t.pendown() t.left(160) DegreeCurve(20, 2500*s) DegreeCurve(220, 250*s, -1) # 绘制一个绿色叶子 t.fillcolor(&#39;green&#39;) t.penup() t.goto(670*s,-180*s) t.pendown() t.right(140) t.begin_fill() t.circle(300*s,120) t.left(60) t.circle(300*s,120) t.end_fill() t.penup() t.goto(180*s,-550*s) t.pendown() t.right(85) t.circle(600*s,40) # 绘制另一个绿色叶子 t.penup() t.goto(-150*s,-1000*s) t.pendown() t.begin_fill() t.rt(120) t.circle(300*s,115) t.left(75) t.circle(300*s,100) t.end_fill() t.penup() t.goto(430*s,-1070*s) t.pendown() t.right(30) t.circle(-600*s,35) t.done() 2. 用Python画出奥运五环图import turtle turtle.width(10) turtle.color(&quot;blue&quot;) turtle.circle(50) turtle.color(&quot;black&quot;) turtle.penup() turtle.goto(120, 0) turtle.pendown() turtle.circle(50) turtle.color(&quot;red&quot;) turtle.penup() turtle.goto(240, 0) turtle.pendown() turtle.circle(50) turtle.color(&quot;yellow&quot;) turtle.penup() turtle.goto(60, -50) turtle.pendown() turtle.circle(50) turtle.color(&quot;green&quot;) turtle.penup() turtle.goto(180, -50) turtle.pendown() turtle.circle(50) 3. 绘制多个同心圆代码如下： import turtle t = turtle.Pen() my_colors = (&quot;red&quot;, &quot;green&quot;, &quot;yellow&quot;, &quot;black&quot;) t.width(4) t.speed(1) for i in range(10): # 0 1 2 3 4 t.penup() t.goto(0, -i*10) # 0, -100,-200,-300,-400 t.pendown() t.color(my_colors[i%len(my_colors)]) t.circle(15+i*10) # 100,200,300, 400,, 500 turtle.done() # 程序执行完，窗口仍然在 执行结果如下图： 4. 用Python 绘制 18*18 棋盘import turtle width = 30 num = 18 x1 = [(-400, 400), (-400+width*num, 400)] y1 = [(-400, 400), (-400, 400-width*num)] t = turtle.Pen() t.speed(10) for i in range(0, 19): t.penup() t.goto(x1[0][0], x1[0][1]-30*i) t.pendown() t.goto(x1[1][0], x1[1][1]-30*i) for i in range(0, 19): t.penup() t.goto(y1[0][0]+30*i,y1[0][1]) t.pendown() t.goto(y1[1][0]+30*i,y1[1][1]) t.hideturtle() # 隐藏画笔 turtle.done() # 保证运行窗口不被自动关闭]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python操作excel]]></title>
    <url>%2F2019%2F03%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20190304_%E6%93%8D%E4%BD%9Cexcel%2F</url>
    <content type="text"><![CDATA[excel格式:https://www.cnblogs.com/fkissx/p/5617630.html 1. 类库xlwt/xlrd 用于生成和读取比较老的excel文件，比如xls格式，最大限制为65535行； 文档地址：https://xlwt.readthedocs.io/en/latest/index.html columns = [&#39;日期&#39;, &#39;PV&#39;, &#39;UV&#39;, &#39;name&#39;] datas = [ [&#39;2019-07-15&#39;, &#39;16000&#39;, &#39;150&#39;, &#39;Andy&#39;], [&#39;2020-02-15&#39;, &#39;9000&#39;, &#39;70&#39;, &#39;李&#39;], [&#39;2015-07-15&#39;, &#39;6000&#39;, &#39;50&#39;, &#39;张&#39;], [&#39;2020-01-15&#39;, &#39;12000&#39;, &#39;80&#39;, &#39;刘&#39;], ] import xlwt workbook = xlwt.Workbook(encoding=&#39;utf-8&#39;) sheet = workbook.add_sheet(&#39;puvn_sheet&#39;) # 写入标题 for col, columns in enumerate(columns): sheet.write(0, col, columns) # 写入每一行 for row, data in enumerate(datas): for col, columns_data in enumerate(data): sheet.write(row + 1, col, columns_data) workbook.save(&#39;puvn_sheet.xls&#39;) 2. 类库openpyxl 用于生成2010之后新的excel文件，比如xlsx格式； 文档地址：https://openpyxl.readthedocs.io/en/stable/ columns = [&#39;日期&#39;, &#39;PV&#39;, &#39;UV&#39;, &#39;name&#39;] datas = [ [&#39;2019-07-15&#39;, &#39;16000&#39;, &#39;150&#39;, &#39;Andy&#39;], [&#39;2020-02-15&#39;, &#39;9000&#39;, &#39;70&#39;, &#39;李&#39;], [&#39;2015-07-15&#39;, &#39;6000&#39;, &#39;50&#39;, &#39;张&#39;], [&#39;2020-01-15&#39;, &#39;12000&#39;, &#39;80&#39;, &#39;刘&#39;], ] from openpyxl import Workbook wk = Workbook() # 默认sheet sheet = wk.active sheet.title = &#39;默认sheet&#39; sheet.append(columns) for data in datas: sheet.append(data) wk.save(&#39;openpyxl.xlsx&#39;) # xls和xlsx均可 3. 类库pandas pandas是最强大的数据分析库，自带python读取和生成模块； 文档地址：https://pandas.pydata.org/ 使用的是：pandas.DataFrame.to_excel]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlalchemy的使用]]></title>
    <url>%2F2019%2F03%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20190303_sqlchemy%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[1. 连接数据库使用create_engine()实现连接，需要了解create_engine()各个参数的作用 # 连接数据库 from sqlalchemy import create_engine engine = create_engine( &quot;mysql+pymysql://root:1990@localhost:3306/crawl_test?charset=utf8&quot;, echo=True) 2. 创建数据表定义实体映射类数据表结构，通过操作类属性从而操作数据表字段 创建表结构的方式创建一个自增的数字主键！！！：不需要特意的设定，SQLAlchemy will automatically set the first Integer PK column that’s not marked as a FK as autoincrement=True # 创建数据表方法一 from sqlalchemy import Column, Integer, String, DateTime from sqlalchemy.ext.declarative import declarative_base Base = declarative_base() class mytable(Base): # 表名 __tablename__ = &#39;mytable&#39; # 字段，属性 id = Column(Integer, primary_key=True) name = Column(String(50), unique=True) age = Column(Integer) birth = Column(DateTime) class_name = Column(String(50)) Base.metadata.create_all(engine) # 创建数据表方法二 from sqlalchemy import Column, MetaData, ForeignKey, Table from sqlalchemy.dialects.mysql import (INTEGER, CHAR) meta = MetaData() myclass = Table(&#39;myclass&#39;, meta, Column(&#39;id&#39;, INTEGER, primary_key=True), Column(&#39;name&#39;, CHAR(50), ForeignKey(mytable.name)), Column(&#39;class_name&#39;, CHAR(50)) ) myclass.create(bind=engine) 删除数据表： # 删除数据表 StudentItem.drop(bind=engine) Base.metadata.drop_all(engine) 3. 创建持久化对象引入sessionmaker模块，绑定已连接数据库的engin对象，生成会话对象session 4. 添加数据对实体类的属性赋值，通过session.add()方法添加数据，通过session.commit()方法提交数据。 new_data = mytable(name=&#39;Li Lei&#39;,age=10,birth=&#39;2017-10-01&#39;,class_name=&#39;一年级一班&#39;) session.add(new_data) session.commit() session.close() 5. 更新数据先查询需要修改的数据对象再更新，更新方法有修改对象属性值 和 使用update()方法更新数据。 session.query(mytable).filter_by(id=1).update({ mytable.age : 12}) session.commit() session.close() 6. 删除数据session.query(mytable).filter_by(id=1).delete() session.commit() session.close() 7. 查询数据filter_by相当于SQL语句里面的where判断;join相当于SQL语句中的inner join ;outerjoin相当于full outer join ; 1、查询myclass全部数据 # 查询myclass全部数据，相当于select * from myclass; # all()是将数据以列表的形式返回 get_data = session.query(myclass).all() for i in get_data: print(&#39;我的名字是：&#39; + i.name) print(&#39;我的班级是：&#39; + i.class_name) session.close() # 查询某些字段，相当于select name, class_name from myclass; get_data = session.query(myclass.name, myclass.class_name).all() for i in get_data: print(&#39;我的名字是：&#39; + i.name) print(&#39;我的班级是：&#39; + i.class_name) session.close() 2、设置筛选条件filter和filter_by # 根据条件查询某条数据 # 筛选方法一： # get_data = session.query(myclass).filter(myclass.id==1).all() # 筛选方法二： get_data = session.query(myclass).filter_by(id=1).all() print(&#39;数据类型是：&#39; + str(type(get_data))) for i in get_data: print(&#39;我的名字是：&#39; + i.name) print(&#39;我的班级是：&#39; + i.class_name) 把all()换成first()可以查询1条数据： # 查询id为1的数据 single_stu = session.query(StudentItem).filter_by(stu_id=stu_id).first() 3、设置多筛选条件： 带and的查询，如：select * from mytable where id&gt;1 and class_name=’三年级二班’，代码如下： get_data = session.query(mytable).filter(mytable.id &gt;= 2, mytable.class_name == &#39;三年级二班&#39;).first() print(&#39;数据类型是：&#39; + str(type(get_data))) print(&#39;我的名字是：&#39; + get_data.name) print(&#39;我的班级是：&#39; + get_data.class_name) 带or的查询，如：select * from mytable where id&gt;1 and class_name=’三年级二班’，代码如下: from sqlalchemy import or_ get_data = session.query(mytable).filter(or_(mytable.id &gt;= 2, mytable.class_name == &#39;三年级二班&#39;)).all() print(&#39;数据类型是：&#39; + str(type(get_data))) print(&#39;我的名字是：&#39; + get_data.name) print(&#39;我的班级是：&#39; + get_data.class_name) 涉及多表查询的内连接查询和外连接查询： # 内连接 get_data = session.query(mytable).join(myclass).filter(mytable.class_name == &#39;三年级二班&#39;).all() print(&#39;数据类型是：&#39; + str(type(get_data))) for i in get_data: print(&#39;我的名字是：&#39; + i.name) print(&#39;我的班级是：&#39; + i.class_name) # 外连接 get_data = session.query(mytable).outerjoin( myclass).filter(mytable.class_name == &#39;三年级二班&#39;).all() 4、涉及复杂的查询语句，特别涉及多表查询和复杂的查询条件时，可直接执行sql语句： sql = &#39;select * from mytable &#39; session.execute(sql) # 如果涉及更新，添加数据，需要session.commit() session.commit() 8. 综合案例(1)# -*- encoding: utf-8 -*- # 连接数据库 from sqlalchemy import create_engine from sqlalchemy import Column, Integer, String, DateTime from sqlalchemy.ext.declarative import declarative_base engine = create_engine(&quot;mysql+pymysql://root:12345678@localhost:3306/my_test?charset=utf8&quot;, echo=True) Base = declarative_base() class StudentItem(Base): &quot;&quot;&quot;创建数据表方法一&quot;&quot;&quot; # 表名 __tablename__ = &#39;my_student&#39; # 字段，属性 stu_id = Column(Integer, primary_key=True, autoincrement=True) stu_name = Column(String(50), unique=True) stu_age = Column(Integer) stu_birth = Column(DateTime) stu_class_name = Column(String(50)) sqlalchemy_test.py from sqlalchemy.orm import sessionmaker from crawl_test.orm import Base, engine, StudentItem get_session = sessionmaker(bind=engine) # 可设置autocommit=True 对当前session进行设置 session = get_session() def create_table(engine): &quot;&quot;&quot;创建表&quot;&quot;&quot; Base.metadata.create_all(engine) def add_one(): &quot;&quot;&quot;向表中添加数据&quot;&quot;&quot; try: new_data = StudentItem(stu_name=&#39;王五&#39;, stu_age=30, stu_birth=&#39;2005-06-09&#39;, stu_class_name=&#39;六年级4班&#39;) session.add(new_data) session.commit() print(&#39;向表中添加单条数据成功&#39;) session.close() except Exception as e: session.rollback() raise Exception(f&#39;向数据库添加数据失败 ：{e}&#39;) def query_one(stu_id=None, stu_name=None): &quot;&quot;&quot;根据id或者名字查询,返回字典&quot;&quot;&quot; try: if stu_id: single_stu = session.query(StudentItem).filter_by(stu_id=stu_id).first() else: single_stu = session.query(StudentItem).filter_by(stu_name=stu_name).first() single_stu_dict = single_stu.__dict__ return single_stu_dict except Exception as e: session.rollback() raise Exception(f&#39;数据库查询失败 ：{e}&#39;) finally: session.close() def query_all(): &quot;&quot;&quot;查询所有数据，返回一个列表&quot;&quot;&quot; stu_data_list = [] try: stu_data = session.query(StudentItem).all() # 遍历对象的列表，并转换成字典 for stu in stu_data: stu_dict = stu.__dict__ stu_data_list.append(stu_dict) return stu_data_list except Exception as e: session.rollback() raise Exception(f&#39;数据库查询失败 ：{e}&#39;) finally: session.close() def update_stu_data(stu_id=None, stu_name=None, stu_data_dict=None): &quot;&quot;&quot;根据id或者名字来修改数据&quot;&quot;&quot; try: if stu_id: result = session.query(StudentItem).filter_by(stu_id=stu_id).update(stu_data_dict) else: result = session.query(StudentItem).filter_by(stu_name=stu_name).update(stu_data_dict) print(&#39;修改成功&#39;, result) session.commit() session.close() except Exception as e: session.rollback() raise Exception(f&#39;修改数据失败 ：{e}&#39;) def delete_stu_data(stu_id=None, stu_name=None): &quot;&quot;&quot;删除一个数据&quot;&quot;&quot; try: if stu_id: ret = session.query(StudentItem).filter(StudentItem.stu_id == stu_id).delete() else: ret = session.query(StudentItem).filter(StudentItem.stu_name == stu_name).delete() print(&#39;删除成功&#39;, ret) session.commit() session.close() except Exception as e: session.rollback() raise Exception(f&#39;删除数据失败 ：{e}&#39;) if __name__ == &quot;__main__&quot;: # create_table(engine) # 增加一个数据 # add_one() # 查询：根据id或者姓名查询单个数据 stu_data = query_one(stu_id=6) print(stu_data[&#39;stu_name&#39;]) # 查询：所有数据 # stu_data_list = query_all() # for stu_data in stu_data_list: # print(stu_data) # 更新数据 # data_dict = { # StudentItem.stu_age: 42, # StudentItem.stu_name: &#39;张君宝&#39; # } # update_stu_data(stu_name=&#39;张无忌&#39;, stu_data_dict=data_dict) # 删除数据 # delete_stu_data(stu_id=3) 9. 综合案例（2）1、创建一个schema: Base = declarative_base() #生成orm基类 class AlchemyTest(Base): __tablename__ = &#39;tbSqlAlchemyTest&#39; #这里不用加上dbo.前缀，默认已经有了 TestName = Column(String(256), primary_key=True) TestNumber = Column(INTEGER) #the table object is a member of a larger collection known as MetaData Base.metadata.create_all(engine) #通过基类与数据库进行交互创建表结构，此时表内还没有数据 还可以在创建class的末尾加上类似于： def __repr__(self): return &quot;&lt;User(name=&#39;%s&#39;, fullname=&#39;%s&#39;, password=&#39;%s&#39;)&gt;&quot; % ( self.name, self.fullname, self.password) 这个为可选项，只是增加对于表的描述，便于以后测试 向表内加入数据：先创建一个实例：test1 = AlchemyTest(TestName=&#39;user1&#39;, TestNumber=1995) 再创建一个会话： from sqlalchemy.orm import sessionmaker Session_class = sessionmaker(bind=engine) #建立与数据库的会话连接，这里建立的是一个class不是一个实例对象 session = Session_class() #这里创建一个会话实例 test1 = AlchemyTest(TestName=&#39;user1&#39;, TestNumber=1995) session.add(test1) #把要创建的数据对象加入到这个会话中，这个时候是pending状态，添加多个对象使用add_all() session.commit() #统一提交会话中的操作 session.close() 在提交这个会话之前就可以使用：our_user = session.query(User).filter_by(name=&#39;ed&#39;).first() 来查看刚刚创建的数据在会话提交之前，还可以这样回滚这个会话，使之前flush的内容失效： session.rollback()每个session会话才是真正的与数据库的连接 2、建立表与表之间的关系（一对多，多对一）： 多对一：employee对于department是多对一的关系 class Department(Base): __tablename__ = &#39;department&#39; id = Column(Integer, primary_key=True) name = Column(String(30)) class Employee(Base): __tablename__ = &#39;employee&#39; id = Column(Integer, primary_key=True) name = Column(String(30)) dep_id = Column(Integer, ForeignKey(&#39;department.id&#39;)) department = relationship(&quot;Department&quot;) 一对多：department对于employee是一对多的关系 class Department(Base): __tablename__ = &#39;department&#39; id = Column(Integer, primary_key=True) name = Column(String(30)) employees = relationship(&quot;Employee&quot;) class Employee(Base): __tablename__ = &#39;employee&#39; id = Column(Integer, primary_key=True) name = Column(String(30)) dep_id = Column(Integer, ForeignKey(&#39;department.id&#39;)) 新建一个tbSqlAlchemyTestError的table 一个test可以有多个error class AlchemyTestError(Base): __tablename__ = &#39;tbSqlAlchemyTestError&#39; errorID = Column(INTEGER, primary_key=True) errorname = Column(String(256), nullable=False) TestName = Column(String(256), ForeignKey(&#39;tbSqlAlchemyTest.TestName&#39;))#这里面关联外键使用表的名字而不是类的名字,表与表之间建立联系 test = relationship(&quot;AlchemyTest&quot;, back_populates=&quot;error&quot;) #告诉ORM,自己这个class与AlchemyTest这个class相关联，并且设定了一个“多对一”的关系 #*在自己这个类中生成一个test属性，然后在AlchemyTest类中创建一个error属性，与之关联，可以反向查询* AlchemyTest.error = relationship(&quot;AlchemyTestError&quot;, back_populates=&quot;test&quot;) #与上面一个relationship形成双向relationship，意思是在AlchemyTest类中生成一个error属性，然后与AlchemyTestError中的test属性相关联 #所以实际上与上面一个relationship是一样的意思 给一对多的关系表插入数据： test1 = session.query(AlchemyTest).filter(AlchemyTest.TestName == &#39;user1&#39;).first() #首先提取需要加入error的test，这个已经存在 test1.error = [AlchemyTestError(errorID=&#39;553&#39;, errorname=&#39;cuowu&#39;), AlchemyTestError(errorID=&#39;667&#39;, errorname=&#39;afsf&#39;)] #使用relationship()时建立的error属性来给AlchemyTestError插入数据 session.add(test1) session.commit()stmt 使用query.join()结合两张表来查询数据表数据： result = session.query(AlchemyTest).join(AlchemyTestError).filter(AlchemyTestError.errorname == &#39;cuowu&#39;).first() #查询AlchemyTest表内的数据，看哪些user有这个error if result is not None: print(result.TestName) 因为这两张表只有一个外键，所以query.join()知道怎么关联这两张表，但是如果没有或者不止一个外键的时候，使用其他的形式： result = session.query(AlchemyTest).join((AlchemyTestError, AlchemyTest.TestName==AlchemyTestError.TestName)).first() 这里有一个join的reminder：join : 如果表中有至少一个匹配，则返回行left join : 即使右表中没有匹配，也从左表返回所有的行right join : 即使左表中没有匹配，也从右表返回所有的行full join : 只要其中一个表中存在匹配，就返回行 outerjoin: query.outerjoin(User.addresses) # LEFT OUTER JOIN 使用别名：当一个table需要被call多次的时候，使用别名aliased()可以弄清： name1 = aliased(AlchemyTest) name2 = aliased(AlchemyTest) 使用subquery()来做子查询：这个例子用于查询每个AlchemyTest的TestName对应了几个error： stmt = session.query(AlchemyTestError.TestName, func.count(&#39;*&#39;).label(&#39;errorcount&#39;)).group_by(AlchemyTestError.TestName).subquery() #一定要使用subquery()才能使这个临时表生效 #相当于生成了一个临时表，stmt它具有表结构，这个表结构的数据我们通过&quot;c&quot;这个属性来获取 for user, count in session.query(AlchemyTest, stmt.c.errorcount).outerjoin(stmt, AlchemyTest.TestName==stmt.c.TestName).order_by(AlchemyTest.TestName): #这里相当于SELECT user FROM AlchemyTest, SELECT count FROM stmt.c.errorcount LEFT OUTER JOIN stmt ON (AlchemyTest.TestName==stmt.c.TestName) print(user.TestName, count) 使用exists()： stmt = exists().where(Address.user_id==User.id) for name, in session.query(User.name).filter(stmt): print(name) 一些描述关系的方法： query.filter(User.addresses.contains(someaddress)) query.filter(User.addresses.any(Address.email_address == &#39;bar&#39;)) query.filter(Address.user.has(name=&#39;ed&#39;)) session.query(Address).with_parent(someuser, &#39;addresses&#39;) 删除数据：删除可以直接使用session.delete()但是与之关联的table并没有删除数据，因为SQLAlchemy并没有设定级联删除！！！解决方案：在一对多关系的table里的relationship设定时增加cascade：cascade=&quot;all, delete, delete-orphan” 建立多对多关系的表结构：例子中有两个tables，分别是博客表和关键字表，一篇博客可以拥有多个关键字，一个关键字也可以对应多篇博客。所以我们要建立一个未映射的关系表： post_keywords = Table(&#39;post_keywords&#39;, Base.metadata, ... Column(&#39;post_id&#39;, ForeignKey(&#39;posts.id&#39;), primary_key=True), ... Column(&#39;keyword_id&#39;, ForeignKey(&#39;keywords.id&#39;), primary_key=True) ... ) 这个表建立的方式与建立一个拥有映射关系的class不同。接下来创建博客表和关键字表分别与这个中间关系表用relationship()关联起来： &gt;&gt;&gt; class BlogPost(Base): ... __tablename__ = &#39;posts&#39; ... ... id = Column(Integer, primary_key=True) ... user_id = Column(Integer, ForeignKey(&#39;users.id&#39;)) ... headline = Column(String(255), nullable=False) ... body = Column(Text) ... ... # many to many BlogPost&lt;-&gt;Keyword ... keywords = relationship(&#39;Keyword&#39;, ... secondary=post_keywords, ... back_populates=&#39;posts&#39;) ... ... def __init__(self, headline, body, author): ... self.author = author ... self.headline = headline ... self.body = body ... ... def __repr__(self): ... return &quot;BlogPost(%r, %r, %r)&quot; % (self.headline, self.body, self.author) &gt;&gt;&gt; class Keyword(Base): ... __tablename__ = &#39;keywords&#39; ... ... id = Column(Integer, primary_key=True) ... keyword = Column(String(50), nullable=False, unique=True) ... posts = relationship(&#39;BlogPost&#39;, ... secondary=post_keywords, ... back_populates=&#39;keywords&#39;) ... ... def __init__(self, keyword): ... self.keyword = keyword]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sqlalchemy的一些概念]]></title>
    <url>%2F2019%2F03%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20190302_sqlalchemy%E7%9A%84%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[官网：https://www.sqlalchemy.org/ Python SQLAlchemy Cheatsheet ： https://www.pythonsheets.com/notes/python-sqlalchemy.html 官方文档：https://docs.sqlalchemy.org/en/latest/orm/tutorial.html 首先 import sqlalchemy可以这样检查版本 sqlalchemy.__version__ 1. sqlalchemy 简介开发人员常用的关系数据库有MySQL,Oracle, SQL Server, SQLite和PostgreSQL，操作数据库的方法大致有以下2种： 直接使用数据库接口连接：在python的数据库连接模块中，分别有pymysql,cx_Oracle,pymssql,sqlite3,psycopg2。通常这类数据库的操作步骤是：连接数据库，执行SQL语句，提交事务，关闭数据库连接。每次操作都需要开启/关闭连接，这么频繁，对系统来说是一种浪费。 通过orm框架来操作数据库：ORM(Object/Relation Mapping)对象-关系映射，主要实现对象到关系数据库的映射（或者说就是在python中设定一个类，在mysql中定义一个表，把关系数据库的表结构映射到这个类上），在实际工作中，企业级开发都是使用orm框架来实现数据库持久化操作的。 常用的ORM框架模块有：SQLObject,stom,Django的ORM,peewee和SQLAlchemy。 SQLAlchemy 是 python 语言中一个比较有名的 ORM 框架。用于连接、操作数据库。提供SQL工具包以及对象-关系映射工具，使用MIT许可证发行。 首次发行于2006年2月，是python社区广泛使用的orm工具之一，不亚于Django的orm框架。 和传统直接操作SQL相比, 使用SQLAlchemy的对象来操作数据库更为直观.SQLAlchemy 内建数据库连接池，解决了连接操作相关繁琐的处理，提供方便的强大的log功能。 类似java里的Hiernate的数据映射模型。 2. sqlalchemy orm优缺点和适用范围1、优点: 简单：ORM以最基本的形式建模数据。表的字段就是这个类的成员变量 可读性：ORM使数据库结构文档化。比如MySQL数据库就被ORM转换为了class类，程序员可以只把注意力放在代码逻辑上（当然能够熟练掌握MySQL更好） 可用性：ORM的避免了不规范、冗余、风格不统一的SQL语句，可以避免很多人为Bug，方便编码风格的统一和后期维护 可维护性：在数据表结构甚至数据库发生改变时，减少了相应的代码修改;可以很方便地引入数据缓存之类的附加功能 2、缺点: 自动化进行关系数据库的映射需要消耗系统性能。一般来说都可以忽略之，特别是有cache存在的时候 在处理多表联查、where条件复杂之类的查询时，ORM的语法会变得复杂 越是功能强大的ORM越是消耗内存，因为一个ORM Object会带有很多成员变量和成员函数。 3、适用范围：适用于快速开发和团队合作开发，不适用于有大数据量(千万/亿级别)、大运算量、复杂查询的系统。 3. 主流数据库的连接方式1、首先安装需要的模块： pip install SQLAlchemy # 如mysql数据库需要长pymysql模块 pip install pymysql 2、主流数据库的连接方式： 数据库 连接字符串 Microsoft SQL Server mssql+pymssql://username:password@ip:port/dbname MySQL mysql+pymysql://username:password@ip:port/dbname Oracle cx_Oracle://username:password@ip:port/dbname PostgreSQL postgressql://username:password@ip:port/dbname SQLite sqlite://file_path 4. 连接实例(获取session) 连接数据库实例3个步骤： 1. 创建engine 2. sessionmaker绑定engine 3. 创建session实例 create_engin的参数及session的创建如下： # 已连接mysql为例 from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker engine = create_engine( # &#39;postgresql+psycopg2://{}:{}@{}:{}/{}&#39;.format( 连接postgresql &#39;mysql+pymysql://{}:{}@{}:{}/{}&#39;.format( # 连接mysql POSTGRESQL_USER_NAME, POSTGRESQL_PASSWORD, POSTGRESQL_HOST, POSTGRESQL_PORT, POSTGRESQL_DB_NAME ), echo=Fase, # -- 如果为真，引擎将记录所有语句 用于调试 echo_pool=False, # -- 如果为true，则连接池将记录信息输出，例如连接失效以及连接回收到默认日志处理程序，用于调试 encoding=&#39;utf-8&#39;, # 默认为 utf-8 . 这是sqlAlchemy用于在sqlAlchemy中发生的字符串编码/解码操作的字符串编码 pool_size=5, #-- 设置连接数，默认设置5个连接数，设置为0表示没有限制 max_overflow=10, # -- 允许在连接池中“溢出”的连接数，即可以在池大小设置（默认为5）之上或之外打开的连接数，默认连接数为10。 pool_timeout=30, # -- 连接超时时间，默认为30秒，超过时间的连接都会连接失败。即在放弃从池中获取连接之前等待的秒数 isolation_level=&quot;AUTOCOMMIT&quot; # 设置引擎范围内的事务隔离级别隔离 pool_recycle=-1 # 连接重置周期，默认为-1，推荐设置7200，即如果连接数已空闲7200秒，就自动重新获取，以防止连接被关闭。 ) Session = sessionmaker(bind=engine) session = Session() #可以把 sessionmaker 想象成一个手机，engine 当做数据库的号码，拨通这个“号码”我们就创建了一个 Session 类。 5. 设置事务级别 isolation_level置引擎范围内的事务隔离级别隔离: create_engine(isolation_level=&quot;READ_COMMITTED&quot;) # 事务隔离级别 对engine范围设置 可选值如下: 值 SERIALIZABLE 串行读 完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞 REPEATABLE_READ 可重复读 确保同一事务的多个实例在并发读取数据时，会看到同样的数据行，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻读 MySQL默认隔离级别； READ_COMMITTED 提交读 只能读取到已经提交的数据。大部分数据库系统的默认隔离级别都是READ-COMMITED，但MySQL不是； READ_UNCOMMITTED 未提交读 事务中的修改，即使没有提交，对其他事务也是可见的，因此可能读到脏数据(脏读，dirty read)； AUTOCOMMIT 自动提交 在命令行执行sql语句，每执行一次操作实质上就是一次事务 6. sessionmaker 参数1、autocommit autocommit参数表示是否自动提交事务,默认关闭,即默认sqlalchemy为每个请求（包含select操作）开启事务,但不会自动提交这个事务，需要手动提交事务。 如果autocommit=True，sqlalchemy会为每个请求（包含select操作）开启事务,并且自动提交这个事务。当你需要保证多条命令是原则性操作，则需使用session.begin()开启事务 isolation_level=”AUTOCOMMIT” 与 sessionmaker(autocommit=True)区别sqlalchemy简单工作流程： 代码（session.query） --&gt; sqlalchemy --&gt; psycopg2 --&gt; postgresql 默认值时（autocommit不开启）：sqlalchemy在执行命令钱会通过psycopg2向数据库发送`begin`命令到数据库（之后所以命令都在事务中执行，不可在次执行session.begin命令） 相同点：最终效果相同（都会在执行select语句后自动提交） 不同点： sessionmaker(autocommit=True) 效果：会在执行命令完毕后断开连接，并将此连接roolback回滚放回连接池。（官方不建议使用）isolation_level=”AUTOCOMMIT”效果：在执行命令之前不会向数据库发送begin命令。 因此两者都可以达到自动提交的效果，但实现方法完全不同。 2、autoflush autoflush 为 True 时（默认是 True），session 进行查询之前会自动把当前累计的修改发送到数据库（注意：autoflush 并不是说在 session.add 之后会自动 flush），举个例子： # 创建了一个对象，这时，这个对象几乎没有任何意义，session 不知道它的存在 &gt;&gt;&gt; user = User(name=&#39;cosven&#39;) # session.add 这个对象之后，它被 session 放到它的对象池里面去了，但这时不会发送任何 SQL 语句给数据库，数据库目前仍然不知道它的存在 &gt;&gt;&gt; session.add(user) # session1.Query 执行之前，由于 autoflush 是 True，session 会先执行 session.flush()(session.flush 的意义：session将变积累的 SQL 语句发送给数据库。)，然后再发送查询语句 # 所以，这个查询是能查到 user &gt;&gt;&gt; session1.query(User).filter_by(name=&#39;cosven&#39;).first() &lt;__main__.User object at 0x1108f04e0&gt; 如果 session 的 autoflush 为 False 的话，session 进行查询之前不会把当前累计的修改发送到数据库，而直接发送查询语句，所以下面这个查询是查不到对象的。 &gt;&gt;&gt; session.add(User(name=&#39;haha&#39;)) &gt;&gt;&gt; session.query(User).filter_by(name=&#39;haha&#39;).first() # None autoflush 的意义：session 在进行查询之前，自动的进行一次 flush 操作。 3、expire_on_commit 如果为True，在commit之后所以实例将完全过期，以便在完成事务之后，获取属性/对象都将从最近的数据库状态加载。 scoped_session 与 sessionmaker区别from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker, scoped_session engine = create_engine() Session = scoped_session( sessionmaker( autoflush = True, bind = engine)) sessionmaker，我们得到一个类，一个能产生session的工厂。(每次调用都会得倒不同的session) scoped_session类似单例模式，当我们调用使用的时候，会先在Registry里找找之前是否已经创建session了。要是有，就把这个session返回。要是没有，就创建新的session，注册到Registry中以便下次返回给调用者。这样就实现了这样一个目的：在同一个线程中，call scoped_session 的时候，返回的是同一个对象 7. 创建orm类# coding =utf-8 # 导入需要的字段类型 from sqlalchemy.dialects.mysql import LONGTEXT from sqlalchemy import Column, VARCHAR, TEXT, DATE, DATETIME # Model基类,创建了一个BaseModel类,这个类的子类可以自动与一个表关联 Base = declarative_base() class ParseHtmlItem(Base): # 指定表名 __tablename__ = &#39;huachuang_parse_html&#39; # 对于表的描述 desc = &#39;华创项目解析详情页信息数据存储&#39; # 表结构 ANCHOR_TITLE = Column(VARCHAR(200), doc={&#39;zh&#39;: &#39;列表页获取详情页标题(外部标题)&#39;}) TAG_TITLE = Column(VARCHAR(200), doc={&#39;zh&#39;: &#39;标签标题&#39;}) TITLE = Column(VARCHAR(200), doc={&#39;zh&#39;: &#39;详情页标题&#39;}) @classmethod def creat_table(cls): &#39;&#39;&#39; 创建数据表 &#39;&#39;&#39; cls.__table__.create(bind=engine_postgresql, checkfirst=True) 8. 常用的SQLAlchemy字段类型 类型名 python中类型 说明 Integer int 普通整数，一般是32位 SmallInteger int 取值范围小的整数，一般是16位 BigInteger int或long 不限制精度的整数 Float float 浮点数 Numeric decimal.Decimal 普通整数，一般是32位 Varchar str 变长字符串 Text str 变长字符串，对较长或不限长度的字符串做了优化 Unicode unicode 变长Unicode字符串 UnicodeText unicode 变长Unicode字符串，对较长或不限长度的字符串做了优化 Boolean bool 布尔值 Date datetime.date 时间 Time datetime.datetime 日期和时间 LargeBinary str 二进制文件 ** 常用的SQLAlchemy列选项 选项名 说明 primary_key 如果为True，代表表的主键 unique 如果为True，代表这列不允许出现重复的值 index 如果为True，为这列创建索引，提高查询效率 nullable 如果为True，允许有空值，如果为False，不允许有空值 default 为这列定义默认值 注意： orm结构中可以只写部分字段，未写出的列会将其忽略 9. 查询、过滤关键字1、使用query查询表的内容：返回的结果是一个tuple session = Session_class() for row in session.query(AlchemyTest).all(): print(row.TestName, row.TestNumber) # 可以使用label()对单独的一列进行命名,这样就对name这一列命名为name_label for row in session.query(User.name.label(&#39;name_label&#39;)).all() pass # 也可以用python的方法限定哪几行： for u in session.query(User).order_by(User.id)[1:3] pass filter_by()可以直接使用关键字进行限制条件，但是filter()能处理更复杂的限制条件。如果有两个限制条件是AND关系，可以直接使用两次filter()处理： session.query(User).filter(User.name==&#39;ed&#39;).filter(User.fullname==&#39;Ed Jones&#39;) 2、下面列表也展示了其他方法：（filter operator :） 作用 符号 相等 == 不相等 != 通配符搜索 like(’%关键字%’) 通配符搜索(不敏感) ilike() 存在于 .in_([‘ed’, ‘wendy’, ‘jack’]) 不存在于 ~User.name.in_([‘ed’, ‘wendy’, ‘jack’]) 为空 == None and .filter(User.name == ‘ed’, User.fullname == ‘Ed Jones’) or or_(User.name == ‘ed’, User.name == ‘wendy’) MATCH .match(‘wendy’) 3、检索返回的列表，以及列表的标量 ： 符号 作用 all() 返回所有 first() 返回第一行 one() 检查是不是只有一行结果 one_or_none() 检查是不是一行或者没有结果 scalar() invokes the one() method, and upon success returns the first column of the row 4、直接使用textual SQL语句 :使用text()可以在query中使用literal strings： session.query(User).filter(text(&quot;id&lt;224&quot;)).order_by(text(&quot;id&quot;)).all() 如果要直接使用完整的整条sql，可以使用text()传给from_statement()： session.query(User).from_statement(text(&quot;SELECT * FROM users where name=:name&quot;)).params(name=&#39;ed&#39;).all() 5、计数：可以直接使用 .count()计算有多少行： session.query(User).filter(User.name.like(&#39;%ed&#39;)).count() 当需要将指定的东西进行计数，就使用func.count()： session.query(func.count(User.id)).scalar() filter 与 filter_by 区别 字段写法：filter筛选的字段是带类名（表名）的，而filter_by只需要筛选字段就可以； 判断条件：filter比filter_by多了一个等号； 作用范围：filter可用于单表或者多表查询，而filter_by只能用于单表查询。 filter 可以像 sql 的 where 语句一样使用 &gt; &lt; 等条件。引用列名时，需要通过 类名.属性名 的方式。filter_by 使用 python 的正常参数传递方法，指定列名时，不需要额外指定类名。 9. 数据库操作（CRUD）1、查询 # 查询ParseHtmlItem.__tablename__ 表中全部数据 session.query(ParseHtmlItem).all() # 查询id为1的值 session.query(ParseHtmlItem).filter_by(ID=1).first() # 得到单个对象 session.query(ParseHtmlItem).filter_by(ID=1).all() # 得到列表 # 查询id 小于5的数据 session.query(ParseHtmlItem).filter(ParseHtmlItem.ID&lt;5).all() # 查询巨大数据量来实现分页的情况，推荐使用通过id区间来读取数据库（提高读取速度） # 取值 data = session.query(ParseHtmlItem).filter_by(ID=1).first() data.ID # 取id的值 2、增加 item = ParseHtmlItem( CONTENT_URL_HASH=content_url_hash, ... ) session.add(item) session.commit() # autocommit=True时，可以不写此命令（但推荐写） 3、修改 # 查询要修改的数据 item = session.query(User).first() item.CONTENT_URL_HASH = &quot;&quot; session.add(usr) session.commit() 4、删除 # 查询要删除的数据 item = session.query(User).first() session.delete(item) session.commit() 10. flush与commit区别在SQLAlchemy中每个事务对应一条或多条SQL语句，这些SQL语句需要经历如下步骤： 将sql语句发送到sql服务器。 在当前事务中执行sql，但不会将修改写入磁盘。 将修改写入磁盘 &emsp;&emsp;flush 操作会执行1，2步骤。&emsp;&emsp; commit操作执行1，2，3步骤。&emsp;&emsp;因此，flush之后你可以在当前Session中看到效果，而commit之后你才能从其它Session中看到效果。 flush 使用场景为：现在已经执行一些操作，但不想结束此事务。 11. 数据库操作错误拦截数据库操作可能因为数据类型/长度，网络原因等问题导致写入数据出错,因此要做好错误拦截避免程序关闭 try: # try 中存放sql操作代码 item = ParseHtmlItem( CONTENT_URL_HASH=content_url_hash, ... ) session.add(item) session.commit() except Exception as e: # 事务回滚，撤销此次事务修改 session.rollback() logging.error(f&quot;sql insert error: {e}&quot;) 注意：使用select语句推荐使用错误拦截，并使用session.rollback()回滚事务（select查询时可能数据库因为一些原因导致此次查询错误，在下次查询时可能持续报错无法正常查询） 12. session 关闭 close session.close() session创建和管理对数据库的连接，当调用close的时候，注意，sqlalchemy不会关闭与mysql的连接，而是把连接返回到连接池。 推荐当前session commit之后就执行close操作（原因：1.每次使用session时都会从连接池中取出，因此可以将session关闭主动放回连接池 2. 可以确保 transaction 有非常清晰的开始和结束，保持 transaction 简短，也就意味着让 transaction 能在一系列操作之后终止，而不是一直开放着。（保留session的生命周期（通常是transaction）独立）） 注意：未commit的transactions会被回滚 13. 整体代码from sqlalchemy import create_engine from sqlalchemy.orm import sessionmaker from sqlalchemy.ext.declarative import declarative_base from sqlalchemy import Column, Integer, String engine = create_engine( # postgresql+psycopg2://{}:{}@{}:{}/{}&#39;.format( 连接postgresql &#39;mysql+pymysql://{}:{}@{}:{}/{}&#39;.format( # 连接mysql POSTGRESQL_USER_NAME, POSTGRESQL_PASSWORD, POSTGRESQL_HOST, POSTGRESQL_PORT, POSTGRESQL_DB_NAME ), echo=Fase, # -- 如果为真，引擎将记录所有语句 用于调试 echo_pool=False, # -- 如果为true，则连接池将记录信息输出，例如连接失效以及连接回收到默认日志处理程序 用于调试 encoding=&#39;utf-8&#39;, # 默认为 utf-8 . 这是sqlAlchemy用于在sqlAlchemy中发生的字符串编码/解码操作的字符串编码 pool_size=5, #-- 在连接池中保持打开的连接数 设置为0表示没有限制 max_overflow=10, # -- 允许在连接池中“溢出”的连接数，即可以在池大小设置（默认为5）之上或之外打开的连接数 pool_timeout=30, # -- 在放弃从池中获取连接之前等待的秒数 isolation_level=&quot;AUTOCOMMIT&quot; # 设置引擎范围内的事务隔离级别隔离 ) Session = sessionmaker(bind=engine) session = Session() Base = declarative_base() class User(Base): __tablename__ = &#39;users&#39; id = Column(Integer, primary_key=True) name = Column(String(50)) fullname = Column(String(50)) password = Column(String(12)) @classmethod def creat_table(cls): &#39;&#39;&#39; 创建数据表 &#39;&#39;&#39; cls.__table__.create(bind=engine_postgresql, checkfirst=True) @classmethod def get_all(cls): &#39;&#39;&#39; 返回所有数据 &#39;&#39;&#39; try: return session_postgresql.query(cls).all() except Exception as e: session_postgresql.rollback() raise Exception(f&#39;数据库查询失败 ：{e}&#39;) finally: session_postgresql.close() def get_item(self, id): &#39;&#39;&#39; 查询指定数据 &#39;&#39;&#39; try: return session.query(self).filter_by(id == id).first() except Exception as e: session_postgresql.rollback() raise Exception(f&#39;数据库查询失败 ：{e}&#39;) finally: session_postgresql.close() 14. 案例 FAQ：session autocommit 使用中错误错误描述 &emsp;&emsp;sqlalchemy 连接 数据库，select操作未commit提交（autocommit=False）这导致 pg 中产生大量的 “idle in transaction” 的长连接。导致需要 ACCESS EXCLUSIVE 锁的语句（如add column）阻塞，并阻塞所有后续需要 ACCESS SHARE 锁的读请求，导致程序异常。 错误例子 （还原）session1 开启事务，并且查询test表：（autocommit=False时所有命令都会开启事务包括select语句） mysql&gt; begin;Query OK, 0 rows affected (0.00 sec) # 在此处开启事务模拟autocommit=False mysql&gt; begin; Query OK, 0 rows affected (0.00 sec) mysql&gt; select * from test1; +----+------+-------+ | id | page | page1 | +----+------+-------+ | 1 | NULL | NULL | +----+------+-------+ 1 row in set (0.00 sec) session2 , 修改表结构，增加字段，这时候会卡住 mysql&gt; alter table test1 add page2 int; session3 再开一个终端，session3模拟其他用户的请求 , 请求也会被卡住 mysql&gt; select * from test1 where id=1; 查看processlist; mysql&gt; show processlist; +----+------+--------------------+------+---------+-------+---------------------------------+---------------------------------+ | Id | User | Host | db | Command | Time | State | Info | +----+------+--------------------+------+---------+-------+---------------------------------+---------------------------------+ | 7 | root | 192.168.33.1:53303 | test | Sleep | 43035 | | NULL | | 8 | root | localhost | test | Query | 0 | starting | show processlist | | 9 | root | localhost | test | Query | 969 | Waiting for table metadata lock | alter table test1 add page2 int | | 10 | root | localhost | test | Query | 134 | Waiting for table metadata lock | select * from test1 where id=1 | +----+------+--------------------+------+---------+-------+---------------------------------+---------------------------------+ id=9的线程，也就是alter表那个线程，在等待锁，此时已经锁住了test表，其他的线程也不能获取锁读取test表。 解决方法 isolation_level=”AUTOCOMMIT” 执行每条命令后都执行commit]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python访问数据库]]></title>
    <url>%2F2019%2F03%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20190301_%E8%AE%BF%E9%97%AE%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[1. python连接mysql并实现增删改查 import pymysql class Databse(object): def __init__(self): self.conn = pymysql.connect(host=&quot;数据库地址&quot;, user=&quot;用户名&quot;, password=&quot;密码&quot;, port=3306, # 端口 database=&quot;数据库名&quot;, charset=&#39;utf8&#39;) self.cursor = self.conn.cursor() def getData(self): data = [] self.cursor.execute(r&quot;select url from worm_tb&quot;) if self.cursor.rowcount != 0: result = self.cursor.fetchall() for d in result: data.append(d[0]) return data def insert(self, url): try: self.cursor.execute(r&quot;insert into worm_tb (url) values (&#39;%s&#39;)&quot; % url) self.conn.commit() except Exception as e: print(e) self.conn.rollback() def die(self): self.cursor.close() self.conn.close() if __name__ == &#39;__main__&#39;: db = Databse() db.insert(&#39;www.baidu.com&#39;) print(db.getData()) db.die() 案例：把控制台输入的数据,写入MySQL数据库 import pymysql def main(): no = int(input(&#39;编号: &#39;)) name = input(&#39;名字: &#39;) loc = input(&#39;所在地: &#39;) # 1. 创建数据库连接对象 con = pymysql.connect(host=&#39;localhost&#39;, port=3306, database=&#39;test&#39;, charset=&#39;utf8&#39;, user=&#39;root&#39;, password=&#39;123456&#39;) try: # 2. 通过连接对象获取游标 with con.cursor() as cursor: # 3. 通过游标执行SQL并获得执行结果 result = cursor.execute( &#39;insert into tb_dept values (%s, %s, %s)&#39;, (no, name, loc) ) if result == 1: print(&#39;添加成功!&#39;) # 4. 操作成功提交事务 con.commit() finally: # 5. 关闭连接释放资源 con.close() if __name__ == &#39;__main__&#39;: main() 2. 用python查询数据库中的数据并保存至文本#coding=utf-8 import pymysql as MySQLdb #这里是python3 如果你是python2.x的话，import MySQLdb host = xxxx user = xxxx passwd = xxxx port = xxxx db = xxxx class SelectMySQL(object): def select_data(self,sql): result = [] try: conn = MySQLdb.connect(host=host, port=port, user=user, passwd=passwd, db=db, charset=&#39;utf8&#39;, ) cur = conn.cursor() cur.execute(sql) alldata = cur.fetchall() # print(alldata) for rec in alldata: result.append(rec[0]) #注意，我这里只是把查询出来的第一列数据保存到结果中了,如果是多列的话，稍微修改下就ok了 except Exception as e: print(&#39;Error msg: &#39; + e) finally: cur.close() conn.close() return result def get_result(self, sql, filename): print(sql) results = self.select_data(sql) print(&#39;The amount of datas: %d&#39; % (len(results))) with open(filename, &#39;w&#39;) as f: for result in results: f.write(str(result) + &#39;\n&#39;) print(&#39;Data write is over!&#39;) return results if __name__ == &#39;__main__&#39;: sql = &quot;select name from user&quot; select = SelectMySQL() result1 = select.get_result(sql,&#39;namemsg.txt&#39;) print(result1) 3.import pymysql class Mysql: def __init__(self): self.content = pymysql.Connect( host=&#39;localhost&#39;, # mysql的主机ip port=3306, # 端口 user=&#39;root&#39;, # 用户名 passwd=&#39;123456&#39;, # 数据库密码 db=&#39;test&#39;, # 数据库名 charset=&#39;utf8&#39;, # 字符集 ) self.cursor = self.content.cursor() def query(self): sql = &quot;select * from chinamoney_ann_v1;&quot; self.cursor.execute(sql) for row in self.cursor.fetchall(): print(row) print(f&quot;一共查找到：{self.cursor.rowcount}&quot;) def end(self): self.cursor.close() self.content.close() if __name__ == &#39;__main__&#39;: mysql = Mysql() mysql.query() mysql.end() 案例：一整套第一步：打开数据库连接 import pymysql db = pymysql.connect(host=&quot;数据库地址&quot;, user=&quot;用户名&quot;, password=&quot;密码&quot;, port=3306,# 端口 database=&quot;数据库名&quot;, charset=&#39;utf8&#39;) 第二步：创建游标 cursor = db.cursor() 第三步：操作数据库 1、创建表 # 如果数据表已经存在使用execute()方法删除表。 cursor.execute(&quot;DROP TABLE IF EXISTS EMPLOYEE&quot;) # 创建数据表SQL语句 sql = &quot;&quot;&quot;CREATE TABLE EMPLOYEE ( FIRST_NAME CHAR(20) NOT NULL, LAST_NAME CHAR(20), AGE INT, SEX CHAR(1), INCOME FLOAT )&quot;&quot;&quot; cursor.execute(sql) 2、查询数据#Python查询Mysql使用 fetchone() 方法获取单条数据, 使用fetchall() 方法获取多条数据。fetchone(): 该收全部的返回结果行.rowcount: 这是方法获取下一个查询结果集。结果集是一个对象fetchall():接一个只读属性，并返回执行execute()方法后影响的行数。 # SQL 查询语句 sql = &quot;SELECT * FROM EMPLOYEE WHERE INCOME &gt; {}&quot;.format(1000) try: # 执行SQL语句 cursor.execute(sql) # 获取所有记录列表 results = cursor.fetchall() for row in results: fname = row[0] lname = row[1] age = row[2] sex = row[3] income = row[4] # 打印结果 print(&quot;fname={},lname={},age={},sex={},income={}&quot;.format(fname, lname, age, sex, income)) except: print(&quot;Error: unable to fecth data&quot;) 3、添加数据 # SQL 插入语句 sql = &quot;&quot;&quot;INSERT INTO EMPLOYEE(FIRST_NAME, LAST_NAME, AGE, SEX, INCOME) VALUES (&#39;Mac&#39;, &#39;Mohan&#39;, 20, &#39;M&#39;, 2000)&quot;&quot;&quot; try: cursor.execute(sql) # 提交到数据库执行 db.commit() except: # 发生错误时回滚 db.rollback() 4、修改数据 # SQL 更新语句 sql = &quot;UPDATE EMPLOYEE SET AGE = AGE + 1 WHERE SEX = &#39;{}&#39;&quot;.format(&#39;M&#39;) try: cursor.execute(sql) # 提交到数据库执行 db.commit() except: # 发生错误时回滚 db.rollback() 5、删除数据 # SQL 刪除语句 sql = &quot;DELETE FROM EMPLOYEE WHERE AGE &gt; {}&quot;.format(20) try: cursor.execute(sql) # 提交到数据库执行 db.commit() except: # 发生错误时回滚 db.rollback() 第四步：关闭游标，数据库连接 cursor.close() db.close() 通过控制台向数据库插入数据&quot;&quot;&quot; @Time : 2020/5/11 14:24 @Software: PyCharm &quot;&quot;&quot; import pymysql host = &#39;127.0.0.1&#39; port = 3306 user = &#39;root&#39; password = &#39;123456&#39; print(&#39;Starting the create database operation, please enter the information required for the database.&#39;) # print(&#39;------------------------------------&#39;) # host = input(&#39;please input database host:&#39;) # port = input(&#39;please input database port:&#39;) # user = input(&#39;please input database user:&#39;) # password = input(&#39;please input database password:&#39;) # print(&#39;------------------------------------&#39;) try: conn = pymysql.connect(host=host, port=int(port), user=user, password=password) print(&#39;create database...&#39;) cur = conn.cursor() cur.execute(&#39;create database if not exists book&#39;) print(&#39;database created done.&#39;) print(&#39;------------------------------------&#39;) conn.select_db(&#39;book&#39;) print(&#39;create user table...&#39;) cur.execute(&quot;CREATE TABLE IF NOT EXISTS user (&quot; &quot;id varchar(50) PRIMARY KEY,&quot; &quot;username varchar(255),&quot; &quot;password varchar(255),&quot; &quot;role int(11),&quot; &quot;create_time datetime,&quot; &quot;delete_flag int(11),&quot; &quot;current_login_time datetime)&quot;) print(&#39;user table created done.&#39;) print(&#39;------------------------------------&#39;) print(&#39;create book table...&#39;) cur.execute(&quot;CREATE TABLE IF NOT EXISTS book(&quot; &quot;id varchar(50) PRIMARY KEY,&quot; &quot;book_name varchar(255),&quot; &quot;author varchar(255),&quot; &quot;publish_company varchar(255),&quot; &quot;store_number int(11),&quot; &quot;borrow_number int(11),&quot; &quot;create_time datetime,&quot; &quot;publish_date datetime)&quot;) print(&#39;book table created done.&#39;) print(&#39;------------------------------------&#39;) print(&#39;create borrow_info table...&#39;) cur.execute(&quot;CREATE TABLE IF NOT EXISTS borrow_info (&quot; &quot;id varchar(50) PRIMARY KEY,&quot; &quot;book_id varchar(50),&quot; &quot;book_name varchar(255),&quot; &quot;borrow_user varchar(255),&quot; &quot;borrow_num int(11),&quot; &quot;borrow_days int(11),&quot; &quot;borrow_time datetime,&quot; &quot;return_time datetime,&quot; &quot;return_flag int(11))&quot;) print(&#39;borrow_info table created done.&#39;) print(&#39;------------------------------------&#39;) print(&#39;create ask_return table...&#39;) cur.execute(&quot;create table if not exists ask_return (&quot; &quot;id int(11) PRIMARY KEY AUTO_INCREMENT NOT NULL,&quot; &quot;user_name varchar(50) NOT NULL,&quot; &quot;borrow_id varchar(50) NOT NULL,&quot; &quot;is_read int(11) NOT NULL,&quot; &quot;time datetime)&quot;) print(&#39;ask_return table created done.&#39;) print(&#39;-&#39;*30) print(&#39;operate done.&#39;) print(&#39;create database successful.&#39;) except Exception as e: print(&#39;the require information of database is correct, please check it and retry.&#39;) print(e.args) import traceback traceback.print_exc() print(&#39;create database failed.&#39;) print(&#39;Is insert some sample data into the database?&#39;) print(&#39;1. insert&#39;) print(&#39;2. exit&#39;) insert_tag = input(&#39;please select the option:&#39;) if insert_tag == &#39;1&#39;: print(&#39;------------------------------------&#39;) print(&#39;starting the insert data operation...&#39;) admin_data = [&#39;12644064935811ea9063d8c497639e37&#39;, &#39;admin&#39;, &#39;21232f297a57a5a743894a0e4a801fc3&#39;, 0, &#39;2020-05-11 15:23:12&#39;, 0, &#39;2020-05-11 15:24:23&#39;] user_data = [&#39;99477a9e935811ea8171d8c497639e37&#39;, &#39;zhangsan&#39;, &#39;e10adc3949ba59abbe56e057f20f883e&#39;, 1, &#39;2020-05-11 15:23:12&#39;, 0, &#39;2020-05-11 15:24:23&#39;] sql = &#39;insert into user (id, username, password, role, create_time, delete_flag, current_login_time) values(%s,%s,&#39;\ &#39;%s,%s,%s,%s,%s)&#39; cur.execute(sql, admin_data) cur.execute(sql, user_data) conn.commit() cur.close() conn.close() print(&#39;insert operation done.&#39;) print(&#39;------------------------------------&#39;) print(&#39;Now you can use admin account login with username=&quot;admin&quot; password=&quot;admin&quot; or use the normal account login&#39; &#39;with username=&quot;zhangsan&quot; password=&quot;123456&quot;.&#39;) else: print(&#39;system exit.&#39;)]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python网络编程]]></title>
    <url>%2F2019%2F02%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20190228_%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[UDP 协议（User Datagram Protocol 用户数据报协议） 面向无连接，传输数据之前源端和目的端不需要建立连接 发送出去的数据不一定会接收得到 传输速率快、效率高 TCP 协议（Transmission Control Protocol传输控制协议） 面向连接，传输数据之前需要建立连接 在连接过程中进行大量的数据传输 安全可靠的传输协议 传输速度慢、效率低 TCP 与 UDP 的主要区别 1.TCP是面向连接的；UDP是无连接的 2.TCP的每个连接都是点对点的，即一对一进行；UDP的连接支持一对一，一对多，多对一以及多对多 3.TCP的传输比较安全可靠；UDP的传输则不那么可靠 4.TCP的传输比较较慢，但可以保证数据的顺序；UDP的传输速度较快，但不可保证数据的顺序 5.在对系统资源的要求上：TCP占用较多的系统资源；UDP只需少量的系统资源 ​​​ 1. udp网络程序-发送数据创建一个基于udp的网络程序，具体步骤如下： 创建客户端套接字 发送/接收数据 关闭套接字 方式1： from socket import * # 1. 创建udp套接字 udp_socket = socket(AF_INET, SOCK_DGRAM) # 2. 准备接收方的地址 # &#39;192.168.1.103&#39;表示目的ip地址 # 8080表示目的端口 dest_addr = (&#39;127.0.0.1&#39;, 6666) # 注意 是元组，ip是字符串，端口是数字 # 3. 从键盘获取数据 send_data = input(&quot;请输入要发送的数据:&quot;) # 4. 发送数据到指定的电脑上的指定程序中 udp_socket.sendto(send_data.encode(&#39;gbk&#39;), dest_addr) # 5. 关闭套接字 udp_socket.close() 方式2： import socket def main(): # 1. 创建udp套接字 udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) # 2. 准备接收方的地址 dest_addr = (&#39;127.0.0.1&#39;, 6666) # 注意 是元组，ip是字符串，端口是数字 # 3. 从键盘获取数据 send_data = input(&quot;请输入要发送的数据:&quot;) # 4. 发送数据到指定的电脑上的指定程序中 udp_socket.sendto(send_data.encode(&#39;gbk&#39;), dest_addr) # 5. 关闭套接字 udp_socket.close() if __name__ == &quot;__main__&quot;: main() 方式3：可连续发送数据 import socket def main(): # 1. 创建udp套接字 udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) while True: # 2.从键盘获取数据 send_data = input(&quot;请输入要发送的数据:&quot;) # 3. 如果用户输入exit，就退出程序 if send_data == &quot;exit&quot;: break # 4. 发送数据到指定的电脑上的指定程序中 udp_socket.sendto(send_data.encode(&#39;gbk&#39;), (&#39;127.0.0.1&#39;, 6666)) # 5. 关闭套接字 udp_socket.close() if __name__ == &quot;__main__&quot;: main() 2. udp网络程序-发送、接收数据from socket import * # 1. 创建udp套接字 udp_socket = socket(AF_INET, SOCK_DGRAM) # 2. 准备接收方的地址 dest_addr = (&#39;10.17.16.153&#39;, 8888) # 3. 从键盘获取数据 send_data = input(&quot;请输入要发送的数据:&quot;) # 4. 发送数据到指定的电脑上 udp_socket.sendto(send_data.encode(&#39;utf-8&#39;), dest_addr) # 5. 等待接收对方发送的数据 recv_data = udp_socket.recvfrom(1024) # 1024表示本次接收的最大字节数 # 6. 显示对方发送的数据 # 接收到的数据recv_data是一个元组 # 第1个元素是对方发送的数据 # 第2个元素是对方的ip和端口 print(recv_data[0].decode(&#39;gbk&#39;)) print(recv_data[1]) # 7. 关闭套接字 udp_socket.close() 牛客网案例 服务端：使用 socket 模块的 socket 函数来创建一个 socket 对象。socket 对象可以通过调用其他函数来设置一个 socket 服务。 现在我们可以通过调用 bind(hostname, port) 函数来指定服务的 port(端口)。 接着，我们调用 socket 对象的 accept 方法。该方法等待客户端的连接，并返回 connection 对象，表示已连接到客户端。 #!/usr/bin/python3 # 文件名：server.py # 导入 socket、sys 模块 import socket import sys # 创建 socket 对象 serversocket = socket.socket( socket.AF_INET, socket.SOCK_STREAM) # 获取本地主机名 host = socket.gethostname() port = 9999 # 绑定端口号 serversocket.bind((host, port)) # 设置最大连接数，超过后排队 serversocket.listen(5) while True: # 建立客户端连接 clientsocket,addr = serversocket.accept() print(&quot;连接地址: %s&quot; % str(addr)) msg=&#39;欢迎访问牛客教程！&#39;+ &quot;\r\n&quot; clientsocket.send(msg.encode(&#39;utf-8&#39;)) clientsocket.close() 客户端： 接下来我们写一个简单的客户端实例连接到以上创建的服务。端口号为 9999。 socket.connect(hosname, port ) 方法打开一个 TCP 连接到主机为 hostname 端口为 port 的服务商。连接后我们就可以从服务端获取数据，记住，操作完成后需要关闭连接。 #!/usr/bin/python3 # 文件名：client.py # 导入 socket、sys 模块 import socket import sys # 创建 socket 对象 s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # 获取本地主机名 host = socket.gethostname() # 设置端口号 port = 9999 # 连接服务，指定主机和端口 s.connect((host, port)) # 接收小于 1024 字节的数据 msg = s.recv(1024) s.close() print (msg.decode(&#39;utf-8&#39;))]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python文件操作]]></title>
    <url>%2F2019%2F02%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20190226_%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[常用文件： IGNORED_EXTENSIONS = [ # 图片 &#39;mng&#39;, &#39;pct&#39;, &#39;bmp&#39;, &#39;gif&#39;, &#39;jpg&#39;, &#39;jpeg&#39;, &#39;png&#39;, &#39;pst&#39;, &#39;psp&#39;, &#39;tif&#39;, &#39;tiff&#39;, &#39;ai&#39;, &#39;drw&#39;, &#39;dxf&#39;, &#39;eps&#39;, &#39;ps&#39;, &#39;svg&#39;, # 音频 &#39;mp3&#39;, &#39;wma&#39;, &#39;ogg&#39;, &#39;wav&#39;, &#39;ra&#39;, &#39;aac&#39;, &#39;mid&#39;, &#39;au&#39;, &#39;aiff&#39;, # 视频 &#39;3gp&#39;, &#39;asf&#39;, &#39;asx&#39;, &#39;avi&#39;, &#39;mov&#39;, &#39;mp4&#39;, &#39;mpg&#39;, &#39;qt&#39;, &#39;rm&#39;, &#39;swf&#39;, &#39;wmv&#39;, &#39;m4a&#39;, &#39;m4v&#39;, &#39;flv&#39;, # 办公软件 &#39;xls&#39;, &#39;xlsx&#39;, &#39;ppt&#39;, &#39;pptx&#39;, &#39;pps&#39;, &#39;doc&#39;, &#39;docx&#39;, &#39;odt&#39;, &#39;ods&#39;, &#39;odg&#39;, &#39;odp&#39;, # 其它 &#39;css&#39;, &#39;pdf&#39;, &#39;exe&#39;, &#39;bin&#39;, &#39;rss&#39;, &#39;zip&#39;, &#39;rar&#39;, ] 文件的打开与关闭在python，使用: open(文件名，访问模式) 函数，可以打开一个已经存在的文件，或者创建一个新文件 访问模式 说明 r 以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。 w 打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a 打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 rb 以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。 wb 以二进制格式打开一个文件只用于写入。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 ab 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。 r+ 打开一个文件用于读写。文件指针将会放在文件的开头。 w+ 打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 a+ 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 rb+ 以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。 wb+ 以二进制格式打开一个文件用于读写。如果该文件已存在则将其覆盖。如果该文件不存在，创建新文件。 ab+ 以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。 文件的重命名和删除os模块中的rename()可以完成对文件的重命名操作：rename(需要修改的文件名, 新的文件名) import os os.rename(&quot;test.py&quot;, &quot;test1.py&quot;) os模块中的remove()可以完成对文件的删除操作: remove(待删除的文件名) import os os.remove(&quot;毕业论文.txt&quot;) 文件夹的相关操作import os # 1. 创建文件夹 os.mkdir(&quot;张三&quot;) # 2. 获取当前目录 os.getcwd() # 3. 改变默认目录 os.chdir(&quot;../&quot;) # 4. 获取目录列表 os.listdir(&quot;./&quot;) # 5. 删除文件夹 os.rmdir(&quot;张三&quot;) Python3 OS 文件/目录方法：os 模块提供了非常丰富的方法用来处理文件和目录。常用的方法如下表所示： os.access(path, mode) ：检验权限模式os.chdir(path)：改变当前工作目录os.chflags(path, flags)：设置路径的标记为数字标记。os.chmod(path, mode)：更改权限os.chown(path, uid, gid)：更改文件所有者os.chroot(path)：改变当前进程的根目录os.close(fd)：关闭文件描述符 fdos.closerange(fd_low, fd_high)：关闭所有文件描述符，从 fd_low (包含) 到 fd_high (不包含), 错误会忽略os.dup(fd)：复制文件描述符 fdos.dup2(fd, fd2)：将一个文件描述符 fd 复制到另一个 fd2os.fchdir(fd)：通过文件描述符改变当前工作目录os.fchmod(fd, mode)：改变一个文件的访问权限，该文件由参数fd指定，参数mode是Unix下的文件访问权限。os.fchown(fd, uid, gid)：修改一个文件的所有权，这个函数修改一个文件的用户ID和用户组ID，该文件由文件描述符fd指定。os.fdatasync(fd)：强制将文件写入磁盘，该文件由文件描述符fd指定，但是不强制更新文件的状态信息。os.fdopen(fd[, mode[, bufsize]])：通过文件描述符 fd 创建一个文件对象，并返回这个文件对象os.fpathconf(fd, name)：返回一个打开的文件的系统配置信息。name为检索的系统配置的值，它也许是一个定义系统值的字符串，这些名字在很多标准中指定（POSIX.1, Unix 95, Unix 98, 和其它）。os.fstat(fd)：返回文件描述符fd的状态，像stat()。os.fstatvfs(fd)：返回包含文件描述符fd的文件的文件系统的信息，像 statvfs()os.fsync(fd)：强制将文件描述符为fd的文件写入硬盘。os.ftruncate(fd, length)：裁剪文件描述符fd对应的文件, 所以它最大不能超过文件大小。os.getcwd()：返回当前工作目录os.getcwdu()：返回一个当前工作目录的Unicode对象os.isatty(fd)：如果文件描述符fd是打开的，同时与tty(-like)设备相连，则返回true, 否则False。os.lchflags(path, flags)：设置路径的标记为数字标记，类似 chflags()，但是没有软链接os.lchmod(path, mode)：修改连接文件权限os.lchown(path, uid, gid)：更改文件所有者，类似 chown，但是不追踪链接。os.link(src, dst)：创建硬链接，名为参数 dst，指向参数 srcos.listdir(path)：返回path指定的文件夹包含的文件或文件夹的名字的列表。os.lseek(fd, pos, how)：设置文件描述符 fd当前位置为pos, how方式修改: SEEK_SET 或者 0 设置从文件开始的计算的pos; SEEK_CUR或者 1 则从当前位置计算; os.SEEK_END或者2则从文件尾部开始. 在unix，Windows中有效os.lstat(path)：像stat(),但是没有软链接os.major(device)：从原始的设备号中提取设备major号码 (使用stat中的st_dev或者st_rdev field)。os.makedev(major, minor)：以major和minor设备号组成一个原始设备号os.makedirs(path[, mode])：递归文件夹创建函数。像mkdir(), 但创建的所有intermediate-level文件夹需要包含子文件夹。os.minor(device)：从原始的设备号中提取设备minor号码 (使用stat中的st_dev或者st_rdev field )。os.mkdir(path[, mode])：以数字mode的mode创建一个名为path的文件夹.默认的 mode 是 0777 (八进制)。os.mkfifo(path[, mode])：创建命名管道，mode 为数字，默认为 0666 (八进制)os.mknod(filename[, mode=0600, device])：创建一个名为filename文件系统节点（文件，设备特别文件或者命名pipe）。os.open(file, flags[, mode])：打开一个文件，并且设置需要的打开选项，mode参数是可选的os.openpty()：打开一个新的伪终端对。返回 pty 和 tty的文件描述符。os.pathconf(path, name)：返回相关文件的系统配置信息。os.pipe()：创建一个管道. 返回一对文件描述符(r, w) 分别为读和写os.popen(command[, mode[, bufsize]])：从一个 command 打开一个管道os.read(fd, n)：从文件描述符 fd 中读取最多 n 个字节，返回包含读取字节的字符串，文件描述符 fd对应文件已达到结尾, 返回一个空字符串。os.readlink(path)：返回软链接所指向的文件os.remove(path)：删除路径为path的文件。如果path 是一个文件夹，将抛出OSError; 查看下面的rmdir()：删除一个 directory。os.removedirs(path)：递归删除目录。os.rename(src, dst)：重命名文件或目录，从 src 到 dstos.renames(old, new)：递归地对目录进行更名，也可以对文件进行更名。os.rmdir(path)：删除path指定的空目录，如果目录非空，则抛出一个OSError异常。os.stat(path)：获取path指定的路径的信息，功能等同于C API中的stat()系统调用。os.stat_float_times([newvalue])：决定stat_result是否以float对象显示时间戳os.statvfs(path)：获取指定路径的文件系统统计信息os.symlink(src, dst)：创建一个软链接os.tcgetpgrp(fd)：返回与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组os.tcsetpgrp(fd, pg)：设置与终端fd（一个由os.open()返回的打开的文件描述符）关联的进程组为pg。os.tempnam([dir[, prefix]])：返回唯一的路径名用于创建临时文件。os.tmpfile()：返回一个打开的模式为(w+b)的文件对象 .这文件对象没有文件夹入口，没有文件描述符，将会自动删除。os.tmpnam()：为创建一个临时文件返回一个唯一的路径os.ttyname(fd)：返回一个字符串，它表示与文件描述符fd 关联的终端设备。如果fd 没有与终端设备关联，则引发一个异常。os.unlink(path)：删除文件路径os.utime(path, times)：返回指定的path文件的访问和修改的时间。os.walk(top[, topdown=True[, onerror=None[, followlinks=False]]])：输出在文件夹中的文件名通过在树中游走，向上或者向下。os.write(fd, str)：写入字符串到文件描述符 fd中. 返回实际写入的字符串长度 3. 案例1、用python处理文本数据，并删除处理之后的数据 # 根据条件把一个文本分成两个文本 # with open(r&#39;list_object.txt&#39;, &#39;r&#39;) as file: # lines = file.readlines() # for key_word in lines: # if key_word.startswith(&#39;files/cninfo_category_daily_update/&#39;): # with open(r&#39;zs_stock.txt&#39;, &#39;a&#39;, encoding=&#39;utf-8&#39;) as file: # file.write(key_word) # else: # with open(r&#39;zs_bond.txt&#39;, &#39;a&#39;, encoding=&#39;utf-8&#39;) as file: # file.write(key_word) # 处理文本数据，并删除处理之后的数据 kafka_list = [] with open(r&#39;files/zs_stock.txt&#39;, encoding=&#39;utf-8&#39;) as file: lines = file.readlines() print(&#39;读取文本行数：&#39;, len(lines)) for num in lines[0:5]: kafka_list.append(num) lines.remove(num) print(&#39;kafka_list:&#39;, kafka_list) with open(r&#39;files/zs_stock.txt&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f: print(&#39;删除已传送jds路径之后文本行数：&#39;, len(lines)) for i in lines: f.write(i) 2、输入文件的名字，然后程序自动完成对文件进行备份 # coding=utf-8 oldFileName = input(&quot;请输入要拷贝的文件名字:&quot;) with open(oldFileName, &#39;r&#39;, encoding=&#39;utf-8&#39;) as oldFile: # 如果打开文件 if oldFile: # 提取文件的后缀 fileFlagNum = oldFileName.rfind(&#39;.&#39;) if fileFlagNum &gt; 0: fileFlag = oldFileName[fileFlagNum:] # 组织新的文件名字 newFileName = oldFileName[:fileFlagNum] + &#39;[复件]&#39; + fileFlag # 创建新文件 with open(newFileName, &#39;w&#39;, encoding=&#39;utf-8&#39;) as newFile: # 把旧文件中的数据，一行一行的进行复制到新文件中 for lineContent in oldFile.readlines(): newFile.write(lineContent) 3、批量在文件名前加前缀 # coding=utf-8 import os funFlag = 1 # 1表示添加标志 2表示删除标志 folderName = &#39;./test_fo/&#39; # 获取指定路径的所有文件名字 dirList = os.listdir(folderName) # 遍历输出所有文件名字 for name in dirList: print(name) if funFlag == 1: # 增加前缀 newName = &#39;[东哥出品]-&#39; + name elif funFlag == 2: # 去除前缀 num = len(&#39;[东哥出品]-&#39;) newName = name[num:] print(newName) os.rename(folderName + name, folderName + newName)]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python进程和线程]]></title>
    <url>%2F2019%2F02%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20190225_%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[操作系统会为每一个进程分配独立的内存空间，的那这样会占用独立的资源，对系统的开销较大。一般情况下我们可以使用多线程来完成多任务的开发，一个进程中包含了多个线程，对系统的开销较小一个进程中至少有一个线程，默认的这个线程我们叫做主线程。 单线程模拟人脑： import time # 敲键盘ing def keyboard(): for i in range(5): print(&quot;敲键盘ing...&quot;) time.sleep(0.5) # 点鼠标ing def mouse(): for i in range(5): print(&quot;点鼠标ing...&quot;) time.sleep(1) if __name__ == &#39;__main__&#39;: keyboard() mouse() 多线程： import threading import time # 敲键盘ing def keyboard(): for i in range(5): print(&quot;敲键盘ing...&quot;) time.sleep(0.5) # 点鼠标ing def mouse(): for i in range(5): print(&quot;点鼠标ing...&quot;) time.sleep(1) if __name__ == &#39;__main__&#39;: # 为了方便，我们使用两个线程分别执行 keyboard和 mouse任务 print(&quot;开辟前，当前有%s个线程在活动,他们是%s&quot; % (threading.active_count(), threading.enumerate())) keyboard_thread = threading.Thread(target=keyboard) mouse_thread = threading.Thread(target=mouse) print(&quot;开辟后，当前有%s个线程在活动,他们是%s&quot; % (threading.active_count(), threading.enumerate())) keyboard_thread.start() mouse_thread.start() print(&quot;start后，当前有%s个线程在活动,他们是%s&quot; % (threading.active_count(), threading.enumerate())) time.sleep(2) # 使用完毕 print(&quot;play over&quot;) ========================================（wiki陶喵） 坑no. 1 类成员变量加锁保护在并发程序中，一个重要的需要注意的点是程序的可重入性 https://blog.csdn.net/vincent040/article/details/50978979以下以一个例子来介绍。 # encoding : utf-8 from flask import Flask import threading lock = threading.Lock() app = Flask(__name__) class my_model(): def __init__(self): self.weights = 1 self.mid_data = 0 def predict(self,input_data): self.mid_data = 0 for i in range(1000): i+1 for i in range(1000000): self.mid_data += (self.weights + input_data) for i in range(1000): i+1 result = self.mid_data return result m = my_model() @app.route(&quot;/zero&quot;,methods=[&quot;GET&quot;]) def zero(): res = m.predict(0) return str(res) @app.route(&quot;/one&quot;,methods=[&quot;GET&quot;]) def one(): res = m.predict(1) return str(res) if __name__==&quot;__main__&quot;: app.run( host = &quot;0.0.0.0&quot;, port = 9865 ) 如上，这个程序看似没有什么问题。在连续访问下，能得到正确结果，但是当出现高并发的访问的时候，程序的结果就不可预知了。 (torch36) zhujinyi@gpuserver010:/data/nfs/wrk-4.1.0$ wrk -t 4 -c 128 -d 60s -s test_m2.lua http://localhost:9865/one Running 1m test @ http://localhost:9865/one 4 threads and 128 connections 953822 3185088 2847474 2940568 713724 3103776 2987122 3380356 105864 3818912 148244 1301280 1555600 1495616 4196668 686306 4317080 729890 909054 这种情况下，常用的解决办法是加锁保护共享数据，界定临界区。 # encoding : utf-8 from flask import Flask import threading lock = threading.Lock() app = Flask(__name__) class my_model(): def __init__(self): self.weights = 1 self.mid_data = 0 def predict(self,input_data): lock.acquire() self.mid_data = 0 for i in range(1000): i+1 for i in range(1000000): self.mid_data += (self.weights + input_data) for i in range(1000): i+1 result = self.mid_data lock.release() return result m = my_model() @app.route(&quot;/zero&quot;,methods=[&quot;GET&quot;]) def zero(): res = m.predict(0) return str(res) @app.route(&quot;/one&quot;,methods=[&quot;GET&quot;]) def one(): res = m.predict(1) return str(res) if __name__==&quot;__main__&quot;: app.run( host = &quot;0.0.0.0&quot;, port = 9865 ) 这样可以得到正确的结果。 (torch36) zhujinyi@gpuserver010:/data/nfs/wrk-4.1.0$ wrk -t 4 -c 128 -d 60s -s test_m2.lua http://localhost:9865/one Running 1m test @ http://localhost:9865/one 4 threads and 128 connections 2000000 2000000 2000000 2000000 2000000 2000000 2000000 2000000 2000000 2000000 2000000 2000000 2000000 2000000 2000000 2000000 当然，大粒度的锁会严重影响程序的性能，不推荐把锁加到函数级别，另一种可以得到正确结果的方案是用更多的空间。 class my_model(): def __init__(self): self.weights = 1 self.mid_data = 0 def predict(self,input_data): tmp_data = 0 for i in range(1000): i+1 for i in range(1000000): tmp_data += (self.weights + input_data) for i in range(1000): i+1 result = tmp_data return result 这样写也可以得到正确结果。 同时起5个进程import time import random from multiprocessing import Process def task(num): print(f&#39;hello: {num}&#39;) time.sleep(1) def works(func, tasknum): proc_record = [] for i in range(tasknum): p = Process(target=func, args=(i,)) p.start() proc_record.append(p) for p in proc_record: p.join() if __name__ == &#39;__main__&#39;: tasknum = 5 works(task, tasknum)]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python正则表达式]]></title>
    <url>%2F2019%2F02%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20190223_python%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[import re mystr=&quot;&quot;&quot;&lt;span class=\&quot;search_yx_tj\&quot;&gt; 共&lt;em&gt;5830&lt;/em&gt;个职位满足条件 &lt;/span&gt;&quot;&quot;&quot; restr = &quot;&lt;em&gt;(\\d+)&lt;/em&gt;&quot; # 正则表达式，（）只要括号内的数据 regex = re.compile(restr, re.IGNORECASE) mylist = regex.findall(mystr) print(mylist) # [&#39;5830&#39;] print(mylist[0]) # 5830 python正则案例 import re m = re.match(r&#39;(\w+) (\w+)(?P&lt;sign&gt;.*)&#39;, &#39;hello world!&#39;) print(m) print(&quot;@@@@@@@@m.string:&quot;, m.string) print(&quot;m.re:&quot;, m.re) print(&quot;m.pos:&quot;, m.pos) print(&quot;m.endpos:&quot;, m.endpos) print(&quot;m.lastindex:&quot;, m.lastindex) print(&quot;m.lastgroup:&quot;, m.lastgroup) print(&quot;m.group(1,2):&quot;, m.group(1, 2)) print(&quot;m.groups():&quot;, m.groups()) print(&quot;m.groupdict():&quot;, m.groupdict()) print(&quot;m.start(2):&quot;, m.start(2)) print(&quot;m.end(2):&quot;, m.end(2)) print(&quot;m.span(2):&quot;, m.span(2)) print(r&quot;m.expand(r&#39;\2 \1\3&#39;):&quot;, m.expand(r&#39;\2 \1\3&#39;)) p = re.compile(r&#39;(\w+) (\w+)(?P&lt;sign&gt;.*)&#39;, re.DOTALL) print(&quot;--------p.pattern:&quot;, p.pattern) print(&quot;p.flags:&quot;, p.flags) print(&quot;p.groups:&quot;, p.groups) print(&quot;p.groupindex:&quot;, p.groupindex) line = &quot;Cats are smarter than dogs&quot; matchObj = re.match(r&#39;(.*) are (.*?) .*&#39;, line, re.M | re.I).group(2) print(matchObj) inputStr = &quot;hello crifan, nihao crifan&quot;; replacedStr = re.sub(r&quot;hello (\w+), nihao \1&quot;, &quot;crifanli&quot;, inputStr) print(&quot;%%%%%%%%%%replacedStr=&quot;, replacedStr) # crifanli 执行结果如下： &lt;_sre.SRE_Match object; span=(0, 12), match=&#39;hello world!&#39;&gt; @@@@@@@@m.string: hello world! m.re: re.compile(&#39;(\\w+) (\\w+)(?P&lt;sign&gt;.*)&#39;) m.pos: 0 m.endpos: 12 m.lastindex: 3 m.lastgroup: sign m.group(1,2): (&#39;hello&#39;, &#39;world&#39;) m.groups(): (&#39;hello&#39;, &#39;world&#39;, &#39;!&#39;) m.groupdict(): {&#39;sign&#39;: &#39;!&#39;} m.start(2): 6 m.end(2): 11 m.span(2): (6, 11) m.expand(r&#39;\2 \1\3&#39;): world hello! --------p.pattern: (\w+) (\w+)(?P&lt;sign&gt;.*) p.flags: 48 p.groups: 3 p.groupindex: {&#39;sign&#39;: 3} smarter %%%%%%%%%%replacedStr= crifanli 正则表达式之数字： 数字：^[0-9]*$ n位的数字：^\d{n}$ 至少n位的数字：^\d{n,}$ m-n位的数字：^\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(\-)?\d+(\.\d{1,2})?$ 正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\d*$ 或 ^([1-9][0-9]*){1,3}$ 或 ^\+?[1-9][0-9]*$ 非零的负整数：^\-[1-9][]0-9&quot;*$ 或 ^-[1-9]\d*$ 非负整数：^\d+$ 或 ^[1-9]\d*|0$ 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$ 非负浮点数：^\d+(\.\d+)?$ 或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$ 非正浮点数：^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$ 正浮点数：^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$ 或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 负浮点数：^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$ 或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 浮点数：^(-?\d+)(\.\d+)?$ 或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$ 正则表达式在线生成工具: https://www.w3cschool.cn/tools/index?name=create_reg 常见正则表达式一、校验数字的表达式 数字：^[0-9]*$ n位的数字：^\d{n}$ 至少n位的数字：^\d{n,}$ m-n位的数字：^\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(-)?\d+(.\d{1,2})?$ 正数、负数、和小数：^(-|+)?\d+(.\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\d$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]*$ 非零的负整数：^-[1-9][]0-9″$ 或 ^-[1-9]\d$ 非负整数：^\d+$ 或 ^[1-9]\d*|0$ 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$ 非负浮点数：^\d+(.\d+)?$ 或 ^[1-9]\d.\d|0.\d[1-9]\d|0?.0+|0$ 非正浮点数：^((-\d+(.\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\d.\d|0.\d[1-9]\d))|0?.0+|0$ 正浮点数：^[1-9]\d.\d|0.\d[1-9]\d$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ 负浮点数：^-([1-9]\d.\d|0.\d[1-9]\d)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ 浮点数：^(-?\d+)(.\d+)?$ 或 ^-?([1-9]\d.\d|0.\d[1-9]\d|0?.0+|0)$ 二、校验字符的表达式 汉字：^[\u4e00-\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$ 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&amp;’,;=?$\”等字符：[^%&amp;&#39;,;=?$\x22]+ 禁止输入含有~的字符：[^~\x22]+ 三、特殊需求表达式 Email地址：^\w+([-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\s] 或 ^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=])?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^($$\d{3,4}-)|\d{3.4}-)?\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7} 身份证号(15位、18位数字)：^\d{15}|\d{18}$ 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\d{4}-\d{1,2}-\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 有四种钱的表示形式我们可以接受:”10000.00″ 和 “10,000.00″, 和没有 “分” 的 “10000″ 和 “10,000″：^[1-9][0-9]*$ 这表示任意一个不以0开头的数字，但是，这也意味着一个字符”0″不通过，所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉，因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 必须说明的是，小数点后面至少应该有1位数，所以”10.”是不通过的，但是 “10″ 和 “10.2″ 是通过的：^[0-9]+(.[0-9]{2})?$ 这样我们规定小数点后面必须有两位，如果你认为太苛刻了，可以这样：^[0-9]+(.[0-9]{1,2})?$ 这样就允许用户只写一位小数。下面我们该考虑数字中的逗号了，我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1到3个数字，后面跟着任意个 逗号+3个数字，逗号成为可选，而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了，别忘了”+”可以用”*”替代。如果你觉得空字符串也可以接受的话(奇怪，为什么?)最后，别忘了在用函数时去掉去掉那个反斜杠，一般的错误都在这里 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\u4e00-\u9fa5] 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\n\s*\r (可以用来删除空白行) HTML标记的正则表达式：&lt;(\S?)[^&gt;]&gt;.?|&lt;.? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 首尾空白字符的正则表达式：^\s|\s$或(^\s)|(\s$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字) IP地址：\d+.\d+.\d+.\d+ (提取IP地址时有用) IP地址：((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d?\d)) re.sub#!/usr/bin/python3 import re phone = &quot;2004-959-559 # 这是一个电话号码&quot; # 删除注释 num = re.sub(r&#39;#.*$&#39;, &quot;&quot;, phone) print (&quot;电话号码 : &quot;, num) # 移除非数字的内容 num = re.sub(r&#39;\D&#39;, &quot;&quot;, phone) print (&quot;电话号码 : &quot;, num)]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python时间处理汇总]]></title>
    <url>%2F2019%2F02%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20190222_%E6%97%B6%E9%97%B4%E5%A4%84%E7%90%86%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[1. datetimedatetime是Python处理日期和时间的标准库。 datetime表示的时间需要时区信息才能确定一个特定的时间，否则只能视为本地时间。 如果要存储datetime，最佳方法是将其转换为timestamp再存储，因为timestamp的值与时区完全无关。 from datetime import datetime, timedelta, timezone # 1. 获取当前日期和时间和指定日期和时间 now = datetime.now() # 获取当前datetime print(now, type(now)) dt = datetime(2019, 4, 19, 12, 20) # 用指定日期时间创建datetime print(dt) # 2. datetime转换为timestamp dt_stamp = dt.timestamp() print(dt_stamp) # timestamp转换为datetime print(datetime.fromtimestamp(dt_stamp)) print(datetime.utcfromtimestamp(dt_stamp)) # UTC时间 # 3. str转换为datetime cday = datetime.strptime(&#39;2019-6-1 18:19:59&#39;, &#39;%Y-%m-%d %H:%M:%S&#39;) print(cday) # datetime转换为str print(now.strftime(&#39;%a, %b %d %H:%M&#39;)) # 4. datetime加减 ten_hour = now + timedelta(hours=2) print(ten_hour) print(now - timedelta(days=1)) print(now + timedelta(days=2, hours=12)) # 5. 本地时间转换为UTC时间 # 北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间 tz_utc_8 = timezone(timedelta(hours=8)) # 创建时区UTC+8:00 dt = now.replace(tzinfo=tz_utc_8) # 强制设置为UTC+8:00 print(dt) # 6. 时区转换 # 可以先通过utcnow()拿到当前的UTC时间，再转换为任意时区的时间： utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc) print(utc_dt) # astimezone()将转换时区为北京时间: bj_dt = utc_dt.astimezone(timezone(timedelta(hours=8))) print(bj_dt) import datetime for i in range(1095, 1, -1): # start_date = &#39;{:%Y-%m-%d}&#39;.format(datetime.date.today() - datetime.timedelta(days=i)) end_date = &#39;{:%Y-%m-%d}&#39;.format(datetime.date.today() - datetime.timedelta(days=i-1)) duration = &#39;{} ~ {}&#39;.format(start_date, end_date) print(start_date) print(end_date) print(duration) date1 = datetime.datetime(2012, 3, 1, 00, 00, 00) timestamp = time.mktime(date1.timetuple()) print(&#39;格式化的时间转成时间戳：&#39;, timestamp) 练习假设你获取了用户输入的日期和时间如2015-1-21 9:01:30，以及一个时区信息如UTC+5:00，均是str，请编写一个函数将其转换为timestamp： import re from datetime import datetime, timezone, timedelta def to_timestamp(dt_str, tz_str): t = datetime.strptime(dt_str, &#39;%Y-%m-%d %H:%M:%S&#39;) tz = re.match(r&#39;\w{3}([\+\-]\d{1,2})\:\d{2}&#39;, tz_str).group(1) tz = int(tz) t_utc = t.replace(tzinfo=timezone(timedelta(hours=tz))) print(t_utc.timestamp()) return t_utc.timestamp() t1 = to_timestamp(&#39;2015-6-1 08:10:30&#39;, &#39;UTC+7:00&#39;) assert t1 == 1433121030.0, t1 t2 = to_timestamp(&#39;2015-5-31 16:10:30&#39;, &#39;UTC-09:00&#39;) assert t2 == 1433121030.0, t2 print(&#39;ok&#39;) ========================== 案例1：打印昨天的时间： # 引入 datetime 模块 import datetime def getYesterday(): today = datetime.date.today() oneday = datetime.timedelta(days=1) yesterday = today - oneday return yesterday # 输出 print(getYesterday()) # 2019-07-22 案例2：格式化时间 import time # 格式化成2019-07-23 11:45:39形式 print(time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, time.localtime())) # 格式化成Sat Mar 28 22:24:24 2016形式 print(time.strftime(&quot;%a %b %d %H:%M:%S %Y&quot;, time.localtime())) # 将格式字符串转换为时间戳 a = &quot;Sat Mar 28 22:24:24 2019&quot; print(time.mktime(time.strptime(a, &quot;%a %b %d %H:%M:%S %Y&quot;))) 执行结果如下图： 案例3：输出某月的日历 import calendar cal = calendar.month(2019, 7) print(&quot;以下输出2016年1月份的日历:&quot;) print(cal) 执行结果如下图： 案例4：将字符串的时间转换为时间戳 import time a1 = &quot;2019-5-10 23:40:00&quot; # 先转换为时间数组 timeArray = time.strptime(a1, &quot;%Y-%m-%d %H:%M:%S&quot;) # 转换为时间戳 timeStamp = int(time.mktime(timeArray)) print(timeStamp) # 格式转换 - 转为 / a2 = &quot;2019-5-10 23:40:00&quot; # 先转换为时间数组,然后转换为其他格式 timeArray = time.strptime(a2, &quot;%Y-%m-%d %H:%M:%S&quot;) otherStyleTime = time.strftime(&quot;%Y/%m/%d %H:%M:%S&quot;, timeArray) print(otherStyleTime) 执行结果如下图: 案例5：获取几天前的时间 import time import datetime # 先获得时间数组格式的日期 threeDayAgo = (datetime.datetime.now() - datetime.timedelta(days=3)) # 转换为时间戳 timeStamp = int(time.mktime(threeDayAgo.timetuple())) # 转换为其他字符串格式 otherStyleTime = threeDayAgo.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) print(otherStyleTime) 执行结果如下图： 案例6：将时间戳转换为指定日期 import time # 获得当前时间时间戳 now = int(time.time()) #转换为其他日期格式,如:&quot;%Y-%m-%d %H:%M:%S&quot; timeArray = time.localtime(now) otherStyleTime = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, timeArray) print(otherStyleTime) 执行结果如下图： import datetime # 获得当前时间 now = datetime.datetime.now() # 转换为指定的格式 otherStyleTime = now.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) print(otherStyleTime) 执行结果如下图： 指定时间戳： import time timeStamp = 1556502800 timeArray = time.localtime(timeStamp) otherStyleTime = time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;, timeArray) print(otherStyleTime) import datetime timeStamp = 1557802800 dateArray = datetime.datetime.utcfromtimestamp(timeStamp) otherStyleTime = dateArray.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) print(otherStyleTime)]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python模块和包以及各种库]]></title>
    <url>%2F2019%2F02%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20190221_%E6%A8%A1%E5%9D%97%E5%92%8C%E5%8C%85%E4%BB%A5%E5%8F%8A%E5%90%84%E7%A7%8D%E5%BA%93%2F</url>
    <content type="text"><![CDATA[模块(Module)：是一个 Python 文件，以 .py 结尾，包含了 Python 对象定义和Python语句。 如果一个文件中有all变量，那么也就意味着这个变量中的元素，不会被from xxx import *时导入 模块让你能够有逻辑地组织你的 Python 代码段。把相关的代码分配到一个模块里能让你的代码更好用，更易懂。模块能定义函数，类和变量，模块里也能包含可执行的代码。包括：内置模块，自定义模块，第三方模块；import 导入文件都做了哪些事？ 以源文件为准产生一个名称空间以刚刚产生的名称空间为准，执行源文件的代码会在当前文件中定义一个名字，这个名字就是模块名，用来引用模块中的名字模块的搜索路径：模块的查找顺序是：内存中已经加载的模块-&gt;内置模块（系统内置那些）-&gt;sys.path路径中包含的模块 1.安装的方式找到模块的压缩包解压进入文件夹执行命令： python setup.py install注意：如果在install的时候，执行目录安装，可以使用：python setup.py install --prefix=安装路径2.模块的引入在程序中，使用from import 即可完成对安装的模块使用 from 模块名 import 模块名或者* 包：包就是一个包含有init.py文件的文件夹。包的导入和导入模块类似，形式：import 包名，只不过想要使用包中的工具，则需要在包的 init 文件下导入此包的模块。 __init__.py控制着包的导入行为 init 的作用：将此包下的模块进行导入，在其他地方调用这个包时，以便访问使用这个包的方法。 安装python模块已存在，可以指定安装的目录进行安装： pip install --target=d:\program\python\python37\lib\site-packages\twisted _win32stdio]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python面向对象编程]]></title>
    <url>%2F2019%2F02%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20190220_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[概念：面向对象(object-oriented ;简称: OO) 至今还没有统一的概念 我这里把它定义为: 按人们 认识客观世界的系统思维方式,采用基于对象(实体) 的概念建立模型,模拟客观世界分析、设 计、实现软件的办法。 面向对象编程(Object Oriented Programming-OOP) 是一种解决软件复用的设计和编程方法。 这种方法把软件系统中相近相似的操作逻辑和操作 应用数据、状态,以类的型式描述出来,以对象实例的形式在软件系统中复用,以达到提高软件开发效率的作用。 类(Class): 是一对相同特征或行为的事物的一个统称，是抽象的，不能直接使用它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。属性：对象具有的特征（有什么），用来描述数据；方法：对象具有的行为（能做什么），用来描述数据相关的操作；作用：类相当于制造飞机的图纸，是一个模板，是负责创建对象的，它来进行创建的飞机就相当于对象；类的抽象：拥有相同(或者类似)属性和行为的对象都可以抽像出一个类 对象：是由类创建出来的一个具体存在，可以直接使用。一个类创建出来的对象 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。局部变量：定义在方法中的变量，只作用于当前实例的类。实例变量：在类的声明中，属性是用变量来表示的。这种变量就称为实例变量，是在类声明的内部但是在类的其他成员方法之外声明的。继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。实例化：创建一个类的实例，类的具体对象。对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。案例：面向对象_扑克牌发牌程序 （Python经典编程案例） 接口： # coding=utf-8 from zope.interface import Interface from zope.interface.declarations import implementer # 定义接口 class MyMiss(Interface): def imissyouatlost(self, miss): &quot;&quot;&quot;Say i miss you at lost to miss&quot;&quot;&quot; @implementer(MyMiss) # 继承接口 class Miss: def imissyouatlost(self, somebody): &quot;&quot;&quot;Say i miss you at lost to somebody&quot;&quot;&quot; return &quot;i miss you at lost, {}!&quot;.format(somebody) if __name__ == &#39;__main__&#39;: z = Miss() hi = z.imissyouatlost(&#39;Zhangsan&#39;) print(hi) 对象： BMW = Car()，这样就产生了一个Car的实例对象，此时也可以通过实例对象BMW来访问属性或者方法; 第一次使用BMW.color = ‘黑色’表示给BMW这个对象添加属性，如果后面再次出现BMW.color = xxx表示对属性进行修改; BMW是一个对象，它拥有属性（数据）和方法（函数）; 当创建一个对象时，就是用一个模子，来制造一个实物 init方法 init()方法，在创建一个对象时默认被调用，不需要手动调用init(self)中，默认有1个参数名字为self，如果在创建对象时传递了2个实参，那么init(self)中出了self作为第一个形参外还需要2个形参，例如init(self,x,y)init(self)中的self参数，不需要开发者传递，python解释器会自动把当前的对象引用传递进去 “魔法”方法 在python中方法名如果是xxxx()的，那么就有特殊的功能，因此叫做“魔法”方法； 当使用print输出对象的时候，只要自己定义了str(self)方法，那么就会打印从在这个方法中return的数据 self所谓的self，可以理解为自己可以把self当做C++中类里面的this指针一样理解，就是对象自身的意思某个对象调用其方法时，python解释器会把这个对象作为第一个参数传递给self，所以开发者只需要传递后面的参数即可 保护对象属性：如果有一个对象，当需要对其进行修改属性时，有2种方法： 对象名.属性名 = 数据 —-&gt;直接修改 对象名.方法名() —-&gt;间接修改 为了更好的保存属性安全，即不能随意修改，一般的处理方式为： 将属性定义为私有属性 添加一个可以调用的方法，供调用 Python中没有像C++中public和private这些关键字来区别公有属性和私有属性它是以属性命名方式来区分，如果在属性名前面加了2个下划线’__’，则表明该属性是私有属性，否则为公有属性（方法也是一样，方法名前面加了2个下划线的话表示该方法是私有的，否则为公有的）。 __del__()方法创建对象后，python解释器默认调用init()方法； 当删除一个对象时，python解释器也会默认调用一个方法，这个方法为del()方法 继承子类在继承的时候，在定义类时，小括号()中为父类的名字父类的属性、方法，会被继承给子类 多态多态的概念是应用于Java和C#这一类强类型语言中，而Python崇尚“鸭子类型”。所谓多态：定义时的类型和运行时的类型不一样，此时就成为多态 new和init的作用new至少要有一个参数cls，代表要实例化的类，此参数在实例化时由Python解释器自动提供 new必须要有返回值，返回实例化出来的实例，这点在自己实现new时要特别注意，可以return父类new出来的实例，或者直接是object的new出来的实例 init有一个参数self，就是这个new返回的实例，init在new的基础上可以完成一些其它初始化的动作，init不需要返回值 我们可以将类比作制造商，new方法就是前期的原材料购买环节，init方法就是在有原材料的基础上，加工，初始化商品环节 继承# -*- encoding: utf-8 -*- class people: # 定义基本属性 name = &#39;&#39; age = 0 # 定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 # 定义构造方法 def __init__(self, n, a, w): self.name = n self.age = a self.__weight = w def speak(self): print(&quot;%s 说: 我 %d 岁。&quot; % (self.name, self.age)) # 单继承示例 class student(people): grade = &#39;&#39; def __init__(self, n, a, w, g): # 调用父类的构函 people.__init__(self, n, a, w) self.grade = g # 覆写父类的方法 def speak(self): print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot; % (self.name, self.age, self.grade)) s = student(&#39;ken&#39;, 10, 60, 3) s.speak() 多重继承 #!/usr/bin/python3 class people: # 定义基本属性 name = &#39;&#39; age = 0 # 定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 # 定义构造方法 def __init__(self, n, a, w): self.name = n self.age = a self.__weight = w def speak(self): print(&quot;%s 说: 我 %d 岁。&quot; % (self.name, self.age)) # 单继承示例 class student(people): grade = &#39;&#39; def __init__(self, n, a, w, g): # 调用父类的构函 people.__init__(self, n, a, w) self.grade = g # 覆写父类的方法 def speak(self): print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot; % (self.name, self.age, self.grade)) # 另一个类，多重继承之前的准备 class speaker(): topic = &#39;&#39; name = &#39;&#39; def __init__(self, n, t): self.name = n self.topic = t def speak(self): print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot; % (self.name, self.topic)) # 多重继承 class sample(speaker, student): a = &#39;&#39; def __init__(self, n, a, w, g, t): student.__init__(self, n, a, w, g) speaker.__init__(self, n, t) test = sample(&quot;Tim&quot;, 25, 80, 4, &quot;Python&quot;) test.speak() # 方法名同，默认调用的是在括号中排前地父类的方法 方法重写 #!/usr/bin/python3 class Parent: # 定义父类 def myMethod(self): print(&#39;调用父类方法&#39;) class Child(Parent): # 定义子类 def myMethod(self): print(&#39;调用子类方法&#39;) c = Child() # 子类实例 c.myMethod() # 子类调用重写方法 super(Child, c).myMethod() # 用子类对象调用父类已被覆盖的方法]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python错误，测试和调试]]></title>
    <url>%2F2019%2F02%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20190219_%E9%94%99%E8%AF%AF%2C%E6%B5%8B%E8%AF%95%E5%92%8C%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[try语句处理异常，是这样做的： 首选，try子语句（try和except关键字之间的语句）会被执行。 如果没有异常发生，except 子句被略过。 如果有异常发生，try后面的其他语句就被跳过了，如果异常类型在except关键字后匹配，这个except子句被执行。 如果没有异常发生，else子句就会被执行。else的作用是它避免了捕获未保护的代码所发起的异常。 finally子语会在try子句执行完毕之前执行，不管是否发生或者不发生异常。当一个异常发生在try子句中却未被处理时（或者发生在except或者else子句中时），finally子句执行完后会再次抛出异常。 实战：编写“角色扮演”游戏import random # 自定义异常类 class MuchError(Exception): pass class Victory(Exception): pass # 定义玩家与角色 player = [&#39;小黄&#39;, &#39;小黑&#39;, &#39;小白&#39;, &#39;小红&#39;] role = [&#39;女巫&#39;, &#39;猎人&#39;, &#39;狼人&#39;, &#39;村民&#39;, &#39;守卫&#39;, &#39;长老&#39;, &#39;预言家&#39;, &#39;白狼王&#39;] # 将玩家与角色的顺序打乱并匹配 player = random.sample(player, len(player)) role = random.sample(role, len(player)) print(&#39;游戏中全部身份有：&#39; + &#39;、&#39;.join(role)) matching = {} for t in range(len(player)): matching[player[t]] = role[t] # 游戏逻辑 try: result, err = 0, 0 for t in player: for i in range(2): guess = input(&#39;你认为&#39; + t + &#39;的身份是：&#39;) if guess == matching[t]: result += 1 print(&#39;你猜对了&#39;) break else: err += 1 print(&#39;猜错了，你还有&#39;+ str(1-i) + &#39;次机会&#39;) if err &gt; 5: raise MuchError(&#39;错误次数已超出5次，游戏结束&#39;) if result == len(player): raise Victory(&#39;恭喜你，全部猜对了&#39;) except MuchError as errInfo: print(errInfo)]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数式编程]]></title>
    <url>%2F2019%2F02%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20190218_%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[一. 函数式编程介绍函数是Python内建支持的一种封装，我们通过把大段代码拆成函数，通过一层一层的函数调用，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。 而函数式编程（请注意多了一个“式”字）——Functional Programming，虽然也可以归结到面向过程的程序设计，但其思想更接近数学计算。 我们首先要搞明白计算机（Computer）和计算（Compute）的概念。 在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。 而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。 函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量。 函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！ Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。 二. 高阶函数高阶函数英文叫Higher-order function。把函数作为参数传入，这样的函数称为高阶函数，函数式编程就是指这种高度抽象的编程范式。 # 1. 变量可以指向函数 # 结论：函数本身也可以赋值给变量，即：变量可以指向函数。 print(abs(-10)) # 10 print(abs) # &lt;built-in function abs&gt; f = abs print(f) # &lt;built-in function abs&gt; # 说明变量f现在已经指向了abs函数本身。直接调用abs()函数和调用变量f()完全相同。 print(f(-10)) # 10 # 2. 函数名也是变量 # 由于abs函数实际上是定义在import builtins模块中的， # 所以要让修改abs变量的指向在其它模块也生效(修改内置函数)，要用import builtins; builtins.abs = 10 # 3. 传入函数 # 既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。 def add(x, y, f): return f(x) + f(y) print(add(-5, 6, abs)) 1. map和reducemap()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。 # 比如我们有一个函数f(x)=x2，要把这个函数作用在一个list [1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map()实现如下： def f(x): return x * x r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9]) print(list(r)) # [1, 4, 9, 16, 25, 36, 49, 64, 81] list1 = list(map(str, [1, 2, 3, 4, 5, 6, 7, 8, 9])) print(list1) # [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;] # reduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数， # reduce把结果继续和序列的下一个元素做累积计算 from functools import reduce # 如果要把序列[1, 3, 5, 7, 9]变换成整数13579，reduce就可以派上用场： def add(x, y): return x * 10 + y r1 = reduce(add, [1, 3, 5, 7, 9]) print(&#39;reduce:---&#39;, r1) # 13579 练习： # 练习1：利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。 # 输入：[&#39;adam&#39;, &#39;LISA&#39;, &#39;barT&#39;]，输出：[&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;]： def normalize(name): # 第一种方式 # return name.capitalize() # 第二种方式 # if not isinstance(name, str): # raise TypeError(&#39;***参数不是字符串***&#39;) # name1 = name[0].upper() # name的首字母大写（这里输出只有首字母） # name2 = name[1:].lower() # name的除首字母以后全部小写（输出只有除首字母的部分） # name = name1 + name2 # 所以要连起来重新赋值给name # return name # 第三种方式 if not isinstance(name, str): raise TypeError(&#39;name input is not a string&#39;) return name[0].upper() + name[1:].lower() L1 = [&#39;adam&#39;, &#39;LISA&#39;, &#39;barT&#39;] L2 = list(map(normalize, L1)) print(L2) # 练习2：Python提供的sum()函数可以接受一个list并求和，请编写一个prod()函数，可以接受一个list并利用reduce()求积： from functools import reduce def prod(L): return reduce(lambda x, y: x*y, L) print(&#39;3 * 5 * 7 * 9 =&#39;, prod([3, 5, 7, 9])) if prod([3, 5, 7, 9]) == 945: print(&#39;测试成功!&#39;) else: print(&#39;测试失败!&#39;) # 练习3：利用map和reduce编写一个str2float函数，把字符串&#39;123.456&#39;转换成浮点数123.456： from functools import reduce def str2float(s): from functools import reduce # 调用reduce函数 DIGITS = {&#39;0&#39;: 0, &#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, &#39;4&#39;: 4, &#39;5&#39;: 5, &#39;6&#39;: 6, &#39;7&#39;: 7, &#39;8&#39;: 8, &#39;9&#39;: 9} def char2num(s): # 定义把数字字符元素转为数字元素的函数 return DIGITS[s] i = s.find(&#39;.&#39;) # 找到&#39;.&#39;所在的索引位 L1 = reduce(lambda x, y: x * 10 + y, map(char2num, s[:i])) # 取&#39;.&#39;之前的元素计算 L2 = reduce(lambda x, y: x / 10 + y, map(char2num, s[:i:-1])) / 10 # 取&#39;.&#39;之后的元素计算 return L1 + L2 print(&#39;str2float(\&#39;123.456\&#39;) =&#39;, str2float(&#39;123.456&#39;)) if abs(str2float(&#39;123.456&#39;) - 123.456) &lt; 0.00001: print(&#39;测试成功!&#39;) else: print(&#39;测试失败!&#39;) 2. filterPython内建的filter()函数用于过滤序列。和map()类似，filter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。由于filter()使用了惰性计算，所以只有在取filter()结果的时候，才会真正筛选并每次返回下一个筛出的元素。 # 例如，在一个list中，删掉偶数，只保留奇数，可以这么写： def is_odd(n): return n % 2 == 1 is_odd_test = list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15])) print(is_odd_test) # 结果: [1, 5, 9, 15] # 注意到filter()函数返回的是一个Iterator，也就是一个惰性序列，所以要强迫filter()完成计算结果，需要用list()函数获得所有结果并返回list。 # 打印1000以内的素数: def _odd_iter(): # 这是一个生成器，并且是一个无限序列 n = 1 while True: n = n + 2 yield n def _not_divisible(n): return lambda x: x % n &gt; 0 def primes(): yield 2 it = _odd_iter() # 初始序列 while True: n = next(it) # 返回序列的第一个数 yield n it = filter(_not_divisible(n), it) # 构造新序列 for n in primes(): if n &lt; 1000: print(n) else: break 3. sortedsorted()也是一个高阶函数。用sorted()排序的关键在于实现一个映射函数。 # Python内置的sorted()函数就可以对list进行排序： print(sorted([36, 5, -12, 9, -21])) # [-21, -12, 5, 9, 36] # sorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，例如按绝对值大小排序： print(sorted([36, 5, -12, 9, -21], key=abs)) # [5, 9, -12, -21, 36] # 默认情况下，对字符串排序，是按照ASCII的大小比较的，由于&#39;Z&#39; &lt; &#39;a&#39;，结果，大写字母Z会排在小写字母a的前面。 print(sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;])) # [&#39;Credit&#39;, &#39;Zoo&#39;, &#39;about&#39;, &#39;bob&#39;] # 忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。 print(sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key=str.lower)) # [&#39;about&#39;, &#39;bob&#39;, &#39;Credit&#39;, &#39;Zoo&#39;] # 要进行反向排序，不必改动key函数，可以传入第三个参数reverse=True： print(sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key=str.lower, reverse=True)) # [&#39;Zoo&#39;, &#39;Credit&#39;, &#39;bob&#39;, &#39;about&#39;] 二. 返回函数函数作为返回值：一个函数可以返回一个计算结果，也可以返回一个函数。返回一个函数时，牢记该函数并未执行，返回函数中不要引用任何可能会变化的变量。 返回闭包时牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。 def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fs f1, f2, f3 = count() print(f1(), f1) # 9 &lt;function count.&lt;locals&gt;.f at 0x000001CCF2376840&gt; print(f2(), f2) # 9 &lt;function count.&lt;locals&gt;.f at 0x000001CCF23768C8&gt; print(f3(), f3) # 9 &lt;function count.&lt;locals&gt;.f at 0x000001CCF2376950&gt; def count1(): def f(j): def g(): return j*j return g fs = [] for i in range(1, 4): fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f() return fs f11, f22, f33 = count1() print(f11(), f11) # 1 &lt;function count1.&lt;locals&gt;.f.&lt;locals&gt;.g at 0x000001CCF2376AE8&gt; print(f22(), f22) # 4 &lt;function count1.&lt;locals&gt;.f.&lt;locals&gt;.g at 0x000001CCF2376B70&gt; print(f33(), f33) # 9 &lt;function count1.&lt;locals&gt;.f.&lt;locals&gt;.g at 0x000001CCF2376BF8&gt; 三. 匿名函数Python对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数。 # 匿名函数lambda x: x * x实际上就是：def f(x): return x * x list1 = list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9])) print(list1) # [1, 4, 9, 16, 25, 36, 49, 64, 81] # 同样，也可以把匿名函数作为返回值返回，比如： def build(x, y): return lambda: x * x + y * y print(build(2, 3)) 四. 装饰器在面向对象（OOP）的设计模式中，decorator被称为装饰模式。在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。OOP的装饰模式需要通过继承和组合来实现，而Python除了能支持OOP的decorator外，直接从语法层次支持decorator。Python的decorator可以用函数实现，也可以用类实现。decorator可以增强函数的功能，定义起来虽然有点复杂，但使用起来非常灵活和方便。 # 本质上，decorator就是一个返回函数的高阶函数。所以，我们要定义一个能打印日志的decorator，可以定义如下： def log(func): def wrapper(*args, **kw): print(&#39;call %s():&#39; % func.__name__) return func(*args, **kw) return wrapper @log def now(): print(&#39;2015-3-25&#39;) now() import functools def log(text): &quot;&quot;&quot;不需要编写wrapper.__name__ = func.__name__这样的代码，Python内置的functools.wraps就是干这个事的，所以，一个完整的decorator的写法如下：&quot;&quot;&quot; def decorator(func): @functools.wraps(func) def wrapper(*args, **kw): print(&#39;%s %s():&#39; % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator @log(&#39;execute&#39;) def now(): print(&#39;2015-3-25&#39;) now() 五. 偏函数]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数及其高级特性]]></title>
    <url>%2F2019%2F02%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20190217_%E5%87%BD%E6%95%B0%E5%8F%8A%E5%85%B6%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[函数：把具有独立功能的代码块组织一个小模块，在需要的时候调用返回值：就是程序中函数完成一件事情后，最后给调用者的结果 全局变量：在函数外边定义的变量，全局变量能够在所有的函数中进行访问；如果在函数中修改全局变量，那么就需要使用global进行声明，否则出错；如果全局变量的名字和局部变量的名字相同，那么使用的是局部变量的，小技巧强龙不压地头蛇对于不可变类型的全局变量来说，因其指向的数据不能修改，所以不使用global时无法修改全局变量。对于可变类型的全局变量来说，因其指向的数据可以修改，所以不使用global时也可修改全局变量。 定义函数时，需要确定函数名和参数个数； 如果有必要，可以先对参数的数据类型做检查； 函数体内部可以用return随时返回函数结果； 函数执行完毕也没有return语句时，自动return None; 函数可以同时返回多个值，但其实就是一个tuple。 浅拷贝 copy(): 不拷贝子对象的内容，只拷贝子对象的引用；深拷贝 deepcopy(): 会连子对象的内存也全部拷贝一份，对子对象的修改不会影响原对象。 LEGB规则：python查找名称时，查找顺序：local -&gt; enclosed -&gt; global -&gt; built in local: （局部）函数或者类的方法内部； enclosed: （闭包）嵌套函数，在闭包作用域进行搜索，装饰器就是一种闭包； global: （全局）模块中的全局变量； build in : 内建命名空间，python为自己保留的特殊名称。 Lambda函数：是一种比较小的匿名函数规则：只允许包含一个表达式，计算结果就是函数的返回值 x = lambda a, b: a*b print(x(3, 6)) y = lambda c: c*4 print(y(6)) 参数处理定义时小括号中的参数，用来接收参数用的，称为 “形参”调用时小括号中的参数，用来传递给函数用的，称为 “实参” 在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。 默认参数：要牢记一点：默认参数必须指向不变对象！ def enroll(name, gender, age=6, city=&#39;Beijing&#39;): &quot;&quot;&quot;可以把年龄和城市设为默认参数&quot;&quot;&quot; print(&#39;name:&#39;, name) print(&#39;gender:&#39;, gender) print(&#39;age:&#39;, age) print(&#39;city:&#39;, city) enroll(&#39;Sarah&#39;, &#39;F&#39;) # 默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！ # 如果默认参数指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。 # 这时可以用None这个不变对象来实现无论调用多少次，都不会有问题： def add_end(L=None): if L is None: L = [] L.append(&#39;END&#39;) return L 可变参数： # 如计算计算a^2 + b^2 + c^2 + ……。 def calc(*numbers): sum = 0 for n in numbers: sum = sum + n * n return sum print(calc(1, 2)) # Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去 nums = [1, 2, 3] print(calc(*nums)) # 这种写法相当有用，而且很常见。 关键字参数：至于到底传入了哪些，就需要在函数内部通过kw检查，如：if &#39;city&#39; in kw: def person(name, age, **kw): &quot;&quot;&quot;kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra&quot;&quot;&quot; print(&#39;name:&#39;, name, &#39;age:&#39;, age, &#39;other:&#39;, kw) # 在调用该函数时，可以只传入必选参数： person(&#39;Michael&#39;, 30) # 可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去 extra = {&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;} person(&#39;Jack&#39;, 24, city=extra[&#39;city&#39;], job=extra[&#39;job&#39;]) # 当然，上面复杂的调用可以用简化的写法： person(&#39;Jack&#39;, 24, **extra) 命名关键字参数：是为了限制调用者可以传入的参数名，同时可以提供默认值。 # 命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。 # 缺少 *，city和job被视为位置参数 def person1(name, age, *, city, job): print(name, age, city, job) # 命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错 person1(&#39;Jack&#39;, 24, city=&#39;Beijing&#39;, job=&#39;Engineer&#39;) # 如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了： def person2(name, age, *args, city, job): print(name, age, args, city, job) # 由于命名关键字参数city具有默认值，调用时，可不传入city参数： def person3(name, age, *, city=&#39;Beijing&#39;, job): print(name, age, city, job) person3(&#39;Jack&#39;, 24, job=&#39;Engineer&#39;) 参数检查： def my_abs(x): # 数据类型检查可以用内置函数isinstance()实现： if not isinstance(x, (int, float)): raise TypeError(&#39;bad operand type&#39;) if x &gt;= 0: return x else: return -x print(my_abs(5)) 递归函数递归函数：自己调用自己的函数；包含两个部分：①终止条件；②递归步骤。处理大数据时慎用，因为会创建大量函数对象，过量的消耗内存和运算能力。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。 使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。 举个例子，我们来计算阶乘n! = 1 x 2 x 3 x … x n，用函数fact(n)表示，可以看出：fact(n) = n! = 1 x 2 x 3 x ... x (n-1) x n = (n-1)! x n = fact(n-1) x n。所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。 def fact(n): if n==1: return 1 return n * fact(n - 1) fact(5) 使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试fact(1000)。 解决递归调用栈溢出的方法是通过尾递归优化(通过尾递归防止栈溢出)，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。 def fact(n): return fact_iter(n, 1) def fact_iter(num, product): if num == 1: return product return fact_iter(num - 1, num * product) fact_iter(5, 1) fact_iter(4, 5) 尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。 函数高级特性函数高级特性：切片，迭代，生成器，迭代器 切片：有了切片操作，很多地方循环就不再需要了。Python的切片非常灵活，一行代码就可以实现很多行循环才能完成的操作。 L = [&#39;Michael&#39;, &#39;Sarah&#39;, &#39;Tracy&#39;, &#39;Bob&#39;, &#39;Jack&#39;] # L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素 print(L[0:3]) # Python支持L[-1]取倒数第一个元素，同样支持倒数切片,倒数第一个元素的索引是-1 print(L[-2:]) print(L[-2:-1]) L1 = list(range(30)) # 前10个数，每两个取一个： print(L1[:10:2]) # [0, 2, 4, 6, 8] # 所有数，每5个取一个： print(L1[::5]) # [0, 5, 10, 15, 20, 25] 迭代：迭代（Iteration）：如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。 只要是可迭代对象，无论有无下标，都可以迭代 生成器: 如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator generator是非常强大的工具，在Python中，可以简单地把列表生成式改成generator，也可以通过函数实现复杂逻辑的generator。 # 第一种：创建生成器的方法很简单，只要把一个列表生成式的[]改成() L = [x * x for x in range(10)] print(L) # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81] g = (x * x for x in range(10)) print(g) # &lt;generator object &lt;genexpr&gt; at 0x1022546d0&gt; for n in g: print(n) # 斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到 def fib(max): n, a, b = 0, 0, 1 while n &lt; max: print(b) a, b = b, a + b n = n + 1 return &#39;done&#39; # 第二种：如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator： # 变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。 def fib1(max): n, a, b = 0, 0, 1 while n &lt; max: yield b # 只需要把print(b)改为yield b就可以了 a, b = b, a + b n = n + 1 return &#39;done&#39; print(fib1(6)) 迭代器：我们已经知道，可以直接作用于for循环的数据类型有以下几种： 一类是集合数据类型，如list、tuple、dict、set、str等； 一类是generator，包括生成器和带yield的generator function; 这些可以直接作用于for循环的对象统称为可迭代对象：Iterable; 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator 集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象 # 可以使用isinstance()判断一个对象是否是Iterable对象： from collections.abc import Iterable print(isinstance([], Iterable)) # True print(isinstance({}, Iterable)) # True print(isinstance((x for x in range(10)), Iterable)) # True # 可以使用isinstance()判断一个对象是否是Iterator对象： from collections.abc import Iterator print(isinstance((x for x in range(10)), Iterator)) # True print(isinstance([], Iterator)) # False print(isinstance({}, Iterator)) # False print(isinstance(&#39;abc&#39;, Iterator)) # False # 生成器都是Iterator对象，但list、dict、str虽然是Iterable，却不是Iterator。 # 把list、dict、str等Iterable变成Iterator可以使用iter()函数： print(isinstance(iter([]), Iterator)) # True print(isinstance(iter(&#39;abc&#39;), Iterator)) # True]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python控制语句]]></title>
    <url>%2F2019%2F02%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20190216_%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[控制语句 注意：代码的缩进格式很重要 建议4个空格来控制根据逻辑值（True，Flase）判断程序的运行方向Ture：表示非空的量（String，tuple元组 、list、set、dictonary），所有非零的数字，False：0，None 、空的量逻辑表达式 可以包含 逻辑运算符 and or not break的作用是提前结束循环;continue的作用是提前结束本轮循环，并直接开始下一轮循环 条件控制if: # 只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False if x: print(&#39;True&#39;) 循环语句Python中的循环语句有 for 和 while。]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python序列（列表，元组，字典，集合）]]></title>
    <url>%2F2019%2F02%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20190215_%E5%BA%8F%E5%88%97%EF%BC%88%E5%88%97%E8%A1%A8%EF%BC%8C%E5%85%83%E7%BB%84%EF%BC%8C%E5%AD%97%E5%85%B8%EF%BC%8C%E9%9B%86%E5%90%88%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在python中，每个变量使用前都必须赋值，变量赋值之后才会被创建。序列：一块用来存放多个值的连续内存空间。作用：进行数据存储操作。遍历时，索引位置和对应值可以用enumerate()函数同时得到。常用的序列结构有：字符串，列表，元组，字典，集合。 序列解包：可用于元组，列表，字典，让我们方便地对多个变量赋值，如：x, y, z = (20, 30, 10) 1. 列表列表：用于存储任意数目，任意类型的数据集合，有序，元素可变。格式：a = [12, 20, ‘abc’, True]特点： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。 常用方法： list.append(x) :增加元素到尾部 list.extend(aList) :将aList中的元素加到list尾部 list.insert(index, x) :在index处插入元素x list.remove(x) : 删除首次出现的x，x不存在会报错，应先用in检查是否存在。 list.pop(i)：删除指定位置的元素，i是索引位置；不传参数默认删除最后一个； list.clear(): 清空列表 list.index(x): 获取x的索引，不存在则抛异常 list.count(x): 计数 list.reverse(): 反转 list.sort(): 排序（升序）， list.sort(reverse=True)降序排序 list.copy(): 浅拷贝 返回某项是否是列表中的元素：‘y’ in list_x 1.1 列表的创建和删除 # 1. 使用赋值运算符直接创建列表 list_name = [7, &#39;优雅&#39;, &#39;Python&#39;, &#39;Web&#39;] # 2. 创建空列表 empty_list = [] # 3. 创建数值列表 data = list(range(10, 20, 2)) print(data) # 输出：[10, 12, 14, 16, 18] # 4. 删除列表用del,删之前得确保列表名称是已经存在的，要不然会报错 del list_name 1.2 访问列表元素 # 访问第三个元素：Python list_name = [7, &#39;优雅&#39;, &#39;Python&#39;, &#39;Web&#39;] print(list_name[2]) # 程序输出：Python # 当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，记得最后一个元素的索引是len(classmates) - 1。 print(list_name[len(list_name) - 1]) # 程序输出：Web 1.3 遍历列表 # 1. 直接使用for循环实现 list_name = [&#39;18&#39;, &#39;优雅&#39;, &#39;Python&#39;, &#39;Web&#39;] for item in list_name: print(item + &quot;\t\t&quot;, end=&#39;&#39;) # 程序不换行输出每一项 # 2. 使用for循环和enumerate()函数实现 for index, item in enumerate(list_name): print(index+1, item) # 换行输出：1 18 2 优雅 3 Python 4 Web 1.4 添加，修改和删除列表元素 list_name.insert(1, &#39;Jack&#39;) # 把元素插入到指定的位置，比如索引号为1的位置 list_name[1] = &#39;Sarah&#39; # 把某个元素替换成别的元素，可以直接赋值给对应的索引位置 列表生成式：列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。 # for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方： d1 = [x * x for x in range(1, 11) if x % 2 == 0] print(d1) # [4, 16, 36, 64, 100] # 还可以使用两层循环，可以生成全排列： d2 = [m + n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;] print(d2) # [&#39;AX&#39;, &#39;AY&#39;, &#39;AZ&#39;, &#39;BX&#39;, &#39;BY&#39;, &#39;BZ&#39;, &#39;CX&#39;, &#39;CY&#39;, &#39;CZ&#39;] # 列出当前目录下的所有文件和目录名，可以通过一行代码实现： import os d3 = [d for d in os.listdir(&#39;.&#39;)] # os.listdir可以列出文件和目录 print(d3) # 列表生成式也可以使用两个变量来生成list： dict = {&#39;x&#39;: &#39;A&#39;, &#39;y&#39;: &#39;B&#39;, &#39;z&#39;: &#39;C&#39;} d4 = [k + &#39;=&#39; + v for k, v in dict.items()] print(d4) # [&#39;x=A&#39;, &#39;y=B&#39;, &#39;z=C&#39;] # 把一个list中所有的字符串变成小写： L = [&#39;Hello&#39;, &#39;World&#39;, &#39;IBM&#39;, &#39;Apple&#39;] d5 = [s.lower() for s in L] print(d5) # [&#39;hello&#39;, &#39;world&#39;, &#39;ibm&#39;, &#39;apple&#39;] # 带if else d6 = [x if x % 2 == 0 else -x for x in range(1, 11)] print(d6) # [-1, 2, -3, 4, -5, 6, -7, 8, -9, 10] 2. 元组元组：与列表类似，不同之处在于元组的元素不能修改，用于存储一串信息。特点：元组的访问和处理速度比列表快，是不可变序列。 tuple的陷阱：当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来。 # 只有1个元素的tuple定义时必须加一个逗号, t = (1,) # 看一个“可变的”tuple： # tuple所谓的“不变”是说，tuple的每个元素，指向永远不变，但指向的这个list本身是可变的 t = (&#39;a&#39;, &#39;b&#39;, [&#39;A&#39;, &#39;B&#39;]) t[2][0] = &#39;X&#39; t[2][1] = &#39;Y&#39; # 可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素 print(t[-1]) 3. 字典字典：是键值对的无序可变序列，作用：可以存储多个数据，通常用于存储描述一个物体相关的信息。dict是用空间来换取时间的一种方法。 dict的key必须是不可变对象，通过key计算位置的算法称为哈希算法（Hash）。要保证hash的正确性，作为key的对象就不能变。 用in检测键是否在字典中；python3.5及以前的版本中，keys方法返回列表中的键是无序的。 特点： 查找和插入的速度极快，不会随着key的增加而变慢； 需要占用大量的内存，内存浪费多。 方法： dict.clear() dict.copy(): 返回一个字典的浅复制 dict.fromkeys([“name”, “age”, “job”]) : 创建值为空的字典； dict.get(): 取值（推荐），键不存在，可自定义默认值，第二个参数； dict.items(): 所有（key, value）元组列表； dict.keys(): 以列表返回字典所有键； dict.pot(key): 删除指定键值对， key不存在会报错； dict.popitem(): 随机删除一个键值对； dict.setdefault(key, value): key不存在新建，存在则不修改； dict.update(dict2): 把dict2中的键值更新到dict里； dict.values(): 以列表返回字典中的所有值 d = {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85} b1 = dict(name=&#39;zhang&#39;, age=&#39;18&#39;) print(b1) # {&#39;name&#39;: &#39;zhang&#39;, &#39;age&#39;: &#39;18&#39;} b2 = dict([(&#39;name&#39;, &#39;zhang&#39;), (&#39;age&#39;, 19)]) print(b2) # {&#39;name&#39;: &#39;zhang&#39;, &#39;age&#39;: 19} # 通过zip创建 k3 = [&#39;name&#39;, &#39;age&#39;] v3 = [&#39;zhang&#39;, &#39;19&#39;] b3 = dict(zip(k3, v3)) print(b3) # {&#39;name&#39;: &#39;zhang&#39;, &#39;age&#39;: &#39;19&#39;} # 取数据 a = d[&#39;Michael&#39;] # 把数据放入dict的方法，除了初始化时指定外，还可以通过key放入 d[&#39;Adam&#39;] = 67 # 要避免key不存在的错误，有两种办法，一是通过in判断key是否存在 if &#39;Michael&#39; in d: print(d[&#39;Michael&#39;]) # 二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value： print(d.get(&#39;Thomas&#39;)) print(d.get(&#39;Bob&#39;, 11)) # 取不到数据时会返回11 # 要删除一个key，用pop(key)方法，对应的value也会从dict中删除 d.pop(&#39;Tracy&#39;) 遍历字典： 默认情况下，dict迭代的是key（for key in d）。 如果要迭代value，可以用for value in d.values()， 如果要同时迭代key和value，可以用for k, v in d.items()。 如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断： # -*- coding: utf-8 -*- # 弃用警告：从collections中导入ABCs已被弃用，并在python3.8中将停止工作，可使用collections.abc代替它进行使用 from collections.abc import Iterable print(isinstance(&#39;abc&#39;, Iterable)) # str是否可迭代 print(isinstance([1, 2, 3], Iterable)) # list是否可迭代 print(isinstance(123, Iterable)) # 整数是否可迭代 # 如果要对list实现类似Java那样的下标循环怎么办？ # Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身： for i, value in enumerate([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]): print(i, value) # 面的for循环里，同时引用了两个变量，在Python里是很常见的，比如下面的代码： for x, y in [(1, 1), (2, 4), (3, 9)]: print(x, y) 字典的核心底层原理：字典的核心是散列表，散列表是一个稀疏数组，数组的每个单元叫bucket;每个bucket有2个部分，一个是键对象的引用，一个是值对象的引用；所有bucket结构和大小一致，可通过偏移量来读取指定bucket。扩容：创造更大的数组，把原有的内容拷贝到新数组中；python会根据散列表的拥挤程度扩容，接近2/3时，数组就会扩容。 4. 集合特点：无序可变，元素不能重复，底层是字典的实现，集合中所有的元素都是字典的键，所以不能重复。 方法： set(): 将列表，元组等可迭代对象转成集合； remove(): 删除指定元素； clear(): 清除整个集合； # 要创建一个set，需要提供一个list作为输入集合： s = set([1, 2, 3]) # 通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果： s.add(4) # 通过remove(key)方法可以删除元素： s.remove(4) # set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作： s1 = set([1, 2, 3]) s2 = set([2, 3, 4]) # s1, s2 = {1, 3, &#39;zha&#39;}, {&#39;he&#39;, 3, &#39;it&#39;} print(s1 &amp; s2, s1.intersection(s2)) # {2, 3} ， 交集 print(s1 | s2, s1.union(s2)) # {1, 2, 3, 4}， 并集 print(s1 - s2, s1.difference(s2)) # {1}, 差集 print(s1 ^ s2) # a和b不同时存在的元素 不可变集合：frozenset是不可变，可散列的 x = set([1, 2, 3, 1, 3, 5]) y = frozenset(x) print(y) # frozenset({1, 2, 3, 5}) 5. 公共方法运算符： 运算符 Python 表达式 结果 描述 支持的数据类型 + [1, 2] + [3, 4] [1, 2, 3, 4] 合并 字符串、列表、元组 * ‘Hi!’ * 4 [‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’] 复制 字符串、列表、元组 in 3 in (1, 2, 3) True 元素是否存在 字符串、列表、元组、字典 not in 4 not in (1, 2, 3) True 元素是否不存在 字符串、列表、元组、字典 内置函数： cmp(item1, item2)：比较两个值len(item)：计算容器中元素个数max(item)：返回容器中元素最大值min(item)：返回容器中元素最小值del(item)：删除变量 6. 案例1、用列表和字典存储表信息，并打印出表中工资高于 15000 的数据 r1 = dict(name=&quot;高小一&quot;, age=18, salary=30000, city=&quot;北京&quot;) r2 = dict(name=&quot;高小二&quot;, age=19, salary=20000, city=&quot;上海&quot;) r3 = dict(name=&quot;高小三&quot;, age=20, salary=10000, city=&quot;深圳&quot;) tb = [r1, r2, r3] for x in tb: if x.get(&quot;salary&quot;) &gt; 15000: print(x)]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python字符串和编码]]></title>
    <url>%2F2019%2F02%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20190214_python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[相互转换：将数值转换成字符串，可以使用str()和repr()函数 字符串1、判断类型：（9个） s.isspace(): 如果字符串只包含空格字符，则返回true，否则返回false。 s.isalnum(): 如果字符串至少包含1个字符，并且所有字符均为数字，则返回true，否则返回false。 s.isalpha(): 如果字符串至少包含1个字符，并且所有字符均为字母，则返回true，否则返回false。 s.isdigit(): 如果字符串只包含数字则返回true，否则返回false。 s.isnumeric(): 如果unicode字符串只包含数字字符，则返回true，否则返回false。 s.istitle(): 如果字符串正确“标题大小写”，则返回true，否则返回false。 s.isupper(): 如果字符串至少包含一个可变大小写字符，并且所有可变大小写字符均为大写，则返回true，否则返回false。 s.islower(): 如果字符串至少包含1个字母，并且所有字符均为小写，则返回true，否则返回false。 s.isdecimal() : 如果unicode字符串只包含十进制字符，则返回true，否则返回false。 2、查找和替换：（7个） s.startswith(str, beg=0,end=len(string)): 确定字符串或字符串的子字符串(如果给定起始索引beg和结束索引end)以str开头; 如果是则返回true，否则返回false。 s.endswith(suffix, beg = 0, end = len(string)): 确定字符串或字符串的子字符串(如果启动索引结束和结束索引结束)都以后缀结尾; 如果是则返回true，否则返回false。 s.find(str, beg = 0 end = len(string)): 如果索引beg和结束索引end给定，则确定str是否在字符串或字符串的子字符串中，如果找到则返回索引，否则为-1。 s.rfind(): 从右边查找。 s.index(str, beg = 0, end = len(string)): 与find()相同，但如果没有找到str，则引发异常。 s.rindex( str, beg = 0, end = len(string)): 与index()相同，但在字符串中向后搜索。 s.replace(old, new [, max]): 如果给定max值，则用new或最多最大出现替换字符串中所有出现的旧字符(old)。 3、大小写转换：（5个） s.capitalize()：把字符串的第一个字母转为大写; s.title(): 返回字符串的标题版本，即所有单词第一个字母都以大写开头，其余的都是小写的。 s.upper(): 将字符串中的小写字母转换为大写。 s.lower(): 将字符串中的所有大写字母转换为小写。 s.swapcase(): 反转在字符串中的所有字母大小写，即小写转大写，大写转小写。 4、文本对齐：（3个） s.center(width, fillchar)：返回使用fillchar填充的字符串，原始字符串以总共width列为中心。 s.ljust(width[, fillchar]): 返回一个空格填充的字符串，原始字符串左对齐到总共width列。 s.rjust(width,[, fillchar]): 返回一个空格填充字符串，原始字符串右对齐到总共宽度(width)列。 5、去除空白字符：（3个） s.strip([chars]): 对字符串执行lstrip()和rstrip() s.lstrip(): 删除字符串中的所有前导空格 s.rstrip(): 删除字符串的所有尾随空格。 6、拆分和连接：（5个） s.join(seq): m将序列seq中的元素以字符串表示合并(并入)到具有分隔符字符串的字符串中。 s.split(str=: 根据分隔符str(空格，如果没有提供)拆分字符串并返回子字符串列表; 如果给定，最多分割为num子串。 s.splitlines( num=string.count(‘\n’)))”): 全部拆分字符串(或num)新行符，并返回每行的列表，并删除新行符。 7、其它 s.count(str, beg = 0,end = len(string))：计算字符串中出现有多少次str或字符串的子字符串(如果开始索引beg和结束索引end,则在beg~end范围匹配)。 s.decode(encoding = ‘UTF-8’,errors = ‘strict’): 使用编码encoding解码该字符串。 编码默认为默认字符串encoding。 s.encode(encoding = ‘UTF-8’,errors = ‘strict’): 返回字符串的编码字符串版本; 在错误的情况下，默认是抛出ValueError，除非使用’ignore‘或’replace‘给出错误。 s.expandtabs(tabsize = 8): 将字符串中的制表符扩展到多个空格; 如果没有提供tabize，则默认为每个制表符为8个空格。 maketrans(): 返回在translate函数中使用的转换表。max(str): 从字符串str返回最大字母字符。translate(table, deletechars=根据转换表STR(256个字符): 除去那些在del字符串转换字符串。zfill(width): 返回原始字符串，左边填充为零，总共有宽度(width)字符; 对于数字zfill()保留给定的任何符号(少于一个零)。 编码：python编码风格：PEP8（Python Enhancement Proposal）python增强提案 模块，包名：简短全小写，非必要时不带下划线 如：sys,re; 函数名，变量名：全小写，用下划线增加可读性，如：my_func(),my_var; 类名：单词首字母大写，如：MyClass; 常量名：全大写，下划线分隔，如：TAX_RETE； 缩进：每级相差4个空格； 比较操作：不要与True或者False值比较，如：if my_var ython 3的字符串使用Unicode，直接支持多语言。 UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间。 在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码，很多网页的源码上会有类似&lt;meta charset=&quot;UTF-8&quot; /&gt;的信息，表示该网页正是用的UTF-8编码。 用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件； 浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器： 如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。Python对bytes类型的数据用带b前缀的单引号或双引号表示，bytes的每个字符都只占用一个字节。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。 # 以Unicode表示的str通过encode()方法可以编码为指定的bytes &#39;ABC&#39;.encode(&#39;ascii&#39;) &#39;中文&#39;.encode(&#39;utf-8&#39;) # 如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法 # 如果bytes中只有一小部分无效的字节，可以传入errors=&#39;ignore&#39;忽略错误的字节 b&#39;\xe4\xb8\xad\xff&#39;.decode(&#39;utf-8&#39;, errors=&#39;ignore&#39;) # 当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行： # 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释； # 第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。 #!/usr/bin/env python3 # -*- coding: utf-8 -*- str类型和bytes类型bytes：二进制互联网上数据的都是以二进制的方式传输的 str ：unicode的呈现形式字符(Character)是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等字符集(Character set)是多个字符的集合字符集包括：ASCII字符集、GB2312字符集、GB18030字符集、Unicode字符集等 ASCII编码是1个字节，而Unicode编码通常是2个字节。UTF-8是Unicode的实现方式之一，UTF-8是它是一种变长的编码方式，可以是1，2，3个字节 str 使用encode方法转化为 bytesbytes通过decode转化为str 编码方式解码方式必须一样，否则就会出现乱码 格式化字符串第一种格式化：在字符串内部，%s表示用字符串替换，%d表示用整数替换，%f表示用浮点数替换，%x表示用十六进制替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。 第二种格式化：使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……， print(&#39;{1} and {0}&#39;.format(&#39;spam&#39;, &#39;eggs&#39;)) # eggs and spam 三种字符串格式化方式对比import timeit # %-formatting tm1 = timeit.timeit(&quot;&quot;&quot;name = &quot;Xiaoming&quot; &#39;Hello is %s.&#39; % name&quot;&quot;&quot;, number=10000) print(&#39;%用时: &#39;, tm1) # %用时: 0.001776108999999998 # str.format() tm2 = timeit.timeit(&quot;&quot;&quot;name = &quot;Xiaoming&quot; &#39;Hello is {}.&#39;.format(name)&quot;&quot;&quot;, number=10000) print(&#39;format用时: &#39;, tm2) # format用时: 0.0025024550000000007 # f-Strings tm3 = timeit.timeit(&quot;&quot;&quot;name = &quot;Xiaoming&quot; f&#39;Hello is {name}.&#39;&quot;&quot;&quot;, number=10000) print(&#39;f用时: &#39;, tm3) # f用时: 0.000950174000000005]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python关键字和内置函数]]></title>
    <url>%2F2019%2F02%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20190213_python%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[关键字关键字：即保留字，在python中已经使用的标识符，具有特殊的功能和含义。 # 查看关键字 import keyword print(keyword.kwlist) 2. python中的内置函数 abs()，取绝对值，不管数字是负数还是正数，结果都是正数。 bytes()，把字符串转为bytes。 chr()，把数字转换为字母，如chr(98) # 输出：b。（把编码转换为对应的字符） ord()，刚好与chr()相反，把字母转换为数字。（获取字符的整数表示） eval()，字符串转换成表达式并获取结果，如：eval(5*6)。 compile()，是把字符串编译成python代码，再由函数eval()，exec()执行。 dir()，可以快速的查看指定类或者模块包含的全部内容（包括函数，方法，类，变量等），如查看列表的方法：dir(list)。 help()，查看某个函数或者方法的帮助文档，如查看列表的备帮助，如：help(list)。 divmod()，是整除求余，如97除以10,整除是9，余数是7，divmod(97, 10)。 isinstance()，判断对象是否是某个类的实例，如：isinstance(‘姓名‘, str)。 filter()，函数是过滤。 map()，函数可以实现迭代的增加。 globals()，代表所有的全局变量,locbals()代表所有的局部变量。 max()，获取最大值，min()获取最小值，sum()获取和。 type()，查看类型。 len() ，方法返回对象（字符、列表、元组等）长度或项目个数。 ange() ，函数可创建一个整数列表，一般用在 for 循环中。 input() ，函数接受一个标准输入数据，返回为 string 类型。（python3中） unichr(x )：将一个整数转换为Unicode字符str(x )：将对象 x 转换为字符串repr(x )：将对象 x 转换为表达式字符串 int(x [,base ])：将x转换为一个整数long(x [,base ])：将x转换为一个长整数float(x )：将x转换到一个浮点数complex(real [,imag ])：创建一个复数hex(x )：将一个整数转换为一个十六进制字符串oct(x )：将一个整数转换为一个八进制字符串 id()：在python中，值是靠引用来传递来的。我们可以用id()来判断两个变量是否为同一个值的引用。 我们可以将id值理解为那块内存的地址标示。 Python的内置函数 数学相关: abs / divmod / pow / round / min / max / sum 序列相关: len / range / next / filter / map / sorted / slice / reversed 类型转换: chr / ord / str / bool / int / float / complex / bin / oct / hex 数据结构: dict / list / set / tuple 其他函数: all / any / id / input / open / print / type“””如：`pythondef myfilter(mystr): return len(mystr) == 6 help()print(chr(0x9a86))print(hex(ord(‘骆’)))print(abs(-1.2345))print(round(-1.2345))print(pow(1.2345, 5))fruits = [‘orange’, ‘peach’, ‘durian’, ‘watermelon’]print(fruits[slice(1, 3)])fruits2 = list(filter(myfilter, fruits))print(fruits)print(fruits2) 内置函数应用： 1.使用chr()与ord()可以实现随机的验证码 ```python import random li = [] for i in range(6): r = random.randrange(65, 91) li.append(chr(r)) print(&#39;&#39;.join(li)) 2.过滤出列表中大于2的值 li=[1,2,3,4,5,6,7,8,9,10] def f1(a): if a&gt;2: return True res=filter(f1,li) print(list(res)) 结合匿名函数lambda函数后，实现的过程更加简单 li=[1,2,3,4,5,6,7,8,9,10] res=filter(lambda a:a&gt;2,li) print(list(res)) 3.有列表[0,1,2,3,4,5,6,7,8,9]，都加10 li=[1,2,3,4,5,6,7,8,9] def f1(): result=[] for i in li: result.append(i+10) return result print(f1()) 使用map函数，实现的代码为： li=[1,2,3,4,5,6,7,8,9] def f1(a): return a+10 result=map(f1,li) print(list(result)) 结合lambda函数，实现的代码更加精简 li=[1,2,3,4,5,6,7,8,9] result=map(lambda a:a+10,li) print(list(result)) 内建函数代码#coding=utf-8 # builtin_function.py 内置函数 import os def fun(): all([True, False]) # 迭代器(为空or)所有元素为true,返回true =&gt; False any([True, False]) # 迭代器任意一个元素为true,返回true =&gt; True num = abs(-1.23) # 绝对值 num = pow(5, 3) # 幂次方 x**y =&gt;125 num = pow(5, 3, 3) # 幂次方再取余 (x**y) % z =&gt; 2 num = round(1.23) # 返回浮点数近似值,默认保留0位,且四舍五入 num = round(1.23, 5) # 5为保留小数点后位数 num = sum([1, 2, 3, 4, 5]) # 对列表数字求和 strs = ascii(os) # 返回对象的ascii字符串形式 strs = bin(123) # 整数转为二进制字符串(若被转对象非int类型可在__index__里定义) boolean = bool(0) # 获取真假(假:None / False / 任何类型的0 / 空&quot;&quot;()[]{} / __bool__返回False / __len__返回0) bytes = bytearray(&quot;You were, are and will be in my heart!&quot;, &quot;utf-8&quot;) # 字符串(字符串,编码):按编码转为字节序列 / 数字(数字):生成相应大小的空数组 / 无参():0数组 bytes = bytes(&quot;You were, are and will be in my heart!&quot;, &quot;utf-8&quot;) # 同bytearray(),但是不可变 strs = chr(123) # 整数(Unicode)转为char类型(范围[0, 1 114 111]) num = ord(&quot;{&quot;) # char类型转为整数(Unicode) num = complex(&quot;1+2j&quot;) # 将字符串或数字转为复数(不能含有空格) num = float(&#39;1.1&#39;) # 构建浮点数 strs = format(123,&#39;f&#39;) # 格式化(类型:x,b,f... / 位移:&gt;(&gt;10),&lt;,^ / 长度:5 / E) strs = hex(123) # 将整数转为16进制字符串 strs = oct(123) # 十进制转成8进制字符串 num = int(123.1) # 转为整数 strs = str(123) # 将对象转为字符串 strs = str(b&quot;123&quot;, &quot;utf-8&quot;) elem = max([1,2,3,4], [2,4,6]) # 可接收1个iterable,或多个元素 =&gt; [2, 4, 6] elem = max(1,2,3,4) # =&gt; 4 elem = max([1,2,3,4, 6], key = lambda x : x == 2) # =&gt; 2 elem = min(1,2,3,4) # 与max相反 exe = compile(&quot;print(&#39;O_O&#39;)&quot;, filename = &#39;strs&#39;, mode=&#39;exec&#39;) # 编译为代码, mode(编译模式:可执行语句&#39;exec&#39;,单个语句&#39;eval&#39;,交互式语句&#39;single&#39;) exec(exe) # 执行已编译代码 exec(&quot;print(&#39;O_O&#39;)&quot;) # 执行String未编译代码 eval(compile(&quot;print(&#39;O_O&#39;)&quot;, filename = &#39;strs&#39;, mode=&#39;eval&#39;)) # 不接受字符串类型 delattr(Clazz(&quot;Hello!&quot;), &quot;name&quot;) # 删除某对象属性 = del clazz.name 详情见 类 文章的 反射 代码块(https://www.jb51.net/article/128897.htm) setattr(Clazz(&quot;Hello!&quot;), &quot;name&quot;, &quot;World!&quot;) # 给对象某属性赋值 strs = getattr(Clazz(&quot;Hello!&quot;), &quot;name&quot;) # 获取某个对象的属性值 strs = getattr(Clazz(&quot;Hello!&quot;), &quot;name&quot;, -1) # -1为未找到属性的返回 boolean = hasattr(Clazz(&quot;Hello!&quot;), &quot;name&quot;) # 该对象是否有该属性 lists = dir(Clazz(&quot;Hello!&quot;)) # 查看函数 clazz = type(os) # 获取类型 dicts = globals() # 获取当前全局函数与对象 dicts = locals() # 获取当前局部函数与对象 dicts = vars() # 同locals() (__dict__) dicts = vars(Clazz(&quot;Hello!&quot;)) num = hash(Clazz(&quot;Hello!&quot;)) # 获取某对象的hash值 help(os) # 获取某对象的帮助文档 num = id(os) # 获取某对象的id boolean = isinstance(Clazz(&quot;Hello!&quot;), Clazz) # 对象是否是该类的实例 boolean = issubclass(Clazz, Clazz) # 该类(前)是否是该类(后)的子类(包括自己) strs = repr(os) # 将对象转为字符串表达形式 # - super() # 代理父类对象,详情见 类 文章(https://www.jb51.net/article/88315.htm) # - memoryview(obj) # 内存视图,详解 数据结构 文章(https://www.jb51.net/article/128892.htm) dics = dict() # 创建字典 tups = divmod(10, 5) # 返回元组,(商(10/5),余数(10%5)) lists = enumerate([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]) # 返回枚举对象 lists = filter(lambda x: True if (ord(x) &gt; 66) else False, [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]) # function为Frue保留,False移除 sets = frozenset([1, 2, 3]) # 返回新的frozenset对象(集合) num = len([1, 2, 3]) # 长度 lists = list((1, &#39;a&#39;)) # 转为list类型 tups = tuple([1, 2, 3]) # 转为tuple元组类型 ran = range(5) # 不可变序列 ran = range(0,5) ran = range(0,5,2) # (起始,结束,增加量) sets = set([1,2,3]) # 返回set集合 maps = map(lambda x, y: x*y, [1, 2, 3], [65, 66, 67, 68]) # 返回一个迭代器,元素通过自定义函数筛选,可接收多个iterable参数 =&gt; [65, 132, 201] iters = zip([&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;], [1, 2, 3]) # 创建新的迭代器, 聚合每个迭代器元素 =&gt; [(&#39;A&#39;, 1), (&#39;B&#39;, 2), (&#39;C&#39;, 3)] iters = iter([1, 2, 3, 4, 5]) # 返回一个迭代器对象 elem = next(iters) # 从迭代器中获取下个元素; 实现原理见 内置函数 文章 lis 块代码(https://www.jb51.net/article/128890.htm) iters = reversed([1,2,3]) # 返回反向的遍历器 =&gt; [3, 2, 1] lists = [1,2,3,4,5][slice(3)] # 切片 =&gt; [1, 2, 3] lists = [1,2,3,4,5][slice(1,3)] # [slice(3) == slice(None, 3, None) / slice(1,3) == slice(1, 3, None) / slice(1,3,1) == slice(1, 3, 1) lists = sorted([2,5,3,1,4]) # 排序 =&gt; [1, 2, 3, 4, 5] lists = sorted([&#39;a&#39;,&#39;B&#39;,&#39;;&#39;,&#39;t&#39;,&#39;D&#39;,&#39;1&#39;], key = lambda x : ord(x), reverse = True) # key:比较键的函数, reverse是否反向遍历 strs = input(&quot;请输入数据:&quot;) # 输入数据 f = open(&quot;temp.txt&quot;, &quot;r+&quot;) # 打开文件,详情见os文章 print(&quot;字符串%d&quot;%123) # 打印字符 =&gt; 字符串123 print(&quot;字&quot;,&quot;符&quot;, &quot;串&quot;, sep=&quot;-&quot;) # sep为分隔 =&gt; 字-符-串 print(&quot;字&quot;,&quot;符&quot;, &quot;串&quot;, sep=&quot;-&quot;, end=&quot;\r\n&quot;) # end为尾部 =&gt; 字-符-串/r/n print(&quot;字&quot;,&quot;符&quot;, &quot;串&quot;, sep=&quot;-&quot;, end=&quot;\r\n&quot;, file=open(&quot;temp.txt&quot;,&quot;w+&quot;)) # 打印到文件 class Clazz: def __init__(self, name): self.name = name; @classmethod # 将函数包装成类方法 def setName_cls(cls, name): pass @staticmethod # 将函数包装成静态方法 def setName_sta(name): pass def getname(self): return self.name def setname(self, value): self.name = value def delname(self): del self.name # property(fget=None, fset=None, fdel=None, doc=None) # 返回一个property 属性 # property 为属性方法, 有两种实现方式,详情见 类 文章的 属性方法代码块(https://www.jb51.net/article/68235.htm) x = property(getname, setname, delname) if __name__ == &quot;__main__&quot;: fun() # property 的使用 c = Clazz(&quot;柳岩&quot;) print(c.x) # =&gt; 柳岩 c.x = &#39;汤唯&#39; print(c.getname()) # =&gt; 汤唯 del c.x]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python标识符和运算符]]></title>
    <url>%2F2019%2F02%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20190212_python%E6%A0%87%E8%AF%86%E7%AC%A6%E5%92%8C%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[标识符：自己可以起名字的地方，包括变量，方法，函数,类，模块； 1.可以由大小写字母，数字，下划线（_）组成，其中数字不能开头； 2.标识符不能是python关键字，但可以包含关键字； 3.标识符不能包含空格。 对象本质：一个内存模块，拥有特定的值，支持特定类型的相关操作； 引用：在python中，变量也称为引用，因为变量存储的对象就是地址。 基本语法 : 在Python中严格区分大小写; Python中的每一行就是一条语句，每条语句以换行结束; Python中每一行语句不要过长（规范中建议每行不要超过80个字符）; “rulers”:[80], 一条语句可以分多行编写，多行编写时语句后边以\结尾 ; Python是缩进严格的语言，所以在Python中不要随便写缩进 ; 在Python中使用#来表示注释，#后的内容都属于注释，注释的内容将会被解释器所忽略;一般习惯上#后边会跟着一个空格 IDE（Integrated Development Environment），集成开发环境。是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。集成了代码编写功能、分析功能、编译功能、调试功能等一体化的开发软件服务套。 常用IDE ： Atom、Sublime、Pycharm、VS Code是Python使用者常用的几款IDE。pycharm-professional-2018.1.3 : 第三方IDE打开多个.py文件时，页面较为友好。同时还有以下优点：智能提示、代码着色、代码跳转、自动完成、单元测试、版本控制等等。 运算符 描述 [] [:] 下标，切片 ** 指数 ~ + - 按位取反, 正负号 * / % // 乘，除，模，整除 + - 加，减 &gt;&gt; &lt;&lt; 右移，左移 &amp; 按位与 ^ 按位异或 &lt;= &lt; &gt; &gt;= 小于等于，小于，大于，大于等于 == != 等于，不等于 is is not 身份运算符 in not in 成员运算符 not or and 逻辑运算符 = += -= *= /= %= //= **= &amp;= ^= &gt;&gt;= &lt;&lt;= （复合）赋值运算符 1. print() user_name = &#39;Charlie&#39; user_age = 8 # 指定sep参数，同时输出多个变量和字符串，指定分隔符 print(&quot;读者名:&quot; , user_name, &quot;年龄:&quot;, user_age, sep=&#39;|&#39;) # 指定end参数，指定输出之后不再换行 print(40, &#39;\t&#39;, end=&quot;&quot;) print(int(&#39;ff&#39;, 16)) # 255, 将16进制的ff转成十进制 print(int(&#39;101&#39;, 2)) # 5, 将2进制的101转成10进制 print(chr(97)) # a, 转为字符 print(ord(&#39;a&#39;)) # 转为ASCII码]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python变量和数据类型]]></title>
    <url>%2F2019%2F02%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F20190212_python%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[变量：是数据在内存中分配的空间，程序用来处理数据，而变量用来存储数据。 变量名必须是大小写英文、数字和_的组合，且不能用数字开头 引用：在python中，变量也称为引用，因为变量存储的就是对象的地址，变量通过地址引用了对象，变量位于栈内存，对象位于堆内存。 常量：所谓常量就是不能变的变量 # 在python的语法规范中推荐使用的方式： # -*- coding:utf-8 -*- # a本身是一个变量，它指向的对象的内容才是&#39;abc&#39;： a = &#39;abc&#39; # 变量a仍指向原有的字符串&#39;abc&#39;，但变量b却指向新字符串&#39;Abc&#39;了： b = a.replace(&#39;a&#39;, &#39;A&#39;) 变量的格式化输出%s:字符串；%d:有符号10进制数，%06d表示整数位数，不足以0补全；%f:浮点数，%02f，小数点后显示2位； # %03d 表示有3个整数位数，如不足以0补全，比如：132，087，006，得保证有3位数 # %04d 表示有4个整数位数，如不足以0补全，比如：1324，0087，0006，得保证有4位数 print(&#39;5{}&#39;.format(&quot;%03d&quot; % a)) python的数据类型数字型：整型(int)浮点型(float):如3.14,可表:314E-2或314e-2布尔型(bool)Tre非零数(非0即真)复数型( comples) 非数字型字符串 (string)列表 (list)元组 （Tuple）字典 (Dictionary)集 (Sets) 可以使用type(变量的名字)，来查看变量的类型。 不可变数据（3 个）：Number（数字）、String（字符串）、Tuple（元组）；可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python简介]]></title>
    <url>%2F2019%2F02%2Fpython%2Fpython%E5%9F%BA%E7%A1%80%2F01_python%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[用任何编程语言来开发程序，都是为了让计算机干活，比如下载一个MP3，编写一个文档等等，而计算机干活的CPU只认识机器指令，所以，尽管不同的编程语言差异极大，最后都得“翻译”成CPU可以执行的机器指令。而不同的编程语言，干同一个活，编写的代码量，差距也很大。 比如，完成同一个任务，C语言要写1000行代码，Java只需要写100行，而Python可能只要20行；C程序运行1秒钟，Java程序可能需要2秒，而Python程序可能就需要10秒 Java占据了世界上绝大部分电商，金融，通信等服务端应用的开发；而C,C++占据了世界上大部分贴近操作系统的硬件编程； 编译型语言：c,c++,Go,Swift,Object-c,Pascal解释型语言：JavaScript,Python,Rby,PHP,Perl,Erlang混合型：Java,C# python介绍:是一种解释型，面向对象的语言;由吉多·范罗苏姆（Guido van Rossum）于1989年发明，1991年正式公布；官网 www.python.org;设计哲学：优雅，明确，简单。 许多大型网站就是用Python开发的，例如YouTube、Instagram，还有国内的豆瓣。很多大公司，包括Google、Yahoo等，甚至NASA（美国航空航天局）都大量地使用Python。 python的历史:1. 1989年圣诞节：Guido von Rossum开始写Python语言的编译器。 2. 1991年2月：第一个Python编译器（同时也是解释器）诞生，它是用C语言实现的（后面），可以调用C语言的库函数。在最早的版本中，Python已经提供了对“类”，“函数”，“异常处理”等构造块的支持，还有对列表、字典等核心数据类型，同时支持以模块为基础来构造应用程序。 3. 1994年1月：Python 1.0正式发布。 4. 2000年10月16日：Python 2.0发布，增加了完整的垃圾回收，提供了对Unicode的支持。与此同时，Python的整个开发过程更加透明，社区对开发进度的影响逐渐扩大，生态圈开始慢慢形成。 5. 2008年12月3日：Python 3.0发布，它并不完全兼容之前的Python代码，不过因为目前还有不少公司在项目和运维中使用Python 2.x版本，所以Python 3.x的很多新特性后来也被移植到Python 2.6/2.7版本中。 6.2009年6月：Python发布3.1了版本。 7.2011年2月：Python发布3.2了版本。 8.2012年9月：Python发布3.3了版本。 9.2014年3月：Python发布了3.4版本。 10.2015年9月：Python发布了3.5版本。 11.2016年12月：Python发布了3.6版本。 目前我们使用的Python 3.7.x的版本是在2018年发布的，Python的版本号分为三段，形如A.B.C。其中A表示大版本号，一般当整体重写，或出现不向后兼容的改变时，增加A；B表示功能更新，出现新功能时增加B；C表示小的改动（例如：修复了某个Bug），只要有修改就增加C。如果对Python的历史感兴趣，可以阅读名为《Python简史》的博文。 python的优缺点:Python的优点很多，简单的可以总结为以下几点。 简单和明确，做一件事只有一种方法。 学习曲线低，跟其他很多语言相比，Python更容易上手。 开放源代码，拥有强大的社区和生态圈。 解释型语言，天生具有平台可移植性。 对两种主流的编程范式（面向对象编程和函数式编程）都提供了支持。 可扩展性和可嵌入性，例如在Python中可以调用C/C++代码。 代码规范程度高，可读性强，适合有代码洁癖和强迫症的人群。 Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池（batteries included）”。用Python开发，许多功能不必从零编写，直接使用现成的即可。 Python还有大量的第三方库 Python的缺点主要集中在以下几点。 1. 执行效率稍低，因此计算密集型任务可以由C/C++编写。 2. 代码无法加密，但是现在很多公司都不销售卖软件而是销售服务，这个问题会被弱化。 3. 在开发时可以选择的框架太多（如Web框架就有100多个），有选择的地方就有错误。 python的用途： WEB应用：Facebook 豆瓣⋯ 爬虫程序： 网络数据采集 科学计算： 云基础设施 自动化运维; 大数据（数据清洗）：科学计算和可视化、数据分析、量化交易 云计算; 桌面软件/游戏; 人工智能：机器人开发、自然语言处理、图像识别; GUI开发 python的解释器分类： CPython（官方）: 用c语言编写的Python解释器; IPython是基于CPython之上的一个交互式解释器，只是在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样的。 PyPy : 用Python语言编写的Python解释器; IronPython : 用.net编写的Python解释器; Jython : 用Java编写的Python解释器,可直接调用java类库，适合在java平台上开发 python2 和 python3的区别：1. python3中，print不再是关键字，而是函数， 2. 比如原来是 print ‘abc’ 现在是 print(‘abc’)但是 python2.6+ 可以使用 from future import print_function 来实现相同功能 3. 在Python 3中，没有旧式类，只有新式类， 4. 原来1/2（两个整数相除）结果是0，现在是0.5了， 5. 新的字符串格式化方法format取代%,从 python2.6+ 开始已经在str和unicode中有该方法, 同时 python3依然支持 % 算符 6. 对 bytes 和 原生 UNICODE 字符串的支持, 删除了 unicode 对象, str 为原生 unicode 字符串, bytes 替代了之前的 str. 7. xrange重命名为range。同时更改的还有一系列内置函数及方法, 都返回迭代器对象, 而不是列表或者 元组, 比如 filter, map, dict.items 等 8. != 取代 &lt; &gt; 在python2中 也很少有人用 &lt; &gt; 所以影响不大 9. 某些类库的变化，组织结构变了些. 但功能没变. urlparse - &gt; urllib.parse 这样的变化 import this print(this) # 可以看到Tim Peter撰写的“Python之禅”]]></content>
      <categories>
        <category>python</category>
        <category>python基础</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用java实现打印各种图形总结 (包括长方形 三角形 菱形 平行四边形等)]]></title>
    <url>%2F2017%2F05%2Fjava%2Fjava%E6%A1%88%E4%BE%8B%2F20170517_java%E6%89%93%E5%8D%B0%E5%9B%BE%E5%BD%A2%2F</url>
    <content type="text"><![CDATA[嵌套循环：循环中还可以声明循环。相当于内层循环的整体充当外层循环的循环体 1.首先来实现一个比较简单的，在控制台打印一个长方形： /** * 测试打印长方形 * @author cui_yonghua */ public class PintPic { public static void main(String[] args) { for(int j = 0;j &lt; 4;j++){//外层循环控制行数 for(int i = 0;i &lt; 5;i++){//内层循环控制列数 System.out.print(&quot;*&quot;); } System.out.println(); } } } 控制台输出如下：2.下面再看打印三角形: /** * 测试打印三角行 * @author cui_yonghua */ public class PintPic { public static void main(String[] args) { for(int j = 0;j &lt; 4;j++){//外层循环控制行数 for(int i = 0;i &lt; j + 1;i++){//每行输出j + 1个 System.out.print(&quot;*&quot;); } System.out.println(); } } } 控制台输出如下：3.打印如图所示： /** * 测试打印图形 * @author cui_yonghua */ public class PintPic { public static void main(String[] args) { for(int j = 0;j &lt; 4;j++){//外层循环控制行数 for(int i = 0;i &lt; j + 1;i++){//每行输出j + 1个 System.out.print(&quot;*&quot;); } System.out.println(); } for(int i = 0; i &lt; 5;i++){ for(int j = 0;j &lt; 5-i;j++){//for(int j = i;j &lt; 5;j++) System.out.print(&quot;*&quot;); } System.out.println(); } } } 控制台输出如下：4.打印如图所示：可以理解为 /** * 测试打印图形 * @author cui_yonghua */ public class PintPic { public static void main(String[] args) { for(int i = 0;i &lt; 5;i++){ for(int k = 0;k &lt; 4 - i;k++){ System.out.print(&quot; &quot;); } for(int j = 0;j &lt; i + 1;j++){ System.out.print(&quot;* &quot;); } System.out.println(); } } } 控制台输出如下： 5.再看打印菱形，如图所示： /** * 测试打印菱形 * @author cui_yonghua */ public class PintPic { public static void main(String[] args) { for(int i = 0;i &lt; 5;i++){ for(int k = 0;k &lt; 4 - i;k++){ System.out.print(&quot; &quot;); } for(int j = 0;j &lt; i + 1;j++){ System.out.print(&quot;* &quot;); } System.out.println(); } //下半部分 for(int i = 0;i &lt; 4;i++){ for(int k = 0;k &lt; i + 1;k++){ System.out.print(&quot; &quot;); } for(int j = 0;j &lt; 4 - i;j++){ System.out.print(&quot;* &quot;); } System.out.println(); } } } 控制台输出如下：6.那么，打印数字菱形该怎么做呢，代码如下： /** * 测试打印图形 * @author cui_yonghua */ public class PintPic { public static void main(String[] args) { for(int i=1;i&lt;=5;i++){ for(int j=1;j&lt;=5-i;j++){ System.out.print(&quot; &quot;); } for(int j=1;j&lt;=2*i-1;j++){ System.out.print(i); } System.out.println(); } for(int i=1;i&lt;=4;i++){ for(int j=1;j&lt;=i;j++){ System.out.print(&quot; &quot;); } for(int j=1;j&lt;=2*(5-i)-1;j++){ System.out.print(5-i); } System.out.println(); } } } 控制台输出如下：7.若打印空心菱形，代码如下： /** * 测试打印空心菱形 * @author cui_yonghua */ public class PintPic { public static void main(String[] args) { for(int i=1;i&lt;=5;i++){ for(int j=1;j&lt;=5-i;j++){ System.out.print(&quot; &quot;); } for(int j=1;j&lt;=2*i-1;j++){ if(j==1||j==2*i-1){ System.out.print(&quot;*&quot;);//上半截 } else{ System.out.print(&quot; &quot;); } } System.out.println(); } for(int i=1;i&lt;=4;i++){ for(int j=1;j&lt;=i;j++){ System.out.print(&quot; &quot;); } for(int j=1;j&lt;=2*(5-i)-1;j++){ if(j==1||j==2*(5-i)-1){ System.out.print(&quot;*&quot;); } else{ System.out.print(&quot; &quot;); } } System.out.println(); } } } 控制台输出如下：若根据用户输入的数字来打印菱形的行数，代码实现如下： import java.util.Scanner; /** * 使用for循环输出空心的菱形 */ public class Example { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.print(&quot;请输入菱形的行数：&quot;); int i = scanner.nextInt(); printHollowRhombus(i); } public static void printHollowRhombus(int size) { if (size % 2 == 0) { size++;// 计算菱形大小 } for (int i = 0; i &lt; size / 2 + 1; i++) { for (int j = size / 2 + 1; j &gt; i + 1; j--) { System.out.print(&quot; &quot;);// 输出左上角位置的空白 } for (int j = 0; j &lt; 2 * i + 1; j++) { if (j == 0 || j == 2 * i) { System.out.print(&quot;* &quot;);// 输出菱形上半部边缘 } else { System.out.print(&quot; &quot;);// 输出菱形上半部空心 } } System.out.println(&quot;&quot;); //换行 } for (int i = size / 2 + 1; i &lt; size; i++) { for (int j = 0; j &lt; i - size / 2; j++) { System.out.print(&quot; &quot;);// 输出菱形左下角空白 } for (int j = 0; j &lt; 2 * size - 1 - 2 * i; j++) { if (j == 0 || j == 2 * (size - i - 1)) { System.out.print(&quot;* &quot;);// 输出菱形下半部边缘 } else { System.out.print(&quot; &quot;);// 输出菱形下半部空心 } } System.out.println(&quot;&quot;); //换行 } } } 执行结果如下图所示： 8.打印平行四边形： /** * 测试打印平行四边形 * @author cui_yonghua */ public class PintPic { public static void main(String[] args) { for(int i=0;i&lt;=5;i++){ for(int j=1;j&lt;=5-i;j++){ System.out.print(&quot; &quot;); } for(int j=1;j&lt;=5;j++){ System.out.print(&quot;*&quot;); } System.out.println(); } } } 控制台输出如下：9.若随意输出一个n,输出打印n行，代码如下： import java.util.Scanner; /** * 测试打印图形 * @author cui_yonghua */ public class PintPic { public static void main(String[] args) { Scanner sc = new Scanner(System.in); int n = sc.nextInt(); for(int i = 1; i&lt;=n; i++){ //输出n-i个空格 for(int j = 1; j&lt;=n-i; j++){ System.out.print(&quot; &quot;); } //输出2*i-1个星 for(int j = 1; j&lt;=2*i-1; j++){ System.out.print(&quot;*&quot;); } //换行 System.out.println(); } } } 比如，随便输入一个数字6，效果如图： 有不到的地方欢迎大家评论指正，交流。]]></content>
      <categories>
        <category>Java</category>
        <category>java案例</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java案例</tag>
        <tag>java打印图形</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01 数据结构和算法——概述和总结]]></title>
    <url>%2F2017%2F05%2Fjava%2Fjava%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%2F20170505_%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[1.什么是数据结构和算法数据结构，就是一组数据的存储结构。算法，就是操作数据的一组方法。数据结构是为算法服务的，算法要作用在特定的数据结构之上。 2.为什么要学习数据结构和算法？（1）对个人：数据结构和算法是程序员的必修课程之一，能帮助我们写出性能更优更好的代码。算法，是一种解决问题的思路和方法，也可以运用到生活的各个方面。长期来看，大脑思考能力是个人最重要的核心竞争力，而算法能帮助我们有效的训练大脑的思考能力。 （2）应用层面原因：在计算机科学和互联网迅猛发展下，需要计算的数据量越来越庞大，但是计算机的计算能力是有限的，这么大量的数据计算，需要越来越多的计算机，需要越来越长的计算时间，注重效率的我们需要尽可能的提高计算效率。其中重要的一项，就是使用合适的数据结构和算法。选用合适的数据结构和算法，特别是在处理数量非常庞大的数据的时候，可以极大提高计算效率。 3.怎么样衡量数据结构和算法需要引入一个衡量的标准（metric）— 时间复杂度和空间复杂度。学习数据结构和算法的基石，就是要学会‘复杂度分析’。知道怎样去分析复杂度，才能做出正确的判断，在特定的场景下选用合适的正确的算法。而不是盲目的死记硬背，机械操作。 4.常见数据结构和算法常见数据结构：： 线性：数组 (Array)、栈 (Stack)、队列 (Queue)、链表 (Linked List)、块状数组（数组+链表） 树： 堆(heap)、二叉搜索树(binary search tree)、Merkle Tree(Hash Tree)、B-/B+ Tree、AVL树、红黑树、二叉树、哈夫曼树 图 (Graph) 散列表 (Hash) 常见算法： 基础：枚举，递归，分治，模拟，贪心，动态规划，剪枝，回溯 排序：冒泡、快速、直接选择和堆、直接插入和希尔排序、归并排序 查找：顺序查找、二分查找、索引查找、二叉排序树、哈希查找 图算法：深度优先遍历与广度优先遍历， 最短路径，最小生成树，拓扑排序]]></content>
      <categories>
        <category>Java</category>
        <category>java数据结构和算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java数据结构和算法]]></title>
    <url>%2F2017%2F05%2Fjava%2Fjava%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%2F20170504_java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[必备网站收藏 https://visualgo.net/en 可视化学习网站 https://algs4.cs.princeton.edu/home/ 算法官网 https://www.zhihu.com/question/21628833 知乎贴 学习进阶之路00 数据结构和算法——深度好文：学习数据结构的经验 01 数据结构和算法——概述和总结 02 数据结构和算法——数组 03 数据结构和算法——线性表 04 数据结构和算法——栈 05 数据结构和算法——队列 06 数据结构和算法——链表 07 数据结构和算法——散列表（哈希表） 08 数据结构和算法——堆 09 数据结构和算法——树和二叉树 10 数据结构和算法——字典树（这是一种高效的树形结构，但值得单独说明） 11 数据结构和算法——红黑树 12 数据结构和算法——哈夫曼树（Huffman Tree） 13 数据结构和算法——B树，B+树，B*树，R树的总结 14 数据结构和算法——图 15 数据结构和算法——基本算法思想及代码实现（穷举，递推，递归，分治，概率） 16 数据结构和算法——排序算法总结及代码实现（冒泡，选择，插入，Shell，快速，堆，归并） 17 数据结构和算法——查找算法总结及代码实现（顺序，折半，二分查找等） 速记导图图1： 图2: 数据结构：是指相互之间存在一种或多种特定关系的数据元素的集合用计算机存储、组织数据的方式。数据结构分别为逻辑结构、（存储）物理结构和数据的运算三个部分。 图3： 图4：]]></content>
      <categories>
        <category>Java</category>
        <category>java数据结构和算法</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础]]></title>
    <url>%2F2017%2F04%2Fjava%2Fjava%E5%9F%BA%E7%A1%80%2F2017427_java%E6%A0%B8%E5%BF%83%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[1. 包装类型把int变为Integer的赋值写法，称为自动装箱（Auto Boxing），反过来，把Integer变为int的赋值写法，称为自动拆箱（Auto Unboxing）。 包装类型的比较必须使用equals()。比如对两个Integer实例进行比较：绝对不能用==比较，因为Integer是引用类型，必须使用equals()比较： Java核心库提供的包装类型可以把基本类型包装为class；自动装箱和自动拆箱都是在编译期完成的（JDK&gt;=1.5）；装箱和拆箱会影响执行效率，且拆箱时可能发生NullPointerException；整数和浮点数的包装类型都继承自Number；包装类型提供了大量实用方法。 进制转换： public class Main { public static void main(String[] args) { // 最常用的静态方法parseInt()可以把字符串解析成一个整数 int x1 = Integer.parseInt(&quot;100&quot;); // 100 int x2 = Integer.parseInt(&quot;100&quot;, 16); // 256,因为按16进制解析 System.out.println(Integer.toString(100)); // &quot;100&quot;,表示为10进制 System.out.println(Integer.toString(100, 36)); // &quot;2s&quot;,表示为36进制 System.out.println(Integer.toHexString(100)); // &quot;64&quot;,表示为16进制 System.out.println(Integer.toOctalString(100)); // &quot;144&quot;,表示为8进制 System.out.println(Integer.toBinaryString(100)); // &quot;1100100&quot;,表示为2进制 } } 2. JavaBeanJavaBean是一种符合命名规范的class，它通过getter和setter来定义属性。 作用：JavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输。此外，JavaBean可以方便地被IDE工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中。 可以利用IDE快速生成getter和setter；使用Introspector.getBeanInfo()可以获取属性列表。`javapackage com.company; import java.beans.*; public class Main { public static void main(String[] args) throws Exception { // 要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的Introspector BeanInfo info = Introspector.getBeanInfo(Person.class); for (PropertyDescriptor pd : info.getPropertyDescriptors()) { System.out.println(pd.getName()); System.out.println(&quot; &quot; + pd.getReadMethod()); System.out.println(&quot; &quot; + pd.getWriteMethod()); } } } class Person { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } #### 3. 记录类 从Java 14开始，提供新的record关键字，可以非常方便地定义Data Class： - 使用record定义的是不变类； - 可以编写Compact Constructor对参数进行验证； - 可以定义静态方法。 代码如下： ```java public class Main { public static void main(String[] args) { Point p = new Point(123, 456); System.out.println(p.x()); System.out.println(p.y()); System.out.println(p); } } public record Point(int x, int y) {} 4. BigIntegerBigInteger用于表示任意大小的整数，BigInteger和Integer、Long一样，也是不可变类，并且也继承自Number类。因为Number定义了转换为基本类型的几个方法： 转换为byte：byteValue() 转换为short：shortValue() 转换为int：intValue() 转换为long：longValue() 转换为float：floatValue() 转换为double：doubleValue() 将BigInteger转换成基本类型时可使用longValueExact()等方法保证结果准确。对BigInteger做运算的时候，只能使用实例方法，例如，加法运算： import java.math.BigInteger; public class Main { public static void main(String[] args) { BigInteger i1 = new BigInteger(&quot;1234567890&quot;); BigInteger i2 = new BigInteger(&quot;12345678901234567890&quot;); BigInteger sum = i1.add(i2); // 12345678902469135780 } } 5. BigDecimal和BigInteger类似，BigDecimal可以表示一个任意大小且精度完全准确的浮点数,常用于财务计算。 比较BigDecimal的值是否相等，必须使用compareTo()而不能使用equals()。 import java.math.BigDecimal; public class Main { public static void main(String[] args) { BigDecimal d1 = new BigDecimal(&quot;123.456&quot;); BigDecimal d2 = new BigDecimal(&quot;123.45600&quot;); System.out.println(d1.equals(d2)); // false,因为scale不同 System.out.println(d1.equals(d2.stripTrailingZeros())); // true,因为d2去除尾部0后scale变为2 System.out.println(d1.compareTo(d2)); // 0 } } 6. MathMath类就是用来进行数学计算的，它提供了大量的静态方法来便于我们实现数学计算。 StrictMath保证所有平台计算结果都是完全相同的，而Math会尽量针对平台优化计算速度，所以，绝大多数情况下，使用Math就足够了。 package com.company; public class Main { public static void main(String[] args) { // 求绝对值： Math.abs(-100); // 100 Math.abs(-7.8); // 7.8 //取最大或最小值： Math.max(100, 99); // 100 Math.min(1.2, 2.3); // 1.2 // 计算x的y次方： Math.pow(2, 10); // 2的10次方=1024 // 计算√x（根号x）： Math.sqrt(2); // 1.414... //计算e的x次方： Math.exp(2); // 7.389... // 计算以e为底的对数： Math.log(4); // 1.386... // 计算以10为底的对数： Math.log10(100); // 2 //三角函数： Math.sin(3.14); // 0.00159... Math.cos(3.14); // -0.9999... Math.tan(3.14); // -0.0015... Math.asin(1.0); // 1.57079... Math.acos(1.0); // 0.0 // Math还提供了几个数学常量： double pi = Math.PI; // 3.14159... double e = Math.E; // 2.7182818... Math.sin(Math.PI / 6); // sin(π/6) = 0.5 // 生成一个随机数x，x的范围是0 &lt;= x &lt; 1： // Math.random()实际上内部调用了Random类，所以它也是伪随机数，只是我们无法指定种子 Math.random(); // 0.53907... 每次都不一样 // 如果我们要生成一个区间在[MIN, MAX)的随机数，可以借助Math.random()实现 double x = Math.random(); // x的范围是[0,1) double min = 10; double max = 50; double y = x * (max - min) + min; // y的范围是[10,50) long n = (long) y; // n的范围是[10,50)的整数 System.out.println(y); System.out.println(n); } } 7. Random和SecureRandomRandom用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。要生成一个随机数，可以使用nextInt()、nextLong()、nextFloat()、nextDouble() Random r = new Random(); r.nextInt(); // 2071575453,每次都不一样 r.nextInt(10); // 5,生成一个[0,10)之间的int r.nextLong(); // 8811649292570369305,每次都不一样 r.nextFloat(); // 0.54335...生成一个[0,1)之间的float r.nextDouble(); // 0.3716...生成一个[0,1)之间的double import java.util.Random; public class Main { public static void main(String[] args) { Random r = new Random(12345); for (int i = 0; i &lt; 10; i++) { System.out.println(r.nextInt(100)); } // 51, 80, 41, 28, 55... } } SecureRandom：生成安全的随机数。SecureRandom的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。在密码学中，安全的随机数非常重要。如果使用不安全的伪随机数，所有加密体系都将被攻破。因此，时刻牢记必须使用SecureRandom来产生安全的随机数。 实际使用的时候，可以优先获取高强度的安全随机数生成器，如果没有提供，再使用普通等级的安全随机数生成器： import java.util.Arrays; import java.security.SecureRandom; import java.security.NoSuchAlgorithmException; public class Main { public static void main(String[] args) { SecureRandom sr = null; try { sr = SecureRandom.getInstanceStrong(); // 获取高强度安全随机数生成器 } catch (NoSuchAlgorithmException e) { sr = new SecureRandom(); // 获取普通的安全随机数生成器 } byte[] buffer = new byte[16]; sr.nextBytes(buffer); // 用安全随机数填充buffer System.out.println(Arrays.toString(buffer)); } }]]></content>
      <categories>
        <category>Java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java数组]]></title>
    <url>%2F2017%2F04%2Fjava%2Fjava%E5%9F%BA%E7%A1%80%2F2017424_%E6%95%B0%E7%BB%84%E5%92%8Cstring%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[数组数组：一次性定义多个 相同数据类型的变量。 特点:长度固定，内存中必定连续，便于寻址，查询效率高 1).数组的初始化 //静态初始化：在声明并初始化数组与给数组相应的元素赋值操作同时进行。 int[] scores1 = new int[]{72,90,59}; //动态初始化：在声明并初始化数组与给数组相应的元素赋值操作分开进行。 int scores2[] = new int[3]; scores2[0] = 72; scores2[1] = 90; scores2[2] = 59; 注：不管是动态还是静态初始化数组，一定在创建的时候，就指明了数组的长度！ 2).如何引用数组元素：通过数组的下角标的方式。下角标从0开始，到n-1结束。其中n为数组的长度。 3).数组的长度：通过数组的属性length来调用。System.out.println(scores2.length);//3 4).如何遍历数组for(int i = 0;i &lt; scores1.length;i++){ System.out.println(scores1[i]);} 5).关于数组元素的默认初始化值 byte short int long 而言：0 float double 而言：0.0 char而言：空格 boolean而言：false 引用类型变量而言:null 6). Arrays类：Arrays类一般用来操作数组(比如排序和搜索)的各种方法。如果指定数组引用为null，则访问此类中的方法都会抛出空指针异常NullPointerException。比较常见的方法有： sort方法，用来对指定数组中的元素进行排序（元素值从小到大进行排序）; int[] arr = {1,5,9,3,7};Arrays.sort( arr ); toString方法，用来返回指定数组元素内容的字符串形式 int[] arr = {1,5,9,3,7};String str = Arrays.toString(arr); //str的值为[1, 3, 5, 7, 9] binarySearch方法，在指定数组中，查找给定元素值出现的位置。若没有查询到，返回位置为-1。要求该数组必须是个有序的数组。 int[] arr = {1,3,4,5,6};int index = Arrays.binarySearch(arr, 4); //index的值为2int index2= Arrasy.binarySearch(arr, 2); //index2的值为-1]]></content>
      <categories>
        <category>Java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java字符串String类]]></title>
    <url>%2F2017%2F04%2Fjava%2Fjava%E5%9F%BA%E7%A1%80%2F2017425_%E5%AD%97%E7%AC%A6%E4%B8%B2string%E7%B1%BB%E7%9A%84%2F</url>
    <content type="text"><![CDATA[String类：不可变的字符序列常用方法： int length():获取字符串的长度，其实也就是字符个数char charAt(int index):获取指定索引处的字符 int indexOf(String str):获取str在字符串对象中第一次出现的索引String substring(int start,int end):从start开始，到end结束截取字符串boolean equals(Object obj):比较字符串的内容是否相同boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写boolean startsWith(String str):判断字符串对象是否以指定的str开头boolean endsWith(String str):判断字符串对象是否以指定的str结尾char[] toCharArray():把字符串转换为字符数组String toLowerCase():把字符串转换为小写字符串String toUpperCase():把字符串转换为大写字符串String trim():去除字符串两端空格String[] split(String str):按照指定符号分割字符串 public class StringMethodDemo { public static void main(String[] args) { //创建字符串对象 String s = &quot;helloworld&quot;; //int length():获取字符串的长度，其实也就是字符个数 System.out.println(s.length());//结果为：10 //char charAt(int index):获取指定索引处的字符 System.out.println(s.charAt(0));//结果为：h System.out.println(s.charAt(1));//结果为：e //int indexOf(String str):获取str在字符串对象中第一次出现的索引 System.out.println(s.indexOf(&quot;l&quot;));//结果为：2 System.out.println(s.indexOf(&quot;owo&quot;));//结果为：4 System.out.println(s.indexOf(&quot;ak&quot;));//结果为：-1 //String substring(int start):从start开始截取字符串 System.out.println(s.substring(0));//结果为：helloworld System.out.println(s.substring(5));//结果为：world //String substring(int start,int end):从start开始，到end结束截取字符串 System.out.println(s.substring(0, s.length()));//结果为：helloworld System.out.println(s.substring(3,8));//结果为：lowor String s3 = &quot;hello&quot;; String s4 = &quot;hello&quot;; String s5 = &quot;Hello&quot;; //boolean equals(Object obj):比较字符串的内容是否相同 System.out.println(s3.equals(s4));//结果为：true //boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写 System.out.println(s3.equalsIgnoreCase(s5));//结果为：true //创建字符串对象 String s6 = &quot;abcde&quot;; //char[] toCharArray():把字符串转换为字符数组 char[] chs = s6.toCharArray(); for(int x=0; x&lt;chs.length; x++) { System.out.println(chs[x]); } //String[] split(String str):按照指定符号分割字符串 String s4 = &quot;aa,bb,cc&quot;; String[] strArray = s4.split(&quot;,&quot;); for(int x=0; x&lt;strArray.length; x++) { System.out.println(strArray[x]); } } } 从键盘输入一串字符,统计一个字符串大小写字母字符，数字字符出现的次数。(不考虑其他字符) import java.util.Scanner; public class StringMethodDemo { public static void main(String[] args) { Scanner sc = new Scanner(System.in);//键盘录入一个字符串数据 System.out.println(&quot;请输入一个字符串数据：&quot;); String s = sc.nextLine(); //定义三个统计变量，初始化值都是0 int bigCount = 0; int smallCount = 0; int numberCount = 0; //遍历字符串，得到每一个字符 for(int x=0; x&lt;s.length(); x++) { char ch = s.charAt(x); //拿字符进行判断 if(ch&gt;=&#39;A&#39; &amp;&amp; ch&lt;=&#39;Z&#39;) { bigCount++; }else if(ch&gt;=&#39;a&#39; &amp;&amp; ch&lt;=&#39;z&#39;) { smallCount++; }else if(ch&gt;=&#39;0&#39; &amp;&amp; ch&lt;=&#39;9&#39;) { numberCount++; }else { System.out.println(&quot;该字符&quot;+ch+&quot;非法&quot;); } } //输出结果 System.out.println(&quot;您输入的大写字符有：&quot;+bigCount+&quot;个&quot;); System.out.println(&quot;您输入的小写字符有：&quot;+smallCount+&quot;个&quot;); System.out.println(&quot;您输入的数字字符有：&quot;+numberCount+&quot;个&quot;); } } String类与基本数据类型、包装类；与字符数组、字节数组之间的转换 * 1.字符串 与基本数据类型、包装类之间转换 * ①字符串 ---&gt;基本数据类型、包装类:调用相应的包装类的parseXxx(String str); * ①基本数据类型、包装类---&gt;字符串:调用字符串的重载的valueOf()方法 * * 2.字符串与字节数组间的转换 * ①字符串----&gt;字节数组:调用字符串的getBytes() * ②字节数组----&gt;字符串：调用字符串的构造器 * * 3.字符串与字符数组间的转换 * ①字符串----&gt;字符数组：调用字符串的toCharArray(); * ②字符数组----&gt;字符串:调用字符串的构造器 * * 4.String与StringBuffer的转换 * ①String ---&gt;StringBuffer：使用StringBuffer的构造器：new StringBuffer(String str); * ②StringBuffer-----&gt;String:使用StringBuffer的toString()方法 public class Test { public static void main(String[] args) { //将数字型的字符串 转化为数字 String s1 = &quot;123456&quot;; System.out.println(Integer.parseInt(s1)); String s2 = &quot;45.87&quot;; System.out.println(Double.parseDouble(s2)); //将数字转化为字符串 int n1 = 234812; System.out.println(Integer.toString(n1)); double n2 = 23.45; System.out.println(Double.toString(n2)); } } StringBuffer类：可变的字符序列 StringBuilder类：可变的字符序列，jdk5.0新加入的，效率更高，线程不安全。 public class StringMethodDemo { public static void main(String[] args) { //创建一个字符串缓冲区对象。用于存储数据。 StringBuffer sb = new StringBuffer(); sb.append(&quot;haha&quot;); //添加字符串 此时sb=haha sb.insert(2, &quot;it&quot;);//在指定位置插入 此时sb=haitha sb.delete(1, 4);//删除 此时sb=hha sb.replace(1, 4, &quot;cast&quot;);//替换指定范围内的内容 此时sb=hcast String str = sb.toString();// 此时sb=hcast } } 设置字符串的格式： public class StringMethodDemo { public static void main(String[] args) { //格式字符串以百分符号（%）打头，后面跟一个或多个标志。 // 格式字符串“%,d”显示十迚制数，并将每3 位用逗号分隔。 //格式字符串“%n”显示换行符。 int accountBalance = 5005; System.out.format(&quot;Balance: $%,d%n&quot;, accountBalance);//输出：Balance: $5,005 //输出Π的小数点后11位 double pi1 = Math.PI; System.out.format(&quot;%.11f%n&quot;, pi1);//输出：3.14159265359 } } 其它： 奖金定义成长整型： 要精确到小数点后多少位，用 &gt; DecimalFormat df = new DecimalFormat(&quot;#0.0000&quot;); 1. StringJava字符串String是不可变对象；字符串操作不改变原字符串内容，而是返回新字符串；Java使用Unicode编码表示String和char；转换编码就是将String和byte[]转换，需要指定编码；转换为byte[]时，始终优先考虑UTF-8编码。 比较字符串的内容是否相同。必须使用equals()方法而不能用==。要忽略大小写比较，使用equalsIgnoreCase()方法。 public class Main { public static void main(String[] args) { // 定义 String s = &quot;Hello!&quot;; String sa = new String(new char[] {&#39;H&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;!&#39;}); // 两个字符串比较，必须总是使用equals()方法。 String s1 = &quot;hello&quot;; String s2 = &quot;HELLO&quot;.toLowerCase(); System.out.println(s1 == s2); System.out.println(s1.equals(s2)); // 是否包含子串: System.out.println(&quot;是否包含子串：&quot; + s1.contains(&quot;ll&quot;)); // true // 搜索子串 System.out.println(s1.indexOf(&#39;l&#39;)); // 2 System.out.println(s1.lastIndexOf(&#39;l&#39;)); // 3 System.out.println(s1.startsWith(&quot;he&quot;)); // true System.out.println(s1.endsWith(&quot;lo&quot;)); // true // 提取子串的例子： System.out.println(&quot;Hello&quot;.substring(2)); // &quot;llo&quot; System.out.println(&quot;Hello&quot;.substring(2, 4)); //&quot;ll&quot; // 去除首尾空白字符 System.out.println(&quot; \tHello\r\n &quot;.trim()); // &quot;Hello&quot; System.out.println(&quot;&quot;.isEmpty()); // 替换子串 String replaceSub = &quot;hello&quot;; String rep = replaceSub.replace(&#39;l&#39;, &#39;w&#39;); // &quot;hewwo&quot;，所有字符&#39;l&#39;被替换为&#39;w&#39; System.out.println(rep); replaceSub.replace(&quot;ll&quot;, &quot;~~&quot;); // &quot;he~~o&quot;，所有子串&quot;ll&quot;被替换为&quot;~~&quot; // 另一种是通过正则表达式替 String s3 = &quot;A,,B;C ,D&quot;; s3.replaceAll(&quot;[\\,\\;\\s]+&quot;, &quot;,&quot;); // &quot;A,B,C,D&quot; // 分割字符串 String s4 = &quot;A,B,C,D&quot;; String[] ss = s4.split(&quot;\\,&quot;); // {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;} System.out.println(ss[1]); // 拼接字符串 String[] arr = {&quot;A&quot;, &quot;B&quot;, &quot;C&quot;}; String s5 = String.join(&quot;***&quot;, arr); // &quot;A***B***C&quot; System.out.println(s5); //类型转换 // 把任意基本类型或引用类型转换为字符串 String.valueOf(123); // &quot;123&quot; // 把字符串转换为其他类型，就需要根据情况 int n1 = Integer.parseInt(&quot;123&quot;); // 123 boolean b1 = Boolean.parseBoolean(&quot;true&quot;); // true // String和char[]类型可以互相转换 char[] cs = &quot;Hello&quot;.toCharArray(); // String -&gt; char[] String s6 = new String(cs); // char[] -&gt; String } } 字符串的不同形式表示import java.text.*; import java.util.*; public class Main { public static void main(String[] args) { int n = 123400; // 123400 System.out.println(n); // 以16进制打印n为:1e208 System.out.println(Integer.toHexString(n)); // 以价格的方式打印n为:$123,400.00 System.out.println(NumberFormat.getCurrencyInstance(Locale.US).format(n)); } } 2. StringBuilderStringBuilder是可变对象，用来高效拼接字符串；StringBuilder可以支持链式操作，实现链式操作的关键是返回实例本身；StringBuffer是StringBuilder的线程安全版本，现在很少使用。 public class Main { public static void main(String[] args) { StringBuilder sb = new StringBuilder(1024); for (int i = 0; i &lt; 10; i++) { sb.append(&#39;,&#39;); sb.append(i); } String s = sb.toString(); System.out.println(s); StringBuilder sb1 = new StringBuilder(1024); sb1.append(&quot;Mr &quot;) .append(&quot;Bob&quot;) .append(&quot;!&quot;) .insert(0, &quot;Hello, &quot;); System.out.println(sb1.toString()); } } StringJoiner用指定分隔符拼接字符串数组时，使用StringJoiner或者String.join()更方便；用StringJoiner拼接字符串时，还可以额外附加一个“开头”和“结尾”。 很多时候，我们拼接的字符串像这样： public class Main { public static void main(String[] args) { String[] names = {&quot;Bob&quot;, &quot;Alice&quot;, &quot;Grace&quot;}; StringBuilder sb = new StringBuilder(); sb.append(&quot;Hello &quot;); for (String name : names) { sb.append(name).append(&quot;, &quot;); } // 注意去掉最后的&quot;, &quot;: sb.delete(sb.length() - 2, sb.length()); sb.append(&quot;!&quot;); System.out.println(sb.toString()); } } 类似用分隔符拼接数组的需求很常见，所以Java标准库还提供了一个StringJoiner来干这个事： import java.util.StringJoiner; public class Main { public static void main(String[] args) { String[] names = {&quot;Bob&quot;, &quot;Alice&quot;, &quot;Grace&quot;}; StringJoiner sj = new StringJoiner(&quot;, &quot;, &quot;Hello &quot;, &quot;!&quot;); for (String name : names) { sj.add(name); } System.out.println(sj.toString()); // 不需要指定“开头”和“结尾”的时候，用String.join()更方便： String[] names1 = {&quot;Bob&quot;, &quot;Alice&quot;, &quot;Grace&quot;}; String s = String.join(&quot;, &quot;, names1); } }]]></content>
      <categories>
        <category>Java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java运算和流程控制]]></title>
    <url>%2F2017%2F04%2Fjava%2Fjava%E5%9F%BA%E7%A1%80%2F2017423_%E8%BF%90%E7%AE%97%E5%92%8C%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[public class Main { public static void main(String[] args) { // ++n表示先加1再引用n，n++表示先引用n再加1 int n = 3300; n++; // 3301, 相当于 n = n + 1; n--; // 3300, 相当于 n = n - 1; int y = 100 + (++n); // 不要这么写 System.out.println(y); } } 移位运算：左移实际上就是不断地×2，右移实际上就是不断地÷2。 浮点数运算：浮点数运算和整数运算相比，只能进行加减乘除这些数值计算，不能做位运算和移位运算。 布尔运算：对于布尔类型boolean，永远只有true和false两个值。布尔运算是一种关系运算，包括以下几类：比较运算符：&gt;，&gt;=，&lt;，&lt;=，==，!=；与运算 &amp;&amp;；或运算 ||；非运算 ! 溢出:整数运算在除数为0时会报错，而浮点数运算在除数为0时，不会报错，但会返回几个特殊值：NaN表示Not a Number； Infinity表示无穷大； -Infinity表示负无穷大。 三元运算符：Java还提供一个三元运算符b ? x : y，它根据第一个布尔表达式的结果，分别返回后续两个表达式之一的计算结果。（三元运算b ? x : y后面的类型必须相同，三元运算也是“短路运算”，只计算x或y。） 转义字符：（因为\是转义字符，所以，两个\表示一个\字符），常见的转义字符包括： \” 表示字符” \’ 表示字符’ \ 表示字符\ \n 表示换行符 \r 表示回车符 \t 表示Tab \u#### 表示一个Unicode编码的字符 package com.company; public class Main { public static void main(String[] args) { // 转义字符 String zhuanyi = &quot;ABC\n\u4e2d\u6587&quot;; // 包含6个字符: A, B, C, 换行符, 中, 文 // 字符串拼接 String s1 = &quot;Hello&quot;; String s2 = &quot;world&quot;; String s = s1 + &quot; &quot; + s2 + &quot;!&quot;; System.out.println(s); // 字符串的不可变是指字符串内容不可变。但是引用类型可以变 String s3 = &quot;hello&quot;; String t = s3; s3 = &quot;world&quot;; System.out.println(t); // t是&quot;hello&quot; // 引用类型的变量可以指向一个空值null，它表示不存在，即该变量不指向任何对象 String s4 = null; // s1是null String s5; // 没有赋初值值，s2也是null String s6 = s4; // s3也是null String s7 = &quot;&quot;; // s4指向空字符串，不是null } } Java的格式化功能提供了多种占位符，可以把各种数据类型“格式化”成指定的字符串： %d 格式化输出整数 %x 格式化输出十六进制整数 %f 格式化输出浮点数 %e 格式化输出科学计数法表示的浮点数 %s 格式化字符串 占位符和输入案例： import java.util.Scanner; public class Main { public static void main(String[] args) { // 占位符本身还可以有更详细的格式化参数。下面的例子把一个整数格式化成十六进制，并用0补足8位 int n = 12345000; System.out.printf(&quot;n=%d, hex=%08x&quot;, n, n); // 注意，两个%占位符必须传入两个数 Scanner scanner = new Scanner(System.in); // 创建Scanner对象 System.out.print(&quot;Input your name: &quot;); // 打印提示 String name = scanner.nextLine(); // 读取一行输入并获取字符串 System.out.print(&quot;Input your age: &quot;); // 打印提示 int age = scanner.nextInt(); // 读取一行输入并获取整数 System.out.printf(&quot;Hi, %s, you are %d\n&quot;, name, age); // 格式化输出 } } switch: switch语句可以做多重选择，然后执行匹配的case语句后续代码； switch的计算结果必须是整型、字符串或枚举类型； 注意千万不要漏写break，建议打开fall-through警告； 总是写上default，建议打开missing default警告； 从Java 14开始，switch语句正式升级为表达式，不再需要break，并且允许使用yield返回值。 while: while循环先判断循环条件是否满足，再执行循环语句； while循环可能一次都不执行； 编写循环时要注意循环条件，并避免死循环。 do while: do while循环先执行循环，再判断条件； do while循环会至少执行一次。 for: for循环通过计数器可以实现复杂循环； for each循环可以直接遍历数组的每个元素，但无法获取索引； 最佳实践：计数器变量定义在for循环内部，循环体内部不修改计数器； package com.company; public class Main { public static void main(String[] args) { int[] ns = { 1, 4, 9, 16, 25 }; for (int i=0; i&lt;ns.length; i++) { System.out.println(ns[i]); } // 使用for each遍历 // for each循环的变量n不再是计数器，而是直接对应到数组的每个元素 // for each循环无法指定遍历顺序，也无法获取数组的索引。 for (int n : ns) { System.out.println(n); } } } break和contonie break语句可以跳出当前最近的一层循环，通常配合if，在满足条件时提前结束整个循环； continue语句可以提前结束本次循环，continue语句通常配合if，在满足条件时提前结束本次循环。]]></content>
      <categories>
        <category>Java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java变量和数据类型]]></title>
    <url>%2F2017%2F04%2Fjava%2Fjava%E5%9F%BA%E7%A1%80%2F2017422_%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[类名要求： 类名必须以英文字母开头，后接字母，数字和下划线的组合 习惯以大写字母开头 常量： 定义变量的时候，如果加上final修饰符，这个变量就变成了常量： 常量在定义时进行初始化后就不可再次赋值，再次赋值会导致编译错误。 常量名通常全部大写。 在Java中，数据类型分为两种：基本类型的变量和引用类型的变量（所有class和interface类型，引用类型可以赋值为null，表示空，但基本类型不能赋值为null）。 基本数据类型是CPU可以直接进行运算的类型。Java定义了以下几种基本数据类型： 整数类型：byte(1字节)，short(2字节)，int(4字节)，long(8字节) 浮点数类型：float(4字节)，double(8字节) 字符类型：char(2字节) 布尔类型：boolean(Java语言对布尔类型的存储并没有做规定，因为理论上存储布尔类型只需要1 bit，但是通常JVM内部会把boolean表示为4字节整数。) Java定义的这些基本数据类型有什么区别呢？要了解这些区别，我们就必须简单了解一下计算机内存的基本结构。计算机内存的最小存储单元是字节（byte），一个字节就是一个8位二进制数，即8个bit。它的二进制表示范围从00000000~11111111，换算成十进制是0~255，换算成十六进制是00~ff。内存单元从0开始编号，称为内存地址。每个内存单元可以看作一间房间，内存地址就是门牌号。一个字节是1byte，1024字节是1K，1024K是1M，1024M是1G，1024G是1T。 变量的定义示例代码：package com.company; public class Main { public static void main(String[] args) { // 定义整型 // 特别注意：同一个数的不同进制的表示是完全相同的，例如15=0xf＝0b1111。 int i = 2147483647; int i2 = -2147483648; int i3 = 2_000_000_000; // 加下划线更容易识别 int i4 = 0xff0000; // 十六进制表示的16711680 int i5 = 0b1000000000; // 二进制表示的512 long l = 9000000000000000000L; // long型的结尾需要加L // 定义浮点型 // 浮点数可表示的范围非常大，float类型可最大表示3.4x1038，而double类型可最大表示1.79x10308。 float f1 = 3.14f; // 对于float类型，需要加上f后缀。 float f2 = 3.14e38f; // 科学计数法表示的3.14x10^38 double d = 1.79e308; double d2 = -1.79e308; double d3 = 4.9e-324; // 科学计数法表示的4.9x10^-324 // 定义boolean型 boolean b1 = true; boolean b2 = false; boolean isGreater = 5 &gt; 3; // 计算结果为true int age = 12; boolean isAdult = age &gt;= 18; // 计算结果为false boolean isTeenager = age &gt;6 &amp;&amp; age &lt;18; // true // 字符类型char表示一个字符。Java的char类型除了可表示标准的ASCII外，还可以表示一个Unicode字符 // 注意char类型使用单引号&#39;，且仅有一个字符，要和双引号&quot;的字符串类型区分开 char a = &#39;A&#39;; char zh = &#39;中&#39;; // 常量 final double PI = 3.14; // PI是一个常量 double r = 5.0; double area = PI * r * r; } }]]></content>
      <categories>
        <category>Java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础]]></title>
    <url>%2F2017%2F04%2Fjava%2Fjava%E5%9F%BA%E7%A1%80%2F2017421_java%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[java介绍Java最早是由SUN公司（已被Oracle收购）的詹姆斯·高斯林（高司令，人称Java之父）在上个世纪90年代初开发的一种编程语言。java的运行机制：Java是将代码编译成一种“字节码”，它类似于抽象的CPU指令，然后，针对不同平台编写虚拟机，不同平台的虚拟机负责加载字节码并执行，这样就实现了“一次编写，到处运行”的效果。 从互联网到企业平台，Java是应用最广泛的编程语言，原因在于： Java是基于JVM虚拟机的跨平台语言，一次编写，到处运行； Java程序易于编写，而且有内置垃圾收集，不必考虑内存管理； Java虚拟机拥有工业级的稳定性和高度优化的性能，且经过了长时期的考验； Java拥有最广泛的开源社区支持，各种高质量组件随时可用。 Java语言常年霸占着三大市场： 互联网和企业应用，这是Java EE的长期优势和市场地位； 大数据平台，主要有Hadoop、Spark、Flink等，他们都是Java或Scala（一种运行于JVM的编程语言）开发的； Android移动平台。 这意味着Java拥有最广泛的就业市场。随着Java的发展，SUN给Java又分出了三个不同版本： Java ME：Micro Edition，一个针对嵌入式设备的“瘦身版”，Java SE的标准库无法在Java ME上使用； Java SE：Standard Edition， 标准版，包含标准的JVM和标准库； Java EE：Enterprise Edition，在Java SE的基础上加上了大量的API和库，以便方便开发Web应用、数据库、消息服务等。我们熟悉的Spring等框架都是Java EE开源生态系统的一部分。 因此我们推荐的Java学习路线图如下： 首先要学习Java SE，掌握Java语言本身、Java核心开发技术以及Java标准库的使用； 如果继续学习Java EE，那么Spring框架、数据库开发、分布式架构就是需要学习的； 如果要学习大数据开发，那么Hadoop、Spark、Flink这些大数据平台就是需要学习的，他们都基于Java或Scala开发； 如果想要学习移动开发，那么就深入Android平台，掌握Android App开发。 无论怎么选择，Java SE的核心技术是基础，这个教程的目的就是让你完全精通Java SE！ java名词解释： JDK：Java Development Kit：JDK除了包含JRE，还提供了编译器、调试器等开发工具。 JRE：Java Runtime Environment：运行Java字节码的虚拟机。（包括JVM + Runtime library） JSR规范：Java Specification Request：为了保证Java语言的规范性，SUN公司搞了一个JSR规范，凡是想给Java平台加一个功能，比如说访问数据库的功能，大家要先创建一个JSR规范，定义好接口，这样，各个数据库厂商都按照规范写出Java驱动程序，开发者就不用担心自己写的数据库代码在MySQL上能跑，却不能跑在PostgreSQL上。 JCP组织：Java Community Process：JSR是一系列的规范，从JVM的内存模型到Web程序接口，全部都标准化了。而负责审核JSR的组织就是JCP。 配置环境变量首先到官网下载jdk：https://www.oracle.com/java/technologies/javase-jdk14-downloads.html，然后安装；安装完JDK后，需要设置一个JAVA_HOME的环境变量，它指向JDK的安装目录。在Windows下，它是安装目录，类似： C:\Program Files\Java\jdk-14 然后，把JAVA_HOME的bin目录附加到系统环境变量PATH上。在Windows下，它长这样： Path=%JAVA_HOME%\bin;&lt;现有的其他路径&gt; 在Mac下，它在~/.bash_profile或~/.zprofile里，它是： export JAVA_HOME=`/usr/libexec/java_home -v 14` export PATH=$JAVA_HOME/bin:$PATH 把JAVA_HOME的bin目录添加到PATH中是为了在任意文件夹下都可以运行java。打开命令提示符窗口，输入命令java -version，可以看到java的版本，则jdk安装正常。细心的童鞋还可以在JAVA_HOME的bin目录下找到很多可执行文件： java：这个可执行程序其实就是JVM，运行Java程序，就是启动JVM，然后让JVM执行指定的编译后的代码； javac：这是Java的编译器，它用于把Java源码文件（以.java后缀结尾）编译为Java字节码文件（以.class后缀结尾）； jar：用于把一组.class文件打包成一个.jar文件，便于发布； javadoc：用于从Java源码中自动提取注释并生成文档； jdb：Java调试器，用于开发阶段的运行调试。 java程序的运行：一个Java源码只能定义一个public类型的class，并且class名称和文件名要完全一致； 使用javac可以将.java源码编译成.class字节码（使用命令：javac Hello.java）； 使用java可以运行一个已编译的Java程序，参数是类名（使用命令：java Hello）。 java编译原理作用是把java程序编写的类和接口编译成字节代码的class文件而java命令程序则是一个解释器，它的作用是把编译后生成的class文件解释成机器能够识别的机器码，并最终由运行环境中的Runtime对代码进行运行，真正实现我们想要机器完成的工作。从截图的帮助文档中我们看到它要执行的是类，是一个和class文件名字完全相同（大小写也要一样）的类 java 命令的作用就是Java虚拟机的作用，虚拟机的功能如下： 通过 ClassLoader 寻找和装载 class 文件 解释字节码成为指令并执行，提供 class 文件的运行环境 进行运行期间垃圾回收 提供与硬件交互的平台 使用IDEIDE是集成开发环境：Integrated Development Environment的缩写。使用IDE的好处在于按，可以把编写代码、组织项目、编译、运行、调试等放到一个环境中运行，能极大地提高开发效率。IDE提升开发效率主要靠以下几点： 编辑器的自动提示，可以大大提高敲代码的速度； 代码修改后可以自动重新编译，并直接运行； 可以方便地进行断点调试。 目前，流行的用于Java开发的IDE有： Eclipse：Eclipse是由IBM开发并捐赠给开源社区的一个IDE，也是目前应用最广泛的IDE。Eclipse的特点是它本身是Java开发的，并且基于插件结构，即使是对Java开发的支持也是通过插件JDT实现的。除了用于Java开发，Eclipse配合插件也可以作为C/C++开发环境、PHP开发环境、Rust开发环境等。 IntelliJ Idea：IntelliJ Idea是由JetBrains公司开发的一个功能强大的IDE，分为免费版和商用付费版。JetBrains公司的IDE平台也是基于IDE平台+语言插件的模式，支持Python开发环境、Ruby开发环境、PHP开发环境等，这些开发环境也分为免费版和付费版。 NetBeans：NetBeans是最早由SUN开发的开源IDE，由于使用人数较少，目前已不再流行。]]></content>
      <categories>
        <category>Java</category>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
